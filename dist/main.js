
(function(l, r) { if (l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (window.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(window.document);
(function () {
    'use strict';

    function noop() { }
    function add_location(element, file, line, column, char) {
        element.__svelte_meta = {
            loc: { file, line, column, char }
        };
    }
    function run(fn) {
        return fn();
    }
    function blank_object() {
        return Object.create(null);
    }
    function run_all(fns) {
        fns.forEach(run);
    }
    function is_function(thing) {
        return typeof thing === 'function';
    }
    function safe_not_equal(a, b) {
        return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
    }
    function is_empty(obj) {
        return Object.keys(obj).length === 0;
    }
    function validate_store(store, name) {
        if (store != null && typeof store.subscribe !== 'function') {
            throw new Error(`'${name}' is not a store with a 'subscribe' method`);
        }
    }
    function subscribe(store, ...callbacks) {
        if (store == null) {
            return noop;
        }
        const unsub = store.subscribe(...callbacks);
        return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
    }
    function component_subscribe(component, store, callback) {
        component.$$.on_destroy.push(subscribe(store, callback));
    }

    function append(target, node) {
        target.appendChild(node);
    }
    function insert(target, node, anchor) {
        target.insertBefore(node, anchor || null);
    }
    function detach(node) {
        node.parentNode.removeChild(node);
    }
    function element(name) {
        return document.createElement(name);
    }
    function text(data) {
        return document.createTextNode(data);
    }
    function space() {
        return text(' ');
    }
    function listen(node, event, handler, options) {
        node.addEventListener(event, handler, options);
        return () => node.removeEventListener(event, handler, options);
    }
    function attr(node, attribute, value) {
        if (value == null)
            node.removeAttribute(attribute);
        else if (node.getAttribute(attribute) !== value)
            node.setAttribute(attribute, value);
    }
    function children(element) {
        return Array.from(element.childNodes);
    }
    function set_style(node, key, value, important) {
        node.style.setProperty(key, value, important ? 'important' : '');
    }
    function custom_event(type, detail) {
        const e = document.createEvent('CustomEvent');
        e.initCustomEvent(type, false, false, detail);
        return e;
    }

    let current_component;
    function set_current_component(component) {
        current_component = component;
    }
    function get_current_component() {
        if (!current_component)
            throw new Error('Function called outside component initialization');
        return current_component;
    }
    function onMount(fn) {
        get_current_component().$$.on_mount.push(fn);
    }
    function afterUpdate(fn) {
        get_current_component().$$.after_update.push(fn);
    }

    const dirty_components = [];
    const binding_callbacks = [];
    const render_callbacks = [];
    const flush_callbacks = [];
    const resolved_promise = Promise.resolve();
    let update_scheduled = false;
    function schedule_update() {
        if (!update_scheduled) {
            update_scheduled = true;
            resolved_promise.then(flush);
        }
    }
    function tick() {
        schedule_update();
        return resolved_promise;
    }
    function add_render_callback(fn) {
        render_callbacks.push(fn);
    }
    let flushing = false;
    const seen_callbacks = new Set();
    function flush() {
        if (flushing)
            return;
        flushing = true;
        do {
            // first, call beforeUpdate functions
            // and update components
            for (let i = 0; i < dirty_components.length; i += 1) {
                const component = dirty_components[i];
                set_current_component(component);
                update(component.$$);
            }
            set_current_component(null);
            dirty_components.length = 0;
            while (binding_callbacks.length)
                binding_callbacks.pop()();
            // then, once components are updated, call
            // afterUpdate functions. This may cause
            // subsequent updates...
            for (let i = 0; i < render_callbacks.length; i += 1) {
                const callback = render_callbacks[i];
                if (!seen_callbacks.has(callback)) {
                    // ...so guard against infinite loops
                    seen_callbacks.add(callback);
                    callback();
                }
            }
            render_callbacks.length = 0;
        } while (dirty_components.length);
        while (flush_callbacks.length) {
            flush_callbacks.pop()();
        }
        update_scheduled = false;
        flushing = false;
        seen_callbacks.clear();
    }
    function update($$) {
        if ($$.fragment !== null) {
            $$.update();
            run_all($$.before_update);
            const dirty = $$.dirty;
            $$.dirty = [-1];
            $$.fragment && $$.fragment.p($$.ctx, dirty);
            $$.after_update.forEach(add_render_callback);
        }
    }
    const outroing = new Set();
    let outros;
    function transition_in(block, local) {
        if (block && block.i) {
            outroing.delete(block);
            block.i(local);
        }
    }
    function transition_out(block, local, detach, callback) {
        if (block && block.o) {
            if (outroing.has(block))
                return;
            outroing.add(block);
            outros.c.push(() => {
                outroing.delete(block);
                if (callback) {
                    if (detach)
                        block.d(1);
                    callback();
                }
            });
            block.o(local);
        }
    }

    const globals = (typeof window !== 'undefined'
        ? window
        : typeof globalThis !== 'undefined'
            ? globalThis
            : global);

    function destroy_block(block, lookup) {
        block.d(1);
        lookup.delete(block.key);
    }
    function update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {
        let o = old_blocks.length;
        let n = list.length;
        let i = o;
        const old_indexes = {};
        while (i--)
            old_indexes[old_blocks[i].key] = i;
        const new_blocks = [];
        const new_lookup = new Map();
        const deltas = new Map();
        i = n;
        while (i--) {
            const child_ctx = get_context(ctx, list, i);
            const key = get_key(child_ctx);
            let block = lookup.get(key);
            if (!block) {
                block = create_each_block(key, child_ctx);
                block.c();
            }
            else if (dynamic) {
                block.p(child_ctx, dirty);
            }
            new_lookup.set(key, new_blocks[i] = block);
            if (key in old_indexes)
                deltas.set(key, Math.abs(i - old_indexes[key]));
        }
        const will_move = new Set();
        const did_move = new Set();
        function insert(block) {
            transition_in(block, 1);
            block.m(node, next);
            lookup.set(block.key, block);
            next = block.first;
            n--;
        }
        while (o && n) {
            const new_block = new_blocks[n - 1];
            const old_block = old_blocks[o - 1];
            const new_key = new_block.key;
            const old_key = old_block.key;
            if (new_block === old_block) {
                // do nothing
                next = new_block.first;
                o--;
                n--;
            }
            else if (!new_lookup.has(old_key)) {
                // remove old block
                destroy(old_block, lookup);
                o--;
            }
            else if (!lookup.has(new_key) || will_move.has(new_key)) {
                insert(new_block);
            }
            else if (did_move.has(old_key)) {
                o--;
            }
            else if (deltas.get(new_key) > deltas.get(old_key)) {
                did_move.add(new_key);
                insert(new_block);
            }
            else {
                will_move.add(old_key);
                o--;
            }
        }
        while (o--) {
            const old_block = old_blocks[o];
            if (!new_lookup.has(old_block.key))
                destroy(old_block, lookup);
        }
        while (n)
            insert(new_blocks[n - 1]);
        return new_blocks;
    }
    function validate_each_keys(ctx, list, get_context, get_key) {
        const keys = new Set();
        for (let i = 0; i < list.length; i++) {
            const key = get_key(get_context(ctx, list, i));
            if (keys.has(key)) {
                throw new Error('Cannot have duplicate keys in a keyed each');
            }
            keys.add(key);
        }
    }
    function create_component(block) {
        block && block.c();
    }
    function mount_component(component, target, anchor) {
        const { fragment, on_mount, on_destroy, after_update } = component.$$;
        fragment && fragment.m(target, anchor);
        // onMount happens before the initial afterUpdate
        add_render_callback(() => {
            const new_on_destroy = on_mount.map(run).filter(is_function);
            if (on_destroy) {
                on_destroy.push(...new_on_destroy);
            }
            else {
                // Edge case - component was destroyed immediately,
                // most likely as a result of a binding initialising
                run_all(new_on_destroy);
            }
            component.$$.on_mount = [];
        });
        after_update.forEach(add_render_callback);
    }
    function destroy_component(component, detaching) {
        const $$ = component.$$;
        if ($$.fragment !== null) {
            run_all($$.on_destroy);
            $$.fragment && $$.fragment.d(detaching);
            // TODO null out other refs, including component.$$ (but need to
            // preserve final state?)
            $$.on_destroy = $$.fragment = null;
            $$.ctx = [];
        }
    }
    function make_dirty(component, i) {
        if (component.$$.dirty[0] === -1) {
            dirty_components.push(component);
            schedule_update();
            component.$$.dirty.fill(0);
        }
        component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));
    }
    function init(component, options, instance, create_fragment, not_equal, props, dirty = [-1]) {
        const parent_component = current_component;
        set_current_component(component);
        const $$ = component.$$ = {
            fragment: null,
            ctx: null,
            // state
            props,
            update: noop,
            not_equal,
            bound: blank_object(),
            // lifecycle
            on_mount: [],
            on_destroy: [],
            before_update: [],
            after_update: [],
            context: new Map(parent_component ? parent_component.$$.context : []),
            // everything else
            callbacks: blank_object(),
            dirty,
            skip_bound: false
        };
        let ready = false;
        $$.ctx = instance
            ? instance(component, options.props || {}, (i, ret, ...rest) => {
                const value = rest.length ? rest[0] : ret;
                if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
                    if (!$$.skip_bound && $$.bound[i])
                        $$.bound[i](value);
                    if (ready)
                        make_dirty(component, i);
                }
                return ret;
            })
            : [];
        $$.update();
        ready = true;
        run_all($$.before_update);
        // `false` as a special case of no DOM component
        $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
        if (options.target) {
            if (options.hydrate) {
                const nodes = children(options.target);
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.l(nodes);
                nodes.forEach(detach);
            }
            else {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.c();
            }
            if (options.intro)
                transition_in(component.$$.fragment);
            mount_component(component, options.target, options.anchor);
            flush();
        }
        set_current_component(parent_component);
    }
    /**
     * Base class for Svelte components. Used when dev=false.
     */
    class SvelteComponent {
        $destroy() {
            destroy_component(this, 1);
            this.$destroy = noop;
        }
        $on(type, callback) {
            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
            callbacks.push(callback);
            return () => {
                const index = callbacks.indexOf(callback);
                if (index !== -1)
                    callbacks.splice(index, 1);
            };
        }
        $set($$props) {
            if (this.$$set && !is_empty($$props)) {
                this.$$.skip_bound = true;
                this.$$set($$props);
                this.$$.skip_bound = false;
            }
        }
    }

    function dispatch_dev(type, detail) {
        document.dispatchEvent(custom_event(type, Object.assign({ version: '3.32.3' }, detail)));
    }
    function append_dev(target, node) {
        dispatch_dev('SvelteDOMInsert', { target, node });
        append(target, node);
    }
    function insert_dev(target, node, anchor) {
        dispatch_dev('SvelteDOMInsert', { target, node, anchor });
        insert(target, node, anchor);
    }
    function detach_dev(node) {
        dispatch_dev('SvelteDOMRemove', { node });
        detach(node);
    }
    function listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {
        const modifiers = options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];
        if (has_prevent_default)
            modifiers.push('preventDefault');
        if (has_stop_propagation)
            modifiers.push('stopPropagation');
        dispatch_dev('SvelteDOMAddEventListener', { node, event, handler, modifiers });
        const dispose = listen(node, event, handler, options);
        return () => {
            dispatch_dev('SvelteDOMRemoveEventListener', { node, event, handler, modifiers });
            dispose();
        };
    }
    function attr_dev(node, attribute, value) {
        attr(node, attribute, value);
        if (value == null)
            dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });
        else
            dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });
    }
    function set_data_dev(text, data) {
        data = '' + data;
        if (text.wholeText === data)
            return;
        dispatch_dev('SvelteDOMSetData', { node: text, data });
        text.data = data;
    }
    function validate_each_argument(arg) {
        if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {
            let msg = '{#each} only iterates over array-like objects.';
            if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {
                msg += ' You can use a spread to convert this iterable into an array.';
            }
            throw new Error(msg);
        }
    }
    function validate_slots(name, slot, keys) {
        for (const slot_key of Object.keys(slot)) {
            if (!~keys.indexOf(slot_key)) {
                console.warn(`<${name}> received an unexpected slot "${slot_key}".`);
            }
        }
    }
    /**
     * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.
     */
    class SvelteComponentDev extends SvelteComponent {
        constructor(options) {
            if (!options || (!options.target && !options.$$inline)) {
                throw new Error("'target' is a required option");
            }
            super();
        }
        $destroy() {
            super.$destroy();
            this.$destroy = () => {
                console.warn('Component was already destroyed'); // eslint-disable-line no-console
            };
        }
        $capture_state() { }
        $inject_state() { }
    }

    const subscriber_queue = [];
    /**
     * Create a `Writable` store that allows both updating and reading by subscription.
     * @param {*=}value initial value
     * @param {StartStopNotifier=}start start and stop notifications for subscriptions
     */
    function writable(value, start = noop) {
        let stop;
        const subscribers = [];
        function set(new_value) {
            if (safe_not_equal(value, new_value)) {
                value = new_value;
                if (stop) { // store is ready
                    const run_queue = !subscriber_queue.length;
                    for (let i = 0; i < subscribers.length; i += 1) {
                        const s = subscribers[i];
                        s[1]();
                        subscriber_queue.push(s, value);
                    }
                    if (run_queue) {
                        for (let i = 0; i < subscriber_queue.length; i += 2) {
                            subscriber_queue[i][0](subscriber_queue[i + 1]);
                        }
                        subscriber_queue.length = 0;
                    }
                }
            }
        }
        function update(fn) {
            set(fn(value));
        }
        function subscribe(run, invalidate = noop) {
            const subscriber = [run, invalidate];
            subscribers.push(subscriber);
            if (subscribers.length === 1) {
                stop = start(set) || noop;
            }
            run(value);
            return () => {
                const index = subscribers.indexOf(subscriber);
                if (index !== -1) {
                    subscribers.splice(index, 1);
                }
                if (subscribers.length === 0) {
                    stop();
                    stop = null;
                }
            };
        }
        return { set, update, subscribe };
    }

    //Insert store variables here
    const count = writable(0);

    /* src\components\SideLeft.svelte generated by Svelte v3.32.3 */

    const file = "src\\components\\SideLeft.svelte";

    function create_fragment(ctx) {
    	let div1;
    	let div0;

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			div0.textContent = "123";
    			add_location(div0, file, 7, 4, 149);
    			attr_dev(div1, "class", "lt:hidden  sm:block  border-soild border-8 borderborder-red-300 bg-red-200");
    			set_style(div1, "width", "240px");
    			add_location(div1, file, 3, 0, 23);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance($$self, $$props) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("SideLeft", slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<SideLeft> was created with unknown prop '${key}'`);
    	});

    	return [];
    }

    class SideLeft extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance, create_fragment, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SideLeft",
    			options,
    			id: create_fragment.name
    		});
    	}
    }

    /* src\components\Editor.svelte generated by Svelte v3.32.3 */

    const { console: console_1 } = globals;
    const file$1 = "src\\components\\Editor.svelte";

    function create_fragment$1(ctx) {
    	let div4;
    	let div0;
    	let t0;
    	let div2;
    	let div1;
    	let button0;
    	let i0;
    	let t1;
    	let button1;
    	let i1;
    	let t2;
    	let button2;
    	let i2;
    	let t3;
    	let button3;
    	let i3;
    	let t4;
    	let button4;
    	let i4;
    	let t5;
    	let button5;
    	let i5;
    	let t6;
    	let div3;
    	let t7;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div4 = element("div");
    			div0 = element("div");
    			t0 = space();
    			div2 = element("div");
    			div1 = element("div");
    			button0 = element("button");
    			i0 = element("i");
    			t1 = space();
    			button1 = element("button");
    			i1 = element("i");
    			t2 = space();
    			button2 = element("button");
    			i2 = element("i");
    			t3 = space();
    			button3 = element("button");
    			i3 = element("i");
    			t4 = space();
    			button4 = element("button");
    			i4 = element("i");
    			t5 = space();
    			button5 = element("button");
    			i5 = element("i");
    			t6 = space();
    			div3 = element("div");
    			t7 = text(/*eContent*/ ctx[0]);
    			attr_dev(div0, "id", "msgInputContainer");
    			attr_dev(div0, "class", "msgInputContainer min-h-32 max-h-64   overflow-y-auto overflow-x-hidden focus:outline-none  svelte-yws4zs");
    			attr_dev(div0, "contenteditable", "true");
    			if (/*eContent*/ ctx[0] === void 0) add_render_callback(() => /*div0_input_handler*/ ctx[6].call(div0));
    			add_location(div0, file$1, 281, 4, 10822);
    			attr_dev(i0, "class", "ri-hashtag");
    			add_location(i0, file$1, 291, 17, 11273);
    			attr_dev(button0, "class", "rounded-sm hover:bg-gray-200 p-1 focus:outline-none");
    			add_location(button0, file$1, 290, 12, 11187);
    			attr_dev(i1, "class", "ri-list-check");
    			add_location(i1, file$1, 295, 37, 11457);
    			attr_dev(button1, "class", "rounded-sm hover:bg-gray-200 p-1 focus:outline-none");
    			add_location(button1, file$1, 293, 12, 11334);
    			attr_dev(i2, "class", "ri-list-ordered");
    			add_location(i2, file$1, 299, 37, 11625);
    			attr_dev(button2, "class", "rounded-sm hover:bg-gray-200 p-1");
    			add_location(button2, file$1, 297, 12, 11521);
    			attr_dev(i3, "class", "ri-bold");
    			add_location(i3, file$1, 302, 17, 11774);
    			attr_dev(button3, "class", "rounded-sm hover:bg-gray-200 p-1");
    			add_location(button3, file$1, 301, 12, 11691);
    			attr_dev(i4, "class", "ri-underline");
    			add_location(i4, file$1, 305, 17, 11899);
    			attr_dev(button4, "class", "rounded-sm hover:bg-gray-200 p-1");
    			add_location(button4, file$1, 304, 12, 11832);
    			attr_dev(i5, "class", "ri-image-2-line");
    			add_location(i5, file$1, 308, 17, 12029);
    			attr_dev(button5, "class", "rounded-sm hover:bg-gray-200 p-1");
    			add_location(button5, file$1, 307, 12, 11962);
    			attr_dev(div1, "id", "toolbar-container");
    			attr_dev(div1, "class", "space-x-1");
    			add_location(div1, file$1, 289, 8, 11127);
    			attr_dev(div2, "class", " flex justify-between  mt-4");
    			add_location(div2, file$1, 288, 4, 11076);
    			add_location(div3, file$1, 312, 4, 12115);
    			attr_dev(div4, "class", "border-gray-200 border-solid border-4 rounded-lg mt-2 p-2");
    			add_location(div4, file$1, 280, 0, 10745);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div4, anchor);
    			append_dev(div4, div0);
    			/*div0_binding*/ ctx[5](div0);

    			if (/*eContent*/ ctx[0] !== void 0) {
    				div0.innerHTML = /*eContent*/ ctx[0];
    			}

    			append_dev(div4, t0);
    			append_dev(div4, div2);
    			append_dev(div2, div1);
    			append_dev(div1, button0);
    			append_dev(button0, i0);
    			append_dev(div1, t1);
    			append_dev(div1, button1);
    			append_dev(button1, i1);
    			append_dev(div1, t2);
    			append_dev(div1, button2);
    			append_dev(button2, i2);
    			append_dev(div1, t3);
    			append_dev(div1, button3);
    			append_dev(button3, i3);
    			append_dev(div1, t4);
    			append_dev(div1, button4);
    			append_dev(button4, i4);
    			append_dev(div1, t5);
    			append_dev(div1, button5);
    			append_dev(button5, i5);
    			append_dev(div4, t6);
    			append_dev(div4, div3);
    			append_dev(div3, t7);

    			if (!mounted) {
    				dispose = [
    					listen_dev(div0, "input", /*div0_input_handler*/ ctx[6]),
    					listen_dev(button1, "click", /*listcheck*/ ctx[2], false, false, false),
    					listen_dev(button2, "click", /*listorder*/ ctx[3], false, false, false),
    					listen_dev(button3, "click", /*bold*/ ctx[4], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*eContent*/ 1 && /*eContent*/ ctx[0] !== div0.innerHTML) {
    				div0.innerHTML = /*eContent*/ ctx[0];
    			}

    			if (dirty & /*eContent*/ 1) set_data_dev(t7, /*eContent*/ ctx[0]);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div4);
    			/*div0_binding*/ ctx[5](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function get1LevelNodePosition(selection) {
    	let cNode = selection.focusNode;

    	if (cNode == null || cNode.id == "msgInputContainer") {
    		console.log("return ", "null");
    		return null;
    	}

    	if (cNode.type) ;

    	while (true) {
    		if (cNode.parentNode.id == "msgInputContainer") {
    			console.log("return ", cNode, cNode.nextElementSibling);

    			return {
    				node: cNode,
    				nextnode: cNode.nextElementSibling
    			};
    		} else {
    			cNode = cNode.parentNode;
    		}
    	}
    }

    function hashtag(params) {
    	
    }

    function toli(inNode) {
    	
    }

    function underline(params) {
    	
    }

    function picture(params) {
    	
    }

    function moveRange(liNode) {
    	let selection = window.getSelection();

    	// 创建新的光标对象
    	var range = document.createRange();

    	// 光标对象的范围界定为新建的表情节点
    	range.selectNodeContents(liNode);

    	// 光标位置定位在表情节点的最大长度
    	console.log("liNode.length", liNode.length);

    	range.setStart(liNode, 0);

    	// range.setEnd(liNode, 0);
    	// 使光标开始和光标结束重叠
    	range.collapse(true);

    	// 清除选定对象的所有光标对象
    	selection.removeAllRanges();

    	// 插入新的光标对象
    	selection.collapse(liNode, 0);

    	selection.addRange(range);
    }

    function instance$1($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Editor", slots, []);
    	let editor = "";

    	afterUpdate(async () => {
    		
    	}); // await tick();
    	// editor.focus();

    	onMount(() => {
    		
    	}); // editor.focus();
    	// let selection = getSelection();
    	// console.log(selection, selection.focusNode.length);
    	// selection.setPosition(selection.focusNode, selection.focusNode.length);

    	let lastEditRange;
    	let eContent = ``;
    	let bolding = false;

    	async function listcheck(params) {
    		editor.focus();
    		let selection = getSelection();
    		console.log("selection", selection);

    		//判断当前属于div,ol,还是ul
    		let inNode = get1LevelNodePosition(selection);

    		if (inNode == null || inNode.nextnode == null) {
    			addli(null);
    		} else if (inNode.node.nodeName == "OL") {
    			//将有序列表变成普通列表
    			let selection = getSelection();

    			let cNode = selection.focusNode;
    			let targetNode = "";

    			//获得光标所在的li
    			while (true) {
    				if (cNode.nodeName == "LI") {
    					targetNode = cNode;
    					break;
    				} else {
    					cNode = cNode.parentNode;
    				}
    			}
    			let geted = false;
    			let newNode = document.createElement("div");
    			let newNextNode = document.createElement("ol");
    			newNextNode.className = "list-decimal list-inside";

    			//获得光标所在的li的位置
    			for (let index = 0; index < inNode.node.children.length; index++) {
    				const element = inNode.node.children[index];

    				if (element.isSameNode(targetNode)) {
    					geted = true;
    					let a = targetNode.childNodes.length;

    					for (let i = 0; i < a; i++) {
    						let elementaa = targetNode.childNodes[i].cloneNode(true);
    						newNode.appendChild(elementaa);
    					}

    					editor.insertBefore(newNode, inNode.nextnode);
    					continue;
    				}

    				if (geted) {
    					newNextNode.appendChild(element.cloneNode(true));
    				}
    			}

    			console.log("newNextNode", newNextNode);
    			inNode.node.removeChild(targetNode);

    			if (inNode.node.childNodes.length == 0) {
    				//如果移除后ol内为空,移除这个空的ol
    				editor.removeChild(inNode.node);
    			} else {
    				//移除目标节点后面的li
    				let a = newNextNode.childNodes.length;

    				for (let i = 0; i < a; i++) {
    					inNode.node.removeChild(inNode.node.lastChild);
    				}
    			}

    			//将目标节点后面的li集中到新的ol中并插入
    			editor.insertBefore(newNextNode, newNode.nextElementSibling);

    			moveRange(newNode);
    		} else if (inNode.node.nodeName == "DIV") {
    			let olNode = document.createElement("ol");
    			olNode.className = "list-decimal list-inside";
    			let liNode = document.createElement("li");
    			let a = inNode.node.childNodes.length;

    			for (let i = 0; i < a; i++) {
    				let elementaa = inNode.node.childNodes[i].cloneNode(true);
    				liNode.appendChild(elementaa);
    			}

    			olNode.appendChild(liNode);
    			editor.insertBefore(olNode, inNode.nextnode);
    			editor.removeChild(inNode.node);
    			moveRange(liNode);
    		} else if (inNode.node.nodeName == "#text") {
    			addli(inNode.nextnode);
    		} else if (inNode.node.nodeName == "UL") {
    			//将无序列表变成有序列表
    			let olNode = document.createElement("ol");

    			olNode.className = "list-decimal list-inside";
    			console.log(inNode.node.children.length);
    			let a = inNode.node.children.length;

    			for (let i = 0; i < a; i++) {
    				let element = inNode.node.children[i].cloneNode(true);
    				console.log(i, element, inNode.node.children.length);
    				olNode.appendChild(element);
    			}

    			inNode.node.parentNode.replaceChild(olNode, inNode.node);
    		}
    	}

    	function addli(inNode) {
    		let olNode = document.createElement("ol");
    		olNode.className = "list-decimal list-inside";
    		let liNode = document.createElement("li");
    		olNode.appendChild(liNode);

    		if (inNode == null) {
    			editor.appendChild(olNode);
    		} else {
    			editor.insertBefore(olNode, inNode);
    		}

    		moveRange(liNode);
    	}

    	function addul(inNode) {
    		let olNode = document.createElement("ul");
    		olNode.className = "list-disc list-inside";
    		let liNode = document.createElement("li");
    		olNode.appendChild(liNode);

    		if (inNode == null) {
    			editor.appendChild(olNode);
    		} else {
    			editor.insertBefore(olNode, inNode);
    		}

    		moveRange(liNode);
    	}

    	function listorder(params) {
    		editor.focus();
    		let selection = getSelection();
    		console.log("selection", selection);

    		//判断当前属于div,ol,还是ul
    		let inNode = get1LevelNodePosition(selection);

    		if (inNode == null || inNode.nextnode == null) {
    			addul(null);
    		} else if (inNode.node.nodeName == "UL") {
    			//将无序列表变成普通列表
    			let selection = getSelection();

    			let cNode = selection.focusNode;
    			let targetNode = "";

    			//获得光标所在的li
    			while (true) {
    				if (cNode.nodeName == "LI") {
    					targetNode = cNode;
    					break;
    				} else {
    					cNode = cNode.parentNode;
    				}
    			}
    			let geted = false;
    			let newNode = document.createElement("div");
    			let newNextNode = document.createElement("ul");
    			newNextNode.className = "list-disc list-inside";

    			//获得光标所在的li的位置
    			for (let index = 0; index < inNode.node.children.length; index++) {
    				const element = inNode.node.children[index];

    				if (element.isSameNode(targetNode)) {
    					geted = true;
    					let a = targetNode.childNodes.length;

    					for (let i = 0; i < a; i++) {
    						let elementaa = targetNode.childNodes[i].cloneNode(true);
    						newNode.appendChild(elementaa);
    					}

    					editor.insertBefore(newNode, inNode.nextnode);
    					continue;
    				}

    				if (geted) {
    					newNextNode.appendChild(element.cloneNode(true));
    				}
    			}

    			console.log("newNextNode", newNextNode);
    			inNode.node.removeChild(targetNode);

    			if (inNode.node.childNodes.length == 0) {
    				//如果移除后ol内为空,移除这个空的ol
    				editor.removeChild(inNode.node);
    			} else {
    				//移除目标节点后面的li
    				let a = newNextNode.childNodes.length;

    				for (let i = 0; i < a; i++) {
    					inNode.node.removeChild(inNode.node.lastChild);
    				}
    			}

    			//将目标节点后面的li集中到新的ol中并插入
    			editor.insertBefore(newNextNode, newNode.nextElementSibling);

    			moveRange(newNode);
    		} else if (inNode.node.nodeName == "DIV") {
    			let olNode = document.createElement("ul");
    			olNode.className = "list-disc list-inside";
    			let liNode = document.createElement("li");
    			let a = inNode.node.childNodes.length;

    			for (let i = 0; i < a; i++) {
    				let elementaa = inNode.node.childNodes[i].cloneNode(true);
    				liNode.appendChild(elementaa);
    			}

    			olNode.appendChild(liNode);
    			editor.insertBefore(olNode, inNode.nextnode);
    			editor.removeChild(inNode.node);
    			moveRange(liNode);
    		} else if (inNode.node.nodeName == "#text") {
    			addli(inNode.nextnode);
    		} else if (inNode.node.nodeName == "OL") {
    			//将无序列表变成有序列表
    			let olNode = document.createElement("ul");

    			olNode.className = "list-disc list-inside";
    			console.log(inNode.node.children.length);
    			let a = inNode.node.children.length;

    			for (let i = 0; i < a; i++) {
    				let element = inNode.node.children[i].cloneNode(true);
    				console.log(i, element, inNode.node.children.length);
    				olNode.appendChild(element);
    			}

    			inNode.node.parentNode.replaceChild(olNode, inNode.node);
    		}
    	}

    	async function bold(params) {
    		editor.focus();
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1.warn(`<Editor> was created with unknown prop '${key}'`);
    	});

    	function div0_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			editor = $$value;
    			$$invalidate(1, editor);
    		});
    	}

    	function div0_input_handler() {
    		eContent = this.innerHTML;
    		$$invalidate(0, eContent);
    	}

    	$$self.$capture_state = () => ({
    		onMount,
    		editor,
    		afterUpdate,
    		tick,
    		lastEditRange,
    		eContent,
    		bolding,
    		get1LevelNodePosition,
    		hashtag,
    		listcheck,
    		addli,
    		addul,
    		toli,
    		listorder,
    		bold,
    		underline,
    		picture,
    		moveRange
    	});

    	$$self.$inject_state = $$props => {
    		if ("editor" in $$props) $$invalidate(1, editor = $$props.editor);
    		if ("lastEditRange" in $$props) lastEditRange = $$props.lastEditRange;
    		if ("eContent" in $$props) $$invalidate(0, eContent = $$props.eContent);
    		if ("bolding" in $$props) bolding = $$props.bolding;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*eContent*/ 1) {
    			 {
    				console.log(eContent);
    			}
    		}
    	};

    	return [eContent, editor, listcheck, listorder, bold, div0_binding, div0_input_handler];
    }

    class Editor extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1, create_fragment$1, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Editor",
    			options,
    			id: create_fragment$1.name
    		});
    	}
    }

    // ::- Persistent data structure representing an ordered mapping from
    // strings to values, with some convenient update methods.
    function OrderedMap(content) {
      this.content = content;
    }

    OrderedMap.prototype = {
      constructor: OrderedMap,

      find: function(key) {
        for (var i = 0; i < this.content.length; i += 2)
          if (this.content[i] === key) return i
        return -1
      },

      // :: (string) → ?any
      // Retrieve the value stored under `key`, or return undefined when
      // no such key exists.
      get: function(key) {
        var found = this.find(key);
        return found == -1 ? undefined : this.content[found + 1]
      },

      // :: (string, any, ?string) → OrderedMap
      // Create a new map by replacing the value of `key` with a new
      // value, or adding a binding to the end of the map. If `newKey` is
      // given, the key of the binding will be replaced with that key.
      update: function(key, value, newKey) {
        var self = newKey && newKey != key ? this.remove(newKey) : this;
        var found = self.find(key), content = self.content.slice();
        if (found == -1) {
          content.push(newKey || key, value);
        } else {
          content[found + 1] = value;
          if (newKey) content[found] = newKey;
        }
        return new OrderedMap(content)
      },

      // :: (string) → OrderedMap
      // Return a map with the given key removed, if it existed.
      remove: function(key) {
        var found = this.find(key);
        if (found == -1) return this
        var content = this.content.slice();
        content.splice(found, 2);
        return new OrderedMap(content)
      },

      // :: (string, any) → OrderedMap
      // Add a new key to the start of the map.
      addToStart: function(key, value) {
        return new OrderedMap([key, value].concat(this.remove(key).content))
      },

      // :: (string, any) → OrderedMap
      // Add a new key to the end of the map.
      addToEnd: function(key, value) {
        var content = this.remove(key).content.slice();
        content.push(key, value);
        return new OrderedMap(content)
      },

      // :: (string, string, any) → OrderedMap
      // Add a key after the given key. If `place` is not found, the new
      // key is added to the end.
      addBefore: function(place, key, value) {
        var without = this.remove(key), content = without.content.slice();
        var found = without.find(place);
        content.splice(found == -1 ? content.length : found, 0, key, value);
        return new OrderedMap(content)
      },

      // :: ((key: string, value: any))
      // Call the given function for each key/value pair in the map, in
      // order.
      forEach: function(f) {
        for (var i = 0; i < this.content.length; i += 2)
          f(this.content[i], this.content[i + 1]);
      },

      // :: (union<Object, OrderedMap>) → OrderedMap
      // Create a new map by prepending the keys in this map that don't
      // appear in `map` before the keys in `map`.
      prepend: function(map) {
        map = OrderedMap.from(map);
        if (!map.size) return this
        return new OrderedMap(map.content.concat(this.subtract(map).content))
      },

      // :: (union<Object, OrderedMap>) → OrderedMap
      // Create a new map by appending the keys in this map that don't
      // appear in `map` after the keys in `map`.
      append: function(map) {
        map = OrderedMap.from(map);
        if (!map.size) return this
        return new OrderedMap(this.subtract(map).content.concat(map.content))
      },

      // :: (union<Object, OrderedMap>) → OrderedMap
      // Create a map containing all the keys in this map that don't
      // appear in `map`.
      subtract: function(map) {
        var result = this;
        map = OrderedMap.from(map);
        for (var i = 0; i < map.content.length; i += 2)
          result = result.remove(map.content[i]);
        return result
      },

      // :: number
      // The amount of keys in this map.
      get size() {
        return this.content.length >> 1
      }
    };

    // :: (?union<Object, OrderedMap>) → OrderedMap
    // Return a map with the given content. If null, create an empty
    // map. If given an ordered map, return that map itself. If given an
    // object, create a map from the object's properties.
    OrderedMap.from = function(value) {
      if (value instanceof OrderedMap) return value
      var content = [];
      if (value) for (var prop in value) content.push(prop, value[prop]);
      return new OrderedMap(content)
    };

    var orderedmap = OrderedMap;

    function findDiffStart(a, b, pos) {
      for (var i = 0;; i++) {
        if (i == a.childCount || i == b.childCount)
          { return a.childCount == b.childCount ? null : pos }

        var childA = a.child(i), childB = b.child(i);
        if (childA == childB) { pos += childA.nodeSize; continue }

        if (!childA.sameMarkup(childB)) { return pos }

        if (childA.isText && childA.text != childB.text) {
          for (var j = 0; childA.text[j] == childB.text[j]; j++)
            { pos++; }
          return pos
        }
        if (childA.content.size || childB.content.size) {
          var inner = findDiffStart(childA.content, childB.content, pos + 1);
          if (inner != null) { return inner }
        }
        pos += childA.nodeSize;
      }
    }

    function findDiffEnd(a, b, posA, posB) {
      for (var iA = a.childCount, iB = b.childCount;;) {
        if (iA == 0 || iB == 0)
          { return iA == iB ? null : {a: posA, b: posB} }

        var childA = a.child(--iA), childB = b.child(--iB), size = childA.nodeSize;
        if (childA == childB) {
          posA -= size; posB -= size;
          continue
        }

        if (!childA.sameMarkup(childB)) { return {a: posA, b: posB} }

        if (childA.isText && childA.text != childB.text) {
          var same = 0, minSize = Math.min(childA.text.length, childB.text.length);
          while (same < minSize && childA.text[childA.text.length - same - 1] == childB.text[childB.text.length - same - 1]) {
            same++; posA--; posB--;
          }
          return {a: posA, b: posB}
        }
        if (childA.content.size || childB.content.size) {
          var inner = findDiffEnd(childA.content, childB.content, posA - 1, posB - 1);
          if (inner) { return inner }
        }
        posA -= size; posB -= size;
      }
    }

    // ::- A fragment represents a node's collection of child nodes.
    //
    // Like nodes, fragments are persistent data structures, and you
    // should not mutate them or their content. Rather, you create new
    // instances whenever needed. The API tries to make this easy.
    var Fragment = function Fragment(content, size) {
      this.content = content;
      // :: number
      // The size of the fragment, which is the total of the size of its
      // content nodes.
      this.size = size || 0;
      if (size == null) { for (var i = 0; i < content.length; i++)
        { this.size += content[i].nodeSize; } }
    };

    var prototypeAccessors = { firstChild: { configurable: true },lastChild: { configurable: true },childCount: { configurable: true } };

    // :: (number, number, (node: Node, start: number, parent: Node, index: number) → ?bool, ?number)
    // Invoke a callback for all descendant nodes between the given two
    // positions (relative to start of this fragment). Doesn't descend
    // into a node when the callback returns `false`.
    Fragment.prototype.nodesBetween = function nodesBetween (from, to, f, nodeStart, parent) {
        if ( nodeStart === void 0 ) nodeStart = 0;

      for (var i = 0, pos = 0; pos < to; i++) {
        var child = this.content[i], end = pos + child.nodeSize;
        if (end > from && f(child, nodeStart + pos, parent, i) !== false && child.content.size) {
          var start = pos + 1;
          child.nodesBetween(Math.max(0, from - start),
                             Math.min(child.content.size, to - start),
                             f, nodeStart + start);
        }
        pos = end;
      }
    };

    // :: ((node: Node, pos: number, parent: Node) → ?bool)
    // Call the given callback for every descendant node. The callback
    // may return `false` to prevent traversal of a given node's children.
    Fragment.prototype.descendants = function descendants (f) {
      this.nodesBetween(0, this.size, f);
    };

    // : (number, number, ?string, ?string) → string
    Fragment.prototype.textBetween = function textBetween (from, to, blockSeparator, leafText) {
      var text = "", separated = true;
      this.nodesBetween(from, to, function (node, pos) {
        if (node.isText) {
          text += node.text.slice(Math.max(from, pos) - pos, to - pos);
          separated = !blockSeparator;
        } else if (node.isLeaf && leafText) {
          text += leafText;
          separated = !blockSeparator;
        } else if (!separated && node.isBlock) {
          text += blockSeparator;
          separated = true;
        }
      }, 0);
      return text
    };

    // :: (Fragment) → Fragment
    // Create a new fragment containing the combined content of this
    // fragment and the other.
    Fragment.prototype.append = function append (other) {
      if (!other.size) { return this }
      if (!this.size) { return other }
      var last = this.lastChild, first = other.firstChild, content = this.content.slice(), i = 0;
      if (last.isText && last.sameMarkup(first)) {
        content[content.length - 1] = last.withText(last.text + first.text);
        i = 1;
      }
      for (; i < other.content.length; i++) { content.push(other.content[i]); }
      return new Fragment(content, this.size + other.size)
    };

    // :: (number, ?number) → Fragment
    // Cut out the sub-fragment between the two given positions.
    Fragment.prototype.cut = function cut (from, to) {
      if (to == null) { to = this.size; }
      if (from == 0 && to == this.size) { return this }
      var result = [], size = 0;
      if (to > from) { for (var i = 0, pos = 0; pos < to; i++) {
        var child = this.content[i], end = pos + child.nodeSize;
        if (end > from) {
          if (pos < from || end > to) {
            if (child.isText)
              { child = child.cut(Math.max(0, from - pos), Math.min(child.text.length, to - pos)); }
            else
              { child = child.cut(Math.max(0, from - pos - 1), Math.min(child.content.size, to - pos - 1)); }
          }
          result.push(child);
          size += child.nodeSize;
        }
        pos = end;
      } }
      return new Fragment(result, size)
    };

    Fragment.prototype.cutByIndex = function cutByIndex (from, to) {
      if (from == to) { return Fragment.empty }
      if (from == 0 && to == this.content.length) { return this }
      return new Fragment(this.content.slice(from, to))
    };

    // :: (number, Node) → Fragment
    // Create a new fragment in which the node at the given index is
    // replaced by the given node.
    Fragment.prototype.replaceChild = function replaceChild (index, node) {
      var current = this.content[index];
      if (current == node) { return this }
      var copy = this.content.slice();
      var size = this.size + node.nodeSize - current.nodeSize;
      copy[index] = node;
      return new Fragment(copy, size)
    };

    // : (Node) → Fragment
    // Create a new fragment by prepending the given node to this
    // fragment.
    Fragment.prototype.addToStart = function addToStart (node) {
      return new Fragment([node].concat(this.content), this.size + node.nodeSize)
    };

    // : (Node) → Fragment
    // Create a new fragment by appending the given node to this
    // fragment.
    Fragment.prototype.addToEnd = function addToEnd (node) {
      return new Fragment(this.content.concat(node), this.size + node.nodeSize)
    };

    // :: (Fragment) → bool
    // Compare this fragment to another one.
    Fragment.prototype.eq = function eq (other) {
      if (this.content.length != other.content.length) { return false }
      for (var i = 0; i < this.content.length; i++)
        { if (!this.content[i].eq(other.content[i])) { return false } }
      return true
    };

    // :: ?Node
    // The first child of the fragment, or `null` if it is empty.
    prototypeAccessors.firstChild.get = function () { return this.content.length ? this.content[0] : null };

    // :: ?Node
    // The last child of the fragment, or `null` if it is empty.
    prototypeAccessors.lastChild.get = function () { return this.content.length ? this.content[this.content.length - 1] : null };

    // :: number
    // The number of child nodes in this fragment.
    prototypeAccessors.childCount.get = function () { return this.content.length };

    // :: (number) → Node
    // Get the child node at the given index. Raise an error when the
    // index is out of range.
    Fragment.prototype.child = function child (index) {
      var found = this.content[index];
      if (!found) { throw new RangeError("Index " + index + " out of range for " + this) }
      return found
    };

    // :: (number) → ?Node
    // Get the child node at the given index, if it exists.
    Fragment.prototype.maybeChild = function maybeChild (index) {
      return this.content[index]
    };

    // :: ((node: Node, offset: number, index: number))
    // Call `f` for every child node, passing the node, its offset
    // into this parent node, and its index.
    Fragment.prototype.forEach = function forEach (f) {
      for (var i = 0, p = 0; i < this.content.length; i++) {
        var child = this.content[i];
        f(child, p, i);
        p += child.nodeSize;
      }
    };

    // :: (Fragment) → ?number
    // Find the first position at which this fragment and another
    // fragment differ, or `null` if they are the same.
    Fragment.prototype.findDiffStart = function findDiffStart$1 (other, pos) {
        if ( pos === void 0 ) pos = 0;

      return findDiffStart(this, other, pos)
    };

    // :: (Fragment) → ?{a: number, b: number}
    // Find the first position, searching from the end, at which this
    // fragment and the given fragment differ, or `null` if they are the
    // same. Since this position will not be the same in both nodes, an
    // object with two separate positions is returned.
    Fragment.prototype.findDiffEnd = function findDiffEnd$1 (other, pos, otherPos) {
        if ( pos === void 0 ) pos = this.size;
        if ( otherPos === void 0 ) otherPos = other.size;

      return findDiffEnd(this, other, pos, otherPos)
    };

    // : (number, ?number) → {index: number, offset: number}
    // Find the index and inner offset corresponding to a given relative
    // position in this fragment. The result object will be reused
    // (overwritten) the next time the function is called. (Not public.)
    Fragment.prototype.findIndex = function findIndex (pos, round) {
        if ( round === void 0 ) round = -1;

      if (pos == 0) { return retIndex(0, pos) }
      if (pos == this.size) { return retIndex(this.content.length, pos) }
      if (pos > this.size || pos < 0) { throw new RangeError(("Position " + pos + " outside of fragment (" + (this) + ")")) }
      for (var i = 0, curPos = 0;; i++) {
        var cur = this.child(i), end = curPos + cur.nodeSize;
        if (end >= pos) {
          if (end == pos || round > 0) { return retIndex(i + 1, end) }
          return retIndex(i, curPos)
        }
        curPos = end;
      }
    };

    // :: () → string
    // Return a debugging string that describes this fragment.
    Fragment.prototype.toString = function toString () { return "<" + this.toStringInner() + ">" };

    Fragment.prototype.toStringInner = function toStringInner () { return this.content.join(", ") };

    // :: () → ?Object
    // Create a JSON-serializeable representation of this fragment.
    Fragment.prototype.toJSON = function toJSON () {
      return this.content.length ? this.content.map(function (n) { return n.toJSON(); }) : null
    };

    // :: (Schema, ?Object) → Fragment
    // Deserialize a fragment from its JSON representation.
    Fragment.fromJSON = function fromJSON (schema, value) {
      if (!value) { return Fragment.empty }
      if (!Array.isArray(value)) { throw new RangeError("Invalid input for Fragment.fromJSON") }
      return new Fragment(value.map(schema.nodeFromJSON))
    };

    // :: ([Node]) → Fragment
    // Build a fragment from an array of nodes. Ensures that adjacent
    // text nodes with the same marks are joined together.
    Fragment.fromArray = function fromArray (array) {
      if (!array.length) { return Fragment.empty }
      var joined, size = 0;
      for (var i = 0; i < array.length; i++) {
        var node = array[i];
        size += node.nodeSize;
        if (i && node.isText && array[i - 1].sameMarkup(node)) {
          if (!joined) { joined = array.slice(0, i); }
          joined[joined.length - 1] = node.withText(joined[joined.length - 1].text + node.text);
        } else if (joined) {
          joined.push(node);
        }
      }
      return new Fragment(joined || array, size)
    };

    // :: (?union<Fragment, Node, [Node]>) → Fragment
    // Create a fragment from something that can be interpreted as a set
    // of nodes. For `null`, it returns the empty fragment. For a
    // fragment, the fragment itself. For a node or array of nodes, a
    // fragment containing those nodes.
    Fragment.from = function from (nodes) {
      if (!nodes) { return Fragment.empty }
      if (nodes instanceof Fragment) { return nodes }
      if (Array.isArray(nodes)) { return this.fromArray(nodes) }
      if (nodes.attrs) { return new Fragment([nodes], nodes.nodeSize) }
      throw new RangeError("Can not convert " + nodes + " to a Fragment" +
                           (nodes.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : ""))
    };

    Object.defineProperties( Fragment.prototype, prototypeAccessors );

    var found = {index: 0, offset: 0};
    function retIndex(index, offset) {
      found.index = index;
      found.offset = offset;
      return found
    }

    // :: Fragment
    // An empty fragment. Intended to be reused whenever a node doesn't
    // contain anything (rather than allocating a new empty fragment for
    // each leaf node).
    Fragment.empty = new Fragment([], 0);

    function compareDeep(a, b) {
      if (a === b) { return true }
      if (!(a && typeof a == "object") ||
          !(b && typeof b == "object")) { return false }
      var array = Array.isArray(a);
      if (Array.isArray(b) != array) { return false }
      if (array) {
        if (a.length != b.length) { return false }
        for (var i = 0; i < a.length; i++) { if (!compareDeep(a[i], b[i])) { return false } }
      } else {
        for (var p in a) { if (!(p in b) || !compareDeep(a[p], b[p])) { return false } }
        for (var p$1 in b) { if (!(p$1 in a)) { return false } }
      }
      return true
    }

    // ::- A mark is a piece of information that can be attached to a node,
    // such as it being emphasized, in code font, or a link. It has a type
    // and optionally a set of attributes that provide further information
    // (such as the target of the link). Marks are created through a
    // `Schema`, which controls which types exist and which
    // attributes they have.
    var Mark = function Mark(type, attrs) {
      // :: MarkType
      // The type of this mark.
      this.type = type;
      // :: Object
      // The attributes associated with this mark.
      this.attrs = attrs;
    };

    // :: ([Mark]) → [Mark]
    // Given a set of marks, create a new set which contains this one as
    // well, in the right position. If this mark is already in the set,
    // the set itself is returned. If any marks that are set to be
    // [exclusive](#model.MarkSpec.excludes) with this mark are present,
    // those are replaced by this one.
    Mark.prototype.addToSet = function addToSet (set) {
      var copy, placed = false;
      for (var i = 0; i < set.length; i++) {
        var other = set[i];
        if (this.eq(other)) { return set }
        if (this.type.excludes(other.type)) {
          if (!copy) { copy = set.slice(0, i); }
        } else if (other.type.excludes(this.type)) {
          return set
        } else {
          if (!placed && other.type.rank > this.type.rank) {
            if (!copy) { copy = set.slice(0, i); }
            copy.push(this);
            placed = true;
          }
          if (copy) { copy.push(other); }
        }
      }
      if (!copy) { copy = set.slice(); }
      if (!placed) { copy.push(this); }
      return copy
    };

    // :: ([Mark]) → [Mark]
    // Remove this mark from the given set, returning a new set. If this
    // mark is not in the set, the set itself is returned.
    Mark.prototype.removeFromSet = function removeFromSet (set) {
      for (var i = 0; i < set.length; i++)
        { if (this.eq(set[i]))
          { return set.slice(0, i).concat(set.slice(i + 1)) } }
      return set
    };

    // :: ([Mark]) → bool
    // Test whether this mark is in the given set of marks.
    Mark.prototype.isInSet = function isInSet (set) {
      for (var i = 0; i < set.length; i++)
        { if (this.eq(set[i])) { return true } }
      return false
    };

    // :: (Mark) → bool
    // Test whether this mark has the same type and attributes as
    // another mark.
    Mark.prototype.eq = function eq (other) {
      return this == other ||
        (this.type == other.type && compareDeep(this.attrs, other.attrs))
    };

    // :: () → Object
    // Convert this mark to a JSON-serializeable representation.
    Mark.prototype.toJSON = function toJSON () {
      var obj = {type: this.type.name};
      for (var _ in this.attrs) {
        obj.attrs = this.attrs;
        break
      }
      return obj
    };

    // :: (Schema, Object) → Mark
    Mark.fromJSON = function fromJSON (schema, json) {
      if (!json) { throw new RangeError("Invalid input for Mark.fromJSON") }
      var type = schema.marks[json.type];
      if (!type) { throw new RangeError(("There is no mark type " + (json.type) + " in this schema")) }
      return type.create(json.attrs)
    };

    // :: ([Mark], [Mark]) → bool
    // Test whether two sets of marks are identical.
    Mark.sameSet = function sameSet (a, b) {
      if (a == b) { return true }
      if (a.length != b.length) { return false }
      for (var i = 0; i < a.length; i++)
        { if (!a[i].eq(b[i])) { return false } }
      return true
    };

    // :: (?union<Mark, [Mark]>) → [Mark]
    // Create a properly sorted mark set from null, a single mark, or an
    // unsorted array of marks.
    Mark.setFrom = function setFrom (marks) {
      if (!marks || marks.length == 0) { return Mark.none }
      if (marks instanceof Mark) { return [marks] }
      var copy = marks.slice();
      copy.sort(function (a, b) { return a.type.rank - b.type.rank; });
      return copy
    };

    // :: [Mark] The empty set of marks.
    Mark.none = [];

    // ReplaceError:: class extends Error
    // Error type raised by [`Node.replace`](#model.Node.replace) when
    // given an invalid replacement.

    function ReplaceError(message) {
      var err = Error.call(this, message);
      err.__proto__ = ReplaceError.prototype;
      return err
    }

    ReplaceError.prototype = Object.create(Error.prototype);
    ReplaceError.prototype.constructor = ReplaceError;
    ReplaceError.prototype.name = "ReplaceError";

    // ::- A slice represents a piece cut out of a larger document. It
    // stores not only a fragment, but also the depth up to which nodes on
    // both side are ‘open’ (cut through).
    var Slice = function Slice(content, openStart, openEnd) {
      // :: Fragment The slice's content.
      this.content = content;
      // :: number The open depth at the start.
      this.openStart = openStart;
      // :: number The open depth at the end.
      this.openEnd = openEnd;
    };

    var prototypeAccessors$1 = { size: { configurable: true } };

    // :: number
    // The size this slice would add when inserted into a document.
    prototypeAccessors$1.size.get = function () {
      return this.content.size - this.openStart - this.openEnd
    };

    Slice.prototype.insertAt = function insertAt (pos, fragment) {
      var content = insertInto(this.content, pos + this.openStart, fragment, null);
      return content && new Slice(content, this.openStart, this.openEnd)
    };

    Slice.prototype.removeBetween = function removeBetween (from, to) {
      return new Slice(removeRange(this.content, from + this.openStart, to + this.openStart), this.openStart, this.openEnd)
    };

    // :: (Slice) → bool
    // Tests whether this slice is equal to another slice.
    Slice.prototype.eq = function eq (other) {
      return this.content.eq(other.content) && this.openStart == other.openStart && this.openEnd == other.openEnd
    };

    Slice.prototype.toString = function toString () {
      return this.content + "(" + this.openStart + "," + this.openEnd + ")"
    };

    // :: () → ?Object
    // Convert a slice to a JSON-serializable representation.
    Slice.prototype.toJSON = function toJSON () {
      if (!this.content.size) { return null }
      var json = {content: this.content.toJSON()};
      if (this.openStart > 0) { json.openStart = this.openStart; }
      if (this.openEnd > 0) { json.openEnd = this.openEnd; }
      return json
    };

    // :: (Schema, ?Object) → Slice
    // Deserialize a slice from its JSON representation.
    Slice.fromJSON = function fromJSON (schema, json) {
      if (!json) { return Slice.empty }
      var openStart = json.openStart || 0, openEnd = json.openEnd || 0;
      if (typeof openStart != "number" || typeof openEnd != "number")
        { throw new RangeError("Invalid input for Slice.fromJSON") }
      return new Slice(Fragment.fromJSON(schema, json.content), openStart, openEnd)
    };

    // :: (Fragment, ?bool) → Slice
    // Create a slice from a fragment by taking the maximum possible
    // open value on both side of the fragment.
    Slice.maxOpen = function maxOpen (fragment, openIsolating) {
        if ( openIsolating === void 0 ) openIsolating=true;

      var openStart = 0, openEnd = 0;
      for (var n = fragment.firstChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.firstChild) { openStart++; }
      for (var n$1 = fragment.lastChild; n$1 && !n$1.isLeaf && (openIsolating || !n$1.type.spec.isolating); n$1 = n$1.lastChild) { openEnd++; }
      return new Slice(fragment, openStart, openEnd)
    };

    Object.defineProperties( Slice.prototype, prototypeAccessors$1 );

    function removeRange(content, from, to) {
      var ref = content.findIndex(from);
      var index = ref.index;
      var offset = ref.offset;
      var child = content.maybeChild(index);
      var ref$1 = content.findIndex(to);
      var indexTo = ref$1.index;
      var offsetTo = ref$1.offset;
      if (offset == from || child.isText) {
        if (offsetTo != to && !content.child(indexTo).isText) { throw new RangeError("Removing non-flat range") }
        return content.cut(0, from).append(content.cut(to))
      }
      if (index != indexTo) { throw new RangeError("Removing non-flat range") }
      return content.replaceChild(index, child.copy(removeRange(child.content, from - offset - 1, to - offset - 1)))
    }

    function insertInto(content, dist, insert, parent) {
      var ref = content.findIndex(dist);
      var index = ref.index;
      var offset = ref.offset;
      var child = content.maybeChild(index);
      if (offset == dist || child.isText) {
        if (parent && !parent.canReplace(index, index, insert)) { return null }
        return content.cut(0, dist).append(insert).append(content.cut(dist))
      }
      var inner = insertInto(child.content, dist - offset - 1, insert);
      return inner && content.replaceChild(index, child.copy(inner))
    }

    // :: Slice
    // The empty slice.
    Slice.empty = new Slice(Fragment.empty, 0, 0);

    function replace($from, $to, slice) {
      if (slice.openStart > $from.depth)
        { throw new ReplaceError("Inserted content deeper than insertion position") }
      if ($from.depth - slice.openStart != $to.depth - slice.openEnd)
        { throw new ReplaceError("Inconsistent open depths") }
      return replaceOuter($from, $to, slice, 0)
    }

    function replaceOuter($from, $to, slice, depth) {
      var index = $from.index(depth), node = $from.node(depth);
      if (index == $to.index(depth) && depth < $from.depth - slice.openStart) {
        var inner = replaceOuter($from, $to, slice, depth + 1);
        return node.copy(node.content.replaceChild(index, inner))
      } else if (!slice.content.size) {
        return close(node, replaceTwoWay($from, $to, depth))
      } else if (!slice.openStart && !slice.openEnd && $from.depth == depth && $to.depth == depth) { // Simple, flat case
        var parent = $from.parent, content = parent.content;
        return close(parent, content.cut(0, $from.parentOffset).append(slice.content).append(content.cut($to.parentOffset)))
      } else {
        var ref = prepareSliceForReplace(slice, $from);
        var start = ref.start;
        var end = ref.end;
        return close(node, replaceThreeWay($from, start, end, $to, depth))
      }
    }

    function checkJoin(main, sub) {
      if (!sub.type.compatibleContent(main.type))
        { throw new ReplaceError("Cannot join " + sub.type.name + " onto " + main.type.name) }
    }

    function joinable($before, $after, depth) {
      var node = $before.node(depth);
      checkJoin(node, $after.node(depth));
      return node
    }

    function addNode(child, target) {
      var last = target.length - 1;
      if (last >= 0 && child.isText && child.sameMarkup(target[last]))
        { target[last] = child.withText(target[last].text + child.text); }
      else
        { target.push(child); }
    }

    function addRange($start, $end, depth, target) {
      var node = ($end || $start).node(depth);
      var startIndex = 0, endIndex = $end ? $end.index(depth) : node.childCount;
      if ($start) {
        startIndex = $start.index(depth);
        if ($start.depth > depth) {
          startIndex++;
        } else if ($start.textOffset) {
          addNode($start.nodeAfter, target);
          startIndex++;
        }
      }
      for (var i = startIndex; i < endIndex; i++) { addNode(node.child(i), target); }
      if ($end && $end.depth == depth && $end.textOffset)
        { addNode($end.nodeBefore, target); }
    }

    function close(node, content) {
      if (!node.type.validContent(content))
        { throw new ReplaceError("Invalid content for node " + node.type.name) }
      return node.copy(content)
    }

    function replaceThreeWay($from, $start, $end, $to, depth) {
      var openStart = $from.depth > depth && joinable($from, $start, depth + 1);
      var openEnd = $to.depth > depth && joinable($end, $to, depth + 1);

      var content = [];
      addRange(null, $from, depth, content);
      if (openStart && openEnd && $start.index(depth) == $end.index(depth)) {
        checkJoin(openStart, openEnd);
        addNode(close(openStart, replaceThreeWay($from, $start, $end, $to, depth + 1)), content);
      } else {
        if (openStart)
          { addNode(close(openStart, replaceTwoWay($from, $start, depth + 1)), content); }
        addRange($start, $end, depth, content);
        if (openEnd)
          { addNode(close(openEnd, replaceTwoWay($end, $to, depth + 1)), content); }
      }
      addRange($to, null, depth, content);
      return new Fragment(content)
    }

    function replaceTwoWay($from, $to, depth) {
      var content = [];
      addRange(null, $from, depth, content);
      if ($from.depth > depth) {
        var type = joinable($from, $to, depth + 1);
        addNode(close(type, replaceTwoWay($from, $to, depth + 1)), content);
      }
      addRange($to, null, depth, content);
      return new Fragment(content)
    }

    function prepareSliceForReplace(slice, $along) {
      var extra = $along.depth - slice.openStart, parent = $along.node(extra);
      var node = parent.copy(slice.content);
      for (var i = extra - 1; i >= 0; i--)
        { node = $along.node(i).copy(Fragment.from(node)); }
      return {start: node.resolveNoCache(slice.openStart + extra),
              end: node.resolveNoCache(node.content.size - slice.openEnd - extra)}
    }

    // ::- You can [_resolve_](#model.Node.resolve) a position to get more
    // information about it. Objects of this class represent such a
    // resolved position, providing various pieces of context information,
    // and some helper methods.
    //
    // Throughout this interface, methods that take an optional `depth`
    // parameter will interpret undefined as `this.depth` and negative
    // numbers as `this.depth + value`.
    var ResolvedPos = function ResolvedPos(pos, path, parentOffset) {
      // :: number The position that was resolved.
      this.pos = pos;
      this.path = path;
      // :: number
      // The number of levels the parent node is from the root. If this
      // position points directly into the root node, it is 0. If it
      // points into a top-level paragraph, 1, and so on.
      this.depth = path.length / 3 - 1;
      // :: number The offset this position has into its parent node.
      this.parentOffset = parentOffset;
    };

    var prototypeAccessors$2 = { parent: { configurable: true },doc: { configurable: true },textOffset: { configurable: true },nodeAfter: { configurable: true },nodeBefore: { configurable: true } };

    ResolvedPos.prototype.resolveDepth = function resolveDepth (val) {
      if (val == null) { return this.depth }
      if (val < 0) { return this.depth + val }
      return val
    };

    // :: Node
    // The parent node that the position points into. Note that even if
    // a position points into a text node, that node is not considered
    // the parent—text nodes are ‘flat’ in this model, and have no content.
    prototypeAccessors$2.parent.get = function () { return this.node(this.depth) };

    // :: Node
    // The root node in which the position was resolved.
    prototypeAccessors$2.doc.get = function () { return this.node(0) };

    // :: (?number) → Node
    // The ancestor node at the given level. `p.node(p.depth)` is the
    // same as `p.parent`.
    ResolvedPos.prototype.node = function node (depth) { return this.path[this.resolveDepth(depth) * 3] };

    // :: (?number) → number
    // The index into the ancestor at the given level. If this points at
    // the 3rd node in the 2nd paragraph on the top level, for example,
    // `p.index(0)` is 1 and `p.index(1)` is 2.
    ResolvedPos.prototype.index = function index (depth) { return this.path[this.resolveDepth(depth) * 3 + 1] };

    // :: (?number) → number
    // The index pointing after this position into the ancestor at the
    // given level.
    ResolvedPos.prototype.indexAfter = function indexAfter (depth) {
      depth = this.resolveDepth(depth);
      return this.index(depth) + (depth == this.depth && !this.textOffset ? 0 : 1)
    };

    // :: (?number) → number
    // The (absolute) position at the start of the node at the given
    // level.
    ResolvedPos.prototype.start = function start (depth) {
      depth = this.resolveDepth(depth);
      return depth == 0 ? 0 : this.path[depth * 3 - 1] + 1
    };

    // :: (?number) → number
    // The (absolute) position at the end of the node at the given
    // level.
    ResolvedPos.prototype.end = function end (depth) {
      depth = this.resolveDepth(depth);
      return this.start(depth) + this.node(depth).content.size
    };

    // :: (?number) → number
    // The (absolute) position directly before the wrapping node at the
    // given level, or, when `depth` is `this.depth + 1`, the original
    // position.
    ResolvedPos.prototype.before = function before (depth) {
      depth = this.resolveDepth(depth);
      if (!depth) { throw new RangeError("There is no position before the top-level node") }
      return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1]
    };

    // :: (?number) → number
    // The (absolute) position directly after the wrapping node at the
    // given level, or the original position when `depth` is `this.depth + 1`.
    ResolvedPos.prototype.after = function after (depth) {
      depth = this.resolveDepth(depth);
      if (!depth) { throw new RangeError("There is no position after the top-level node") }
      return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1] + this.path[depth * 3].nodeSize
    };

    // :: number
    // When this position points into a text node, this returns the
    // distance between the position and the start of the text node.
    // Will be zero for positions that point between nodes.
    prototypeAccessors$2.textOffset.get = function () { return this.pos - this.path[this.path.length - 1] };

    // :: ?Node
    // Get the node directly after the position, if any. If the position
    // points into a text node, only the part of that node after the
    // position is returned.
    prototypeAccessors$2.nodeAfter.get = function () {
      var parent = this.parent, index = this.index(this.depth);
      if (index == parent.childCount) { return null }
      var dOff = this.pos - this.path[this.path.length - 1], child = parent.child(index);
      return dOff ? parent.child(index).cut(dOff) : child
    };

    // :: ?Node
    // Get the node directly before the position, if any. If the
    // position points into a text node, only the part of that node
    // before the position is returned.
    prototypeAccessors$2.nodeBefore.get = function () {
      var index = this.index(this.depth);
      var dOff = this.pos - this.path[this.path.length - 1];
      if (dOff) { return this.parent.child(index).cut(0, dOff) }
      return index == 0 ? null : this.parent.child(index - 1)
    };

    // :: (number, ?number) → number
    // Get the position at the given index in the parent node at the
    // given depth (which defaults to `this.depth`).
    ResolvedPos.prototype.posAtIndex = function posAtIndex (index, depth) {
      depth = this.resolveDepth(depth);
      var node = this.path[depth * 3], pos = depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
      for (var i = 0; i < index; i++) { pos += node.child(i).nodeSize; }
      return pos
    };

    // :: () → [Mark]
    // Get the marks at this position, factoring in the surrounding
    // marks' [`inclusive`](#model.MarkSpec.inclusive) property. If the
    // position is at the start of a non-empty node, the marks of the
    // node after it (if any) are returned.
    ResolvedPos.prototype.marks = function marks () {
      var parent = this.parent, index = this.index();

      // In an empty parent, return the empty array
      if (parent.content.size == 0) { return Mark.none }

      // When inside a text node, just return the text node's marks
      if (this.textOffset) { return parent.child(index).marks }

      var main = parent.maybeChild(index - 1), other = parent.maybeChild(index);
      // If the `after` flag is true of there is no node before, make
      // the node after this position the main reference.
      if (!main) { var tmp = main; main = other; other = tmp; }

      // Use all marks in the main node, except those that have
      // `inclusive` set to false and are not present in the other node.
      var marks = main.marks;
      for (var i = 0; i < marks.length; i++)
        { if (marks[i].type.spec.inclusive === false && (!other || !marks[i].isInSet(other.marks)))
          { marks = marks[i--].removeFromSet(marks); } }

      return marks
    };

    // :: (ResolvedPos) → ?[Mark]
    // Get the marks after the current position, if any, except those
    // that are non-inclusive and not present at position `$end`. This
    // is mostly useful for getting the set of marks to preserve after a
    // deletion. Will return `null` if this position is at the end of
    // its parent node or its parent node isn't a textblock (in which
    // case no marks should be preserved).
    ResolvedPos.prototype.marksAcross = function marksAcross ($end) {
      var after = this.parent.maybeChild(this.index());
      if (!after || !after.isInline) { return null }

      var marks = after.marks, next = $end.parent.maybeChild($end.index());
      for (var i = 0; i < marks.length; i++)
        { if (marks[i].type.spec.inclusive === false && (!next || !marks[i].isInSet(next.marks)))
          { marks = marks[i--].removeFromSet(marks); } }
      return marks
    };

    // :: (number) → number
    // The depth up to which this position and the given (non-resolved)
    // position share the same parent nodes.
    ResolvedPos.prototype.sharedDepth = function sharedDepth (pos) {
      for (var depth = this.depth; depth > 0; depth--)
        { if (this.start(depth) <= pos && this.end(depth) >= pos) { return depth } }
      return 0
    };

    // :: (?ResolvedPos, ?(Node) → bool) → ?NodeRange
    // Returns a range based on the place where this position and the
    // given position diverge around block content. If both point into
    // the same textblock, for example, a range around that textblock
    // will be returned. If they point into different blocks, the range
    // around those blocks in their shared ancestor is returned. You can
    // pass in an optional predicate that will be called with a parent
    // node to see if a range into that parent is acceptable.
    ResolvedPos.prototype.blockRange = function blockRange (other, pred) {
        if ( other === void 0 ) other = this;

      if (other.pos < this.pos) { return other.blockRange(this) }
      for (var d = this.depth - (this.parent.inlineContent || this.pos == other.pos ? 1 : 0); d >= 0; d--)
        { if (other.pos <= this.end(d) && (!pred || pred(this.node(d))))
          { return new NodeRange(this, other, d) } }
    };

    // :: (ResolvedPos) → bool
    // Query whether the given position shares the same parent node.
    ResolvedPos.prototype.sameParent = function sameParent (other) {
      return this.pos - this.parentOffset == other.pos - other.parentOffset
    };

    // :: (ResolvedPos) → ResolvedPos
    // Return the greater of this and the given position.
    ResolvedPos.prototype.max = function max (other) {
      return other.pos > this.pos ? other : this
    };

    // :: (ResolvedPos) → ResolvedPos
    // Return the smaller of this and the given position.
    ResolvedPos.prototype.min = function min (other) {
      return other.pos < this.pos ? other : this
    };

    ResolvedPos.prototype.toString = function toString () {
      var str = "";
      for (var i = 1; i <= this.depth; i++)
        { str += (str ? "/" : "") + this.node(i).type.name + "_" + this.index(i - 1); }
      return str + ":" + this.parentOffset
    };

    ResolvedPos.resolve = function resolve (doc, pos) {
      if (!(pos >= 0 && pos <= doc.content.size)) { throw new RangeError("Position " + pos + " out of range") }
      var path = [];
      var start = 0, parentOffset = pos;
      for (var node = doc;;) {
        var ref = node.content.findIndex(parentOffset);
          var index = ref.index;
          var offset = ref.offset;
        var rem = parentOffset - offset;
        path.push(node, index, start + offset);
        if (!rem) { break }
        node = node.child(index);
        if (node.isText) { break }
        parentOffset = rem - 1;
        start += offset + 1;
      }
      return new ResolvedPos(pos, path, parentOffset)
    };

    ResolvedPos.resolveCached = function resolveCached (doc, pos) {
      for (var i = 0; i < resolveCache.length; i++) {
        var cached = resolveCache[i];
        if (cached.pos == pos && cached.doc == doc) { return cached }
      }
      var result = resolveCache[resolveCachePos] = ResolvedPos.resolve(doc, pos);
      resolveCachePos = (resolveCachePos + 1) % resolveCacheSize;
      return result
    };

    Object.defineProperties( ResolvedPos.prototype, prototypeAccessors$2 );

    var resolveCache = [], resolveCachePos = 0, resolveCacheSize = 12;

    // ::- Represents a flat range of content, i.e. one that starts and
    // ends in the same node.
    var NodeRange = function NodeRange($from, $to, depth) {
      // :: ResolvedPos A resolved position along the start of the
      // content. May have a `depth` greater than this object's `depth`
      // property, since these are the positions that were used to
      // compute the range, not re-resolved positions directly at its
      // boundaries.
      this.$from = $from;
      // :: ResolvedPos A position along the end of the content. See
      // caveat for [`$from`](#model.NodeRange.$from).
      this.$to = $to;
      // :: number The depth of the node that this range points into.
      this.depth = depth;
    };

    var prototypeAccessors$1$1 = { start: { configurable: true },end: { configurable: true },parent: { configurable: true },startIndex: { configurable: true },endIndex: { configurable: true } };

    // :: number The position at the start of the range.
    prototypeAccessors$1$1.start.get = function () { return this.$from.before(this.depth + 1) };
    // :: number The position at the end of the range.
    prototypeAccessors$1$1.end.get = function () { return this.$to.after(this.depth + 1) };

    // :: Node The parent node that the range points into.
    prototypeAccessors$1$1.parent.get = function () { return this.$from.node(this.depth) };
    // :: number The start index of the range in the parent node.
    prototypeAccessors$1$1.startIndex.get = function () { return this.$from.index(this.depth) };
    // :: number The end index of the range in the parent node.
    prototypeAccessors$1$1.endIndex.get = function () { return this.$to.indexAfter(this.depth) };

    Object.defineProperties( NodeRange.prototype, prototypeAccessors$1$1 );

    var emptyAttrs = Object.create(null);

    // ::- This class represents a node in the tree that makes up a
    // ProseMirror document. So a document is an instance of `Node`, with
    // children that are also instances of `Node`.
    //
    // Nodes are persistent data structures. Instead of changing them, you
    // create new ones with the content you want. Old ones keep pointing
    // at the old document shape. This is made cheaper by sharing
    // structure between the old and new data as much as possible, which a
    // tree shape like this (without back pointers) makes easy.
    //
    // **Do not** directly mutate the properties of a `Node` object. See
    // [the guide](/docs/guide/#doc) for more information.
    var Node$1 = function Node(type, attrs, content, marks) {
      // :: NodeType
      // The type of node that this is.
      this.type = type;

      // :: Object
      // An object mapping attribute names to values. The kind of
      // attributes allowed and required are
      // [determined](#model.NodeSpec.attrs) by the node type.
      this.attrs = attrs;

      // :: Fragment
      // A container holding the node's children.
      this.content = content || Fragment.empty;

      // :: [Mark]
      // The marks (things like whether it is emphasized or part of a
      // link) applied to this node.
      this.marks = marks || Mark.none;
    };

    var prototypeAccessors$3 = { nodeSize: { configurable: true },childCount: { configurable: true },textContent: { configurable: true },firstChild: { configurable: true },lastChild: { configurable: true },isBlock: { configurable: true },isTextblock: { configurable: true },inlineContent: { configurable: true },isInline: { configurable: true },isText: { configurable: true },isLeaf: { configurable: true },isAtom: { configurable: true } };

    // text:: ?string
    // For text nodes, this contains the node's text content.

    // :: number
    // The size of this node, as defined by the integer-based [indexing
    // scheme](/docs/guide/#doc.indexing). For text nodes, this is the
    // amount of characters. For other leaf nodes, it is one. For
    // non-leaf nodes, it is the size of the content plus two (the start
    // and end token).
    prototypeAccessors$3.nodeSize.get = function () { return this.isLeaf ? 1 : 2 + this.content.size };

    // :: number
    // The number of children that the node has.
    prototypeAccessors$3.childCount.get = function () { return this.content.childCount };

    // :: (number) → Node
    // Get the child node at the given index. Raises an error when the
    // index is out of range.
    Node$1.prototype.child = function child (index) { return this.content.child(index) };

    // :: (number) → ?Node
    // Get the child node at the given index, if it exists.
    Node$1.prototype.maybeChild = function maybeChild (index) { return this.content.maybeChild(index) };

    // :: ((node: Node, offset: number, index: number))
    // Call `f` for every child node, passing the node, its offset
    // into this parent node, and its index.
    Node$1.prototype.forEach = function forEach (f) { this.content.forEach(f); };

    // :: (number, number, (node: Node, pos: number, parent: Node, index: number) → ?bool, ?number)
    // Invoke a callback for all descendant nodes recursively between
    // the given two positions that are relative to start of this node's
    // content. The callback is invoked with the node, its
    // parent-relative position, its parent node, and its child index.
    // When the callback returns false for a given node, that node's
    // children will not be recursed over. The last parameter can be
    // used to specify a starting position to count from.
    Node$1.prototype.nodesBetween = function nodesBetween (from, to, f, startPos) {
        if ( startPos === void 0 ) startPos = 0;

      this.content.nodesBetween(from, to, f, startPos, this);
    };

    // :: ((node: Node, pos: number, parent: Node) → ?bool)
    // Call the given callback for every descendant node. Doesn't
    // descend into a node when the callback returns `false`.
    Node$1.prototype.descendants = function descendants (f) {
      this.nodesBetween(0, this.content.size, f);
    };

    // :: string
    // Concatenates all the text nodes found in this fragment and its
    // children.
    prototypeAccessors$3.textContent.get = function () { return this.textBetween(0, this.content.size, "") };

    // :: (number, number, ?string, ?string) → string
    // Get all text between positions `from` and `to`. When
    // `blockSeparator` is given, it will be inserted whenever a new
    // block node is started. When `leafText` is given, it'll be
    // inserted for every non-text leaf node encountered.
    Node$1.prototype.textBetween = function textBetween (from, to, blockSeparator, leafText) {
      return this.content.textBetween(from, to, blockSeparator, leafText)
    };

    // :: ?Node
    // Returns this node's first child, or `null` if there are no
    // children.
    prototypeAccessors$3.firstChild.get = function () { return this.content.firstChild };

    // :: ?Node
    // Returns this node's last child, or `null` if there are no
    // children.
    prototypeAccessors$3.lastChild.get = function () { return this.content.lastChild };

    // :: (Node) → bool
    // Test whether two nodes represent the same piece of document.
    Node$1.prototype.eq = function eq (other) {
      return this == other || (this.sameMarkup(other) && this.content.eq(other.content))
    };

    // :: (Node) → bool
    // Compare the markup (type, attributes, and marks) of this node to
    // those of another. Returns `true` if both have the same markup.
    Node$1.prototype.sameMarkup = function sameMarkup (other) {
      return this.hasMarkup(other.type, other.attrs, other.marks)
    };

    // :: (NodeType, ?Object, ?[Mark]) → bool
    // Check whether this node's markup correspond to the given type,
    // attributes, and marks.
    Node$1.prototype.hasMarkup = function hasMarkup (type, attrs, marks) {
      return this.type == type &&
        compareDeep(this.attrs, attrs || type.defaultAttrs || emptyAttrs) &&
        Mark.sameSet(this.marks, marks || Mark.none)
    };

    // :: (?Fragment) → Node
    // Create a new node with the same markup as this node, containing
    // the given content (or empty, if no content is given).
    Node$1.prototype.copy = function copy (content) {
        if ( content === void 0 ) content = null;

      if (content == this.content) { return this }
      return new this.constructor(this.type, this.attrs, content, this.marks)
    };

    // :: ([Mark]) → Node
    // Create a copy of this node, with the given set of marks instead
    // of the node's own marks.
    Node$1.prototype.mark = function mark (marks) {
      return marks == this.marks ? this : new this.constructor(this.type, this.attrs, this.content, marks)
    };

    // :: (number, ?number) → Node
    // Create a copy of this node with only the content between the
    // given positions. If `to` is not given, it defaults to the end of
    // the node.
    Node$1.prototype.cut = function cut (from, to) {
      if (from == 0 && to == this.content.size) { return this }
      return this.copy(this.content.cut(from, to))
    };

    // :: (number, ?number) → Slice
    // Cut out the part of the document between the given positions, and
    // return it as a `Slice` object.
    Node$1.prototype.slice = function slice (from, to, includeParents) {
        if ( to === void 0 ) to = this.content.size;
        if ( includeParents === void 0 ) includeParents = false;

      if (from == to) { return Slice.empty }

      var $from = this.resolve(from), $to = this.resolve(to);
      var depth = includeParents ? 0 : $from.sharedDepth(to);
      var start = $from.start(depth), node = $from.node(depth);
      var content = node.content.cut($from.pos - start, $to.pos - start);
      return new Slice(content, $from.depth - depth, $to.depth - depth)
    };

    // :: (number, number, Slice) → Node
    // Replace the part of the document between the given positions with
    // the given slice. The slice must 'fit', meaning its open sides
    // must be able to connect to the surrounding content, and its
    // content nodes must be valid children for the node they are placed
    // into. If any of this is violated, an error of type
    // [`ReplaceError`](#model.ReplaceError) is thrown.
    Node$1.prototype.replace = function replace$1 (from, to, slice) {
      return replace(this.resolve(from), this.resolve(to), slice)
    };

    // :: (number) → ?Node
    // Find the node directly after the given position.
    Node$1.prototype.nodeAt = function nodeAt (pos) {
      for (var node = this;;) {
        var ref = node.content.findIndex(pos);
          var index = ref.index;
          var offset = ref.offset;
        node = node.maybeChild(index);
        if (!node) { return null }
        if (offset == pos || node.isText) { return node }
        pos -= offset + 1;
      }
    };

    // :: (number) → {node: ?Node, index: number, offset: number}
    // Find the (direct) child node after the given offset, if any,
    // and return it along with its index and offset relative to this
    // node.
    Node$1.prototype.childAfter = function childAfter (pos) {
      var ref = this.content.findIndex(pos);
        var index = ref.index;
        var offset = ref.offset;
      return {node: this.content.maybeChild(index), index: index, offset: offset}
    };

    // :: (number) → {node: ?Node, index: number, offset: number}
    // Find the (direct) child node before the given offset, if any,
    // and return it along with its index and offset relative to this
    // node.
    Node$1.prototype.childBefore = function childBefore (pos) {
      if (pos == 0) { return {node: null, index: 0, offset: 0} }
      var ref = this.content.findIndex(pos);
        var index = ref.index;
        var offset = ref.offset;
      if (offset < pos) { return {node: this.content.child(index), index: index, offset: offset} }
      var node = this.content.child(index - 1);
      return {node: node, index: index - 1, offset: offset - node.nodeSize}
    };

    // :: (number) → ResolvedPos
    // Resolve the given position in the document, returning an
    // [object](#model.ResolvedPos) with information about its context.
    Node$1.prototype.resolve = function resolve (pos) { return ResolvedPos.resolveCached(this, pos) };

    Node$1.prototype.resolveNoCache = function resolveNoCache (pos) { return ResolvedPos.resolve(this, pos) };

    // :: (number, number, union<Mark, MarkType>) → bool
    // Test whether a given mark or mark type occurs in this document
    // between the two given positions.
    Node$1.prototype.rangeHasMark = function rangeHasMark (from, to, type) {
      var found = false;
      if (to > from) { this.nodesBetween(from, to, function (node) {
        if (type.isInSet(node.marks)) { found = true; }
        return !found
      }); }
      return found
    };

    // :: bool
    // True when this is a block (non-inline node)
    prototypeAccessors$3.isBlock.get = function () { return this.type.isBlock };

    // :: bool
    // True when this is a textblock node, a block node with inline
    // content.
    prototypeAccessors$3.isTextblock.get = function () { return this.type.isTextblock };

    // :: bool
    // True when this node allows inline content.
    prototypeAccessors$3.inlineContent.get = function () { return this.type.inlineContent };

    // :: bool
    // True when this is an inline node (a text node or a node that can
    // appear among text).
    prototypeAccessors$3.isInline.get = function () { return this.type.isInline };

    // :: bool
    // True when this is a text node.
    prototypeAccessors$3.isText.get = function () { return this.type.isText };

    // :: bool
    // True when this is a leaf node.
    prototypeAccessors$3.isLeaf.get = function () { return this.type.isLeaf };

    // :: bool
    // True when this is an atom, i.e. when it does not have directly
    // editable content. This is usually the same as `isLeaf`, but can
    // be configured with the [`atom` property](#model.NodeSpec.atom) on
    // a node's spec (typically used when the node is displayed as an
    // uneditable [node view](#view.NodeView)).
    prototypeAccessors$3.isAtom.get = function () { return this.type.isAtom };

    // :: () → string
    // Return a string representation of this node for debugging
    // purposes.
    Node$1.prototype.toString = function toString () {
      if (this.type.spec.toDebugString) { return this.type.spec.toDebugString(this) }
      var name = this.type.name;
      if (this.content.size)
        { name += "(" + this.content.toStringInner() + ")"; }
      return wrapMarks(this.marks, name)
    };

    // :: (number) → ContentMatch
    // Get the content match in this node at the given index.
    Node$1.prototype.contentMatchAt = function contentMatchAt (index) {
      var match = this.type.contentMatch.matchFragment(this.content, 0, index);
      if (!match) { throw new Error("Called contentMatchAt on a node with invalid content") }
      return match
    };

    // :: (number, number, ?Fragment, ?number, ?number) → bool
    // Test whether replacing the range between `from` and `to` (by
    // child index) with the given replacement fragment (which defaults
    // to the empty fragment) would leave the node's content valid. You
    // can optionally pass `start` and `end` indices into the
    // replacement fragment.
    Node$1.prototype.canReplace = function canReplace (from, to, replacement, start, end) {
        if ( replacement === void 0 ) replacement = Fragment.empty;
        if ( start === void 0 ) start = 0;
        if ( end === void 0 ) end = replacement.childCount;

      var one = this.contentMatchAt(from).matchFragment(replacement, start, end);
      var two = one && one.matchFragment(this.content, to);
      if (!two || !two.validEnd) { return false }
      for (var i = start; i < end; i++) { if (!this.type.allowsMarks(replacement.child(i).marks)) { return false } }
      return true
    };

    // :: (number, number, NodeType, ?[Mark]) → bool
    // Test whether replacing the range `from` to `to` (by index) with a
    // node of the given type would leave the node's content valid.
    Node$1.prototype.canReplaceWith = function canReplaceWith (from, to, type, marks) {
      if (marks && !this.type.allowsMarks(marks)) { return false }
      var start = this.contentMatchAt(from).matchType(type);
      var end = start && start.matchFragment(this.content, to);
      return end ? end.validEnd : false
    };

    // :: (Node) → bool
    // Test whether the given node's content could be appended to this
    // node. If that node is empty, this will only return true if there
    // is at least one node type that can appear in both nodes (to avoid
    // merging completely incompatible nodes).
    Node$1.prototype.canAppend = function canAppend (other) {
      if (other.content.size) { return this.canReplace(this.childCount, this.childCount, other.content) }
      else { return this.type.compatibleContent(other.type) }
    };

    // :: ()
    // Check whether this node and its descendants conform to the
    // schema, and raise error when they do not.
    Node$1.prototype.check = function check () {
      if (!this.type.validContent(this.content))
        { throw new RangeError(("Invalid content for node " + (this.type.name) + ": " + (this.content.toString().slice(0, 50)))) }
      this.content.forEach(function (node) { return node.check(); });
    };

    // :: () → Object
    // Return a JSON-serializeable representation of this node.
    Node$1.prototype.toJSON = function toJSON () {
      var obj = {type: this.type.name};
      for (var _ in this.attrs) {
        obj.attrs = this.attrs;
        break
      }
      if (this.content.size)
        { obj.content = this.content.toJSON(); }
      if (this.marks.length)
        { obj.marks = this.marks.map(function (n) { return n.toJSON(); }); }
      return obj
    };

    // :: (Schema, Object) → Node
    // Deserialize a node from its JSON representation.
    Node$1.fromJSON = function fromJSON (schema, json) {
      if (!json) { throw new RangeError("Invalid input for Node.fromJSON") }
      var marks = null;
      if (json.marks) {
        if (!Array.isArray(json.marks)) { throw new RangeError("Invalid mark data for Node.fromJSON") }
        marks = json.marks.map(schema.markFromJSON);
      }
      if (json.type == "text") {
        if (typeof json.text != "string") { throw new RangeError("Invalid text node in JSON") }
        return schema.text(json.text, marks)
      }
      var content = Fragment.fromJSON(schema, json.content);
      return schema.nodeType(json.type).create(json.attrs, content, marks)
    };

    Object.defineProperties( Node$1.prototype, prototypeAccessors$3 );

    var TextNode = /*@__PURE__*/(function (Node) {
      function TextNode(type, attrs, content, marks) {
        Node.call(this, type, attrs, null, marks);

        if (!content) { throw new RangeError("Empty text nodes are not allowed") }

        this.text = content;
      }

      if ( Node ) TextNode.__proto__ = Node;
      TextNode.prototype = Object.create( Node && Node.prototype );
      TextNode.prototype.constructor = TextNode;

      var prototypeAccessors$1 = { textContent: { configurable: true },nodeSize: { configurable: true } };

      TextNode.prototype.toString = function toString () {
        if (this.type.spec.toDebugString) { return this.type.spec.toDebugString(this) }
        return wrapMarks(this.marks, JSON.stringify(this.text))
      };

      prototypeAccessors$1.textContent.get = function () { return this.text };

      TextNode.prototype.textBetween = function textBetween (from, to) { return this.text.slice(from, to) };

      prototypeAccessors$1.nodeSize.get = function () { return this.text.length };

      TextNode.prototype.mark = function mark (marks) {
        return marks == this.marks ? this : new TextNode(this.type, this.attrs, this.text, marks)
      };

      TextNode.prototype.withText = function withText (text) {
        if (text == this.text) { return this }
        return new TextNode(this.type, this.attrs, text, this.marks)
      };

      TextNode.prototype.cut = function cut (from, to) {
        if ( from === void 0 ) from = 0;
        if ( to === void 0 ) to = this.text.length;

        if (from == 0 && to == this.text.length) { return this }
        return this.withText(this.text.slice(from, to))
      };

      TextNode.prototype.eq = function eq (other) {
        return this.sameMarkup(other) && this.text == other.text
      };

      TextNode.prototype.toJSON = function toJSON () {
        var base = Node.prototype.toJSON.call(this);
        base.text = this.text;
        return base
      };

      Object.defineProperties( TextNode.prototype, prototypeAccessors$1 );

      return TextNode;
    }(Node$1));

    function wrapMarks(marks, str) {
      for (var i = marks.length - 1; i >= 0; i--)
        { str = marks[i].type.name + "(" + str + ")"; }
      return str
    }

    // ::- Instances of this class represent a match state of a node
    // type's [content expression](#model.NodeSpec.content), and can be
    // used to find out whether further content matches here, and whether
    // a given position is a valid end of the node.
    var ContentMatch = function ContentMatch(validEnd) {
      // :: bool
      // True when this match state represents a valid end of the node.
      this.validEnd = validEnd;
      this.next = [];
      this.wrapCache = [];
    };

    var prototypeAccessors$4 = { inlineContent: { configurable: true },defaultType: { configurable: true },edgeCount: { configurable: true } };

    ContentMatch.parse = function parse (string, nodeTypes) {
      var stream = new TokenStream(string, nodeTypes);
      if (stream.next == null) { return ContentMatch.empty }
      var expr = parseExpr(stream);
      if (stream.next) { stream.err("Unexpected trailing text"); }
      var match = dfa(nfa(expr));
      checkForDeadEnds(match, stream);
      return match
    };

    // :: (NodeType) → ?ContentMatch
    // Match a node type, returning a match after that node if
    // successful.
    ContentMatch.prototype.matchType = function matchType (type) {
      for (var i = 0; i < this.next.length; i += 2)
        { if (this.next[i] == type) { return this.next[i + 1] } }
      return null
    };

    // :: (Fragment, ?number, ?number) → ?ContentMatch
    // Try to match a fragment. Returns the resulting match when
    // successful.
    ContentMatch.prototype.matchFragment = function matchFragment (frag, start, end) {
        if ( start === void 0 ) start = 0;
        if ( end === void 0 ) end = frag.childCount;

      var cur = this;
      for (var i = start; cur && i < end; i++)
        { cur = cur.matchType(frag.child(i).type); }
      return cur
    };

    prototypeAccessors$4.inlineContent.get = function () {
      var first = this.next[0];
      return first ? first.isInline : false
    };

    // :: ?NodeType
    // Get the first matching node type at this match position that can
    // be generated.
    prototypeAccessors$4.defaultType.get = function () {
      for (var i = 0; i < this.next.length; i += 2) {
        var type = this.next[i];
        if (!(type.isText || type.hasRequiredAttrs())) { return type }
      }
    };

    ContentMatch.prototype.compatible = function compatible (other) {
      for (var i = 0; i < this.next.length; i += 2)
        { for (var j = 0; j < other.next.length; j += 2)
          { if (this.next[i] == other.next[j]) { return true } } }
      return false
    };

    // :: (Fragment, bool, ?number) → ?Fragment
    // Try to match the given fragment, and if that fails, see if it can
    // be made to match by inserting nodes in front of it. When
    // successful, return a fragment of inserted nodes (which may be
    // empty if nothing had to be inserted). When `toEnd` is true, only
    // return a fragment if the resulting match goes to the end of the
    // content expression.
    ContentMatch.prototype.fillBefore = function fillBefore (after, toEnd, startIndex) {
        if ( toEnd === void 0 ) toEnd = false;
        if ( startIndex === void 0 ) startIndex = 0;

      var seen = [this];
      function search(match, types) {
        var finished = match.matchFragment(after, startIndex);
        if (finished && (!toEnd || finished.validEnd))
          { return Fragment.from(types.map(function (tp) { return tp.createAndFill(); })) }

        for (var i = 0; i < match.next.length; i += 2) {
          var type = match.next[i], next = match.next[i + 1];
          if (!(type.isText || type.hasRequiredAttrs()) && seen.indexOf(next) == -1) {
            seen.push(next);
            var found = search(next, types.concat(type));
            if (found) { return found }
          }
        }
      }

      return search(this, [])
    };

    // :: (NodeType) → ?[NodeType]
    // Find a set of wrapping node types that would allow a node of the
    // given type to appear at this position. The result may be empty
    // (when it fits directly) and will be null when no such wrapping
    // exists.
    ContentMatch.prototype.findWrapping = function findWrapping (target) {
      for (var i = 0; i < this.wrapCache.length; i += 2)
        { if (this.wrapCache[i] == target) { return this.wrapCache[i + 1] } }
      var computed = this.computeWrapping(target);
      this.wrapCache.push(target, computed);
      return computed
    };

    ContentMatch.prototype.computeWrapping = function computeWrapping (target) {
      var seen = Object.create(null), active = [{match: this, type: null, via: null}];
      while (active.length) {
        var current = active.shift(), match = current.match;
        if (match.matchType(target)) {
          var result = [];
          for (var obj = current; obj.type; obj = obj.via)
            { result.push(obj.type); }
          return result.reverse()
        }
        for (var i = 0; i < match.next.length; i += 2) {
          var type = match.next[i];
          if (!type.isLeaf && !type.hasRequiredAttrs() && !(type.name in seen) && (!current.type || match.next[i + 1].validEnd)) {
            active.push({match: type.contentMatch, type: type, via: current});
            seen[type.name] = true;
          }
        }
      }
    };

    // :: number
    // The number of outgoing edges this node has in the finite
    // automaton that describes the content expression.
    prototypeAccessors$4.edgeCount.get = function () {
      return this.next.length >> 1
    };

    // :: (number) → {type: NodeType, next: ContentMatch}
    // Get the _n_​th outgoing edge from this node in the finite
    // automaton that describes the content expression.
    ContentMatch.prototype.edge = function edge (n) {
      var i = n << 1;
      if (i >= this.next.length) { throw new RangeError(("There's no " + n + "th edge in this content match")) }
      return {type: this.next[i], next: this.next[i + 1]}
    };

    ContentMatch.prototype.toString = function toString () {
      var seen = [];
      function scan(m) {
        seen.push(m);
        for (var i = 1; i < m.next.length; i += 2)
          { if (seen.indexOf(m.next[i]) == -1) { scan(m.next[i]); } }
      }
      scan(this);
      return seen.map(function (m, i) {
        var out = i + (m.validEnd ? "*" : " ") + " ";
        for (var i$1 = 0; i$1 < m.next.length; i$1 += 2)
          { out += (i$1 ? ", " : "") + m.next[i$1].name + "->" + seen.indexOf(m.next[i$1 + 1]); }
        return out
      }).join("\n")
    };

    Object.defineProperties( ContentMatch.prototype, prototypeAccessors$4 );

    ContentMatch.empty = new ContentMatch(true);

    var TokenStream = function TokenStream(string, nodeTypes) {
      this.string = string;
      this.nodeTypes = nodeTypes;
      this.inline = null;
      this.pos = 0;
      this.tokens = string.split(/\s*(?=\b|\W|$)/);
      if (this.tokens[this.tokens.length - 1] == "") { this.tokens.pop(); }
      if (this.tokens[0] == "") { this.tokens.shift(); }
    };

    var prototypeAccessors$1$2 = { next: { configurable: true } };

    prototypeAccessors$1$2.next.get = function () { return this.tokens[this.pos] };

    TokenStream.prototype.eat = function eat (tok) { return this.next == tok && (this.pos++ || true) };

    TokenStream.prototype.err = function err (str) { throw new SyntaxError(str + " (in content expression '" + this.string + "')") };

    Object.defineProperties( TokenStream.prototype, prototypeAccessors$1$2 );

    function parseExpr(stream) {
      var exprs = [];
      do { exprs.push(parseExprSeq(stream)); }
      while (stream.eat("|"))
      return exprs.length == 1 ? exprs[0] : {type: "choice", exprs: exprs}
    }

    function parseExprSeq(stream) {
      var exprs = [];
      do { exprs.push(parseExprSubscript(stream)); }
      while (stream.next && stream.next != ")" && stream.next != "|")
      return exprs.length == 1 ? exprs[0] : {type: "seq", exprs: exprs}
    }

    function parseExprSubscript(stream) {
      var expr = parseExprAtom(stream);
      for (;;) {
        if (stream.eat("+"))
          { expr = {type: "plus", expr: expr}; }
        else if (stream.eat("*"))
          { expr = {type: "star", expr: expr}; }
        else if (stream.eat("?"))
          { expr = {type: "opt", expr: expr}; }
        else if (stream.eat("{"))
          { expr = parseExprRange(stream, expr); }
        else { break }
      }
      return expr
    }

    function parseNum(stream) {
      if (/\D/.test(stream.next)) { stream.err("Expected number, got '" + stream.next + "'"); }
      var result = Number(stream.next);
      stream.pos++;
      return result
    }

    function parseExprRange(stream, expr) {
      var min = parseNum(stream), max = min;
      if (stream.eat(",")) {
        if (stream.next != "}") { max = parseNum(stream); }
        else { max = -1; }
      }
      if (!stream.eat("}")) { stream.err("Unclosed braced range"); }
      return {type: "range", min: min, max: max, expr: expr}
    }

    function resolveName(stream, name) {
      var types = stream.nodeTypes, type = types[name];
      if (type) { return [type] }
      var result = [];
      for (var typeName in types) {
        var type$1 = types[typeName];
        if (type$1.groups.indexOf(name) > -1) { result.push(type$1); }
      }
      if (result.length == 0) { stream.err("No node type or group '" + name + "' found"); }
      return result
    }

    function parseExprAtom(stream) {
      if (stream.eat("(")) {
        var expr = parseExpr(stream);
        if (!stream.eat(")")) { stream.err("Missing closing paren"); }
        return expr
      } else if (!/\W/.test(stream.next)) {
        var exprs = resolveName(stream, stream.next).map(function (type) {
          if (stream.inline == null) { stream.inline = type.isInline; }
          else if (stream.inline != type.isInline) { stream.err("Mixing inline and block content"); }
          return {type: "name", value: type}
        });
        stream.pos++;
        return exprs.length == 1 ? exprs[0] : {type: "choice", exprs: exprs}
      } else {
        stream.err("Unexpected token '" + stream.next + "'");
      }
    }

    // The code below helps compile a regular-expression-like language
    // into a deterministic finite automaton. For a good introduction to
    // these concepts, see https://swtch.com/~rsc/regexp/regexp1.html

    // : (Object) → [[{term: ?any, to: number}]]
    // Construct an NFA from an expression as returned by the parser. The
    // NFA is represented as an array of states, which are themselves
    // arrays of edges, which are `{term, to}` objects. The first state is
    // the entry state and the last node is the success state.
    //
    // Note that unlike typical NFAs, the edge ordering in this one is
    // significant, in that it is used to contruct filler content when
    // necessary.
    function nfa(expr) {
      var nfa = [[]];
      connect(compile(expr, 0), node());
      return nfa

      function node() { return nfa.push([]) - 1 }
      function edge(from, to, term) {
        var edge = {term: term, to: to};
        nfa[from].push(edge);
        return edge
      }
      function connect(edges, to) { edges.forEach(function (edge) { return edge.to = to; }); }

      function compile(expr, from) {
        if (expr.type == "choice") {
          return expr.exprs.reduce(function (out, expr) { return out.concat(compile(expr, from)); }, [])
        } else if (expr.type == "seq") {
          for (var i = 0;; i++) {
            var next = compile(expr.exprs[i], from);
            if (i == expr.exprs.length - 1) { return next }
            connect(next, from = node());
          }
        } else if (expr.type == "star") {
          var loop = node();
          edge(from, loop);
          connect(compile(expr.expr, loop), loop);
          return [edge(loop)]
        } else if (expr.type == "plus") {
          var loop$1 = node();
          connect(compile(expr.expr, from), loop$1);
          connect(compile(expr.expr, loop$1), loop$1);
          return [edge(loop$1)]
        } else if (expr.type == "opt") {
          return [edge(from)].concat(compile(expr.expr, from))
        } else if (expr.type == "range") {
          var cur = from;
          for (var i$1 = 0; i$1 < expr.min; i$1++) {
            var next$1 = node();
            connect(compile(expr.expr, cur), next$1);
            cur = next$1;
          }
          if (expr.max == -1) {
            connect(compile(expr.expr, cur), cur);
          } else {
            for (var i$2 = expr.min; i$2 < expr.max; i$2++) {
              var next$2 = node();
              edge(cur, next$2);
              connect(compile(expr.expr, cur), next$2);
              cur = next$2;
            }
          }
          return [edge(cur)]
        } else if (expr.type == "name") {
          return [edge(from, null, expr.value)]
        }
      }
    }

    function cmp(a, b) { return b - a }

    // Get the set of nodes reachable by null edges from `node`. Omit
    // nodes with only a single null-out-edge, since they may lead to
    // needless duplicated nodes.
    function nullFrom(nfa, node) {
      var result = [];
      scan(node);
      return result.sort(cmp)

      function scan(node) {
        var edges = nfa[node];
        if (edges.length == 1 && !edges[0].term) { return scan(edges[0].to) }
        result.push(node);
        for (var i = 0; i < edges.length; i++) {
          var ref = edges[i];
          var term = ref.term;
          var to = ref.to;
          if (!term && result.indexOf(to) == -1) { scan(to); }
        }
      }
    }

    // : ([[{term: ?any, to: number}]]) → ContentMatch
    // Compiles an NFA as produced by `nfa` into a DFA, modeled as a set
    // of state objects (`ContentMatch` instances) with transitions
    // between them.
    function dfa(nfa) {
      var labeled = Object.create(null);
      return explore(nullFrom(nfa, 0))

      function explore(states) {
        var out = [];
        states.forEach(function (node) {
          nfa[node].forEach(function (ref) {
            var term = ref.term;
            var to = ref.to;

            if (!term) { return }
            var known = out.indexOf(term), set = known > -1 && out[known + 1];
            nullFrom(nfa, to).forEach(function (node) {
              if (!set) { out.push(term, set = []); }
              if (set.indexOf(node) == -1) { set.push(node); }
            });
          });
        });
        var state = labeled[states.join(",")] = new ContentMatch(states.indexOf(nfa.length - 1) > -1);
        for (var i = 0; i < out.length; i += 2) {
          var states$1 = out[i + 1].sort(cmp);
          state.next.push(out[i], labeled[states$1.join(",")] || explore(states$1));
        }
        return state
      }
    }

    function checkForDeadEnds(match, stream) {
      for (var i = 0, work = [match]; i < work.length; i++) {
        var state = work[i], dead = !state.validEnd, nodes = [];
        for (var j = 0; j < state.next.length; j += 2) {
          var node = state.next[j], next = state.next[j + 1];
          nodes.push(node.name);
          if (dead && !(node.isText || node.hasRequiredAttrs())) { dead = false; }
          if (work.indexOf(next) == -1) { work.push(next); }
        }
        if (dead) { stream.err("Only non-generatable nodes (" + nodes.join(", ") + ") in a required position (see https://prosemirror.net/docs/guide/#generatable)"); }
      }
    }

    // For node types where all attrs have a default value (or which don't
    // have any attributes), build up a single reusable default attribute
    // object, and use it for all nodes that don't specify specific
    // attributes.
    function defaultAttrs(attrs) {
      var defaults = Object.create(null);
      for (var attrName in attrs) {
        var attr = attrs[attrName];
        if (!attr.hasDefault) { return null }
        defaults[attrName] = attr.default;
      }
      return defaults
    }

    function computeAttrs(attrs, value) {
      var built = Object.create(null);
      for (var name in attrs) {
        var given = value && value[name];
        if (given === undefined) {
          var attr = attrs[name];
          if (attr.hasDefault) { given = attr.default; }
          else { throw new RangeError("No value supplied for attribute " + name) }
        }
        built[name] = given;
      }
      return built
    }

    function initAttrs(attrs) {
      var result = Object.create(null);
      if (attrs) { for (var name in attrs) { result[name] = new Attribute(attrs[name]); } }
      return result
    }

    // ::- Node types are objects allocated once per `Schema` and used to
    // [tag](#model.Node.type) `Node` instances. They contain information
    // about the node type, such as its name and what kind of node it
    // represents.
    var NodeType = function NodeType(name, schema, spec) {
      // :: string
      // The name the node type has in this schema.
      this.name = name;

      // :: Schema
      // A link back to the `Schema` the node type belongs to.
      this.schema = schema;

      // :: NodeSpec
      // The spec that this type is based on
      this.spec = spec;

      this.groups = spec.group ? spec.group.split(" ") : [];
      this.attrs = initAttrs(spec.attrs);

      this.defaultAttrs = defaultAttrs(this.attrs);

      // :: ContentMatch
      // The starting match of the node type's content expression.
      this.contentMatch = null;

      // : ?[MarkType]
      // The set of marks allowed in this node. `null` means all marks
      // are allowed.
      this.markSet = null;

      // :: bool
      // True if this node type has inline content.
      this.inlineContent = null;

      // :: bool
      // True if this is a block type
      this.isBlock = !(spec.inline || name == "text");

      // :: bool
      // True if this is the text node type.
      this.isText = name == "text";
    };

    var prototypeAccessors$5 = { isInline: { configurable: true },isTextblock: { configurable: true },isLeaf: { configurable: true },isAtom: { configurable: true } };

    // :: bool
    // True if this is an inline type.
    prototypeAccessors$5.isInline.get = function () { return !this.isBlock };

    // :: bool
    // True if this is a textblock type, a block that contains inline
    // content.
    prototypeAccessors$5.isTextblock.get = function () { return this.isBlock && this.inlineContent };

    // :: bool
    // True for node types that allow no content.
    prototypeAccessors$5.isLeaf.get = function () { return this.contentMatch == ContentMatch.empty };

    // :: bool
    // True when this node is an atom, i.e. when it does not have
    // directly editable content.
    prototypeAccessors$5.isAtom.get = function () { return this.isLeaf || this.spec.atom };

    // :: () → bool
    // Tells you whether this node type has any required attributes.
    NodeType.prototype.hasRequiredAttrs = function hasRequiredAttrs () {
      for (var n in this.attrs) { if (this.attrs[n].isRequired) { return true } }
      return false
    };

    NodeType.prototype.compatibleContent = function compatibleContent (other) {
      return this == other || this.contentMatch.compatible(other.contentMatch)
    };

    NodeType.prototype.computeAttrs = function computeAttrs$1 (attrs) {
      if (!attrs && this.defaultAttrs) { return this.defaultAttrs }
      else { return computeAttrs(this.attrs, attrs) }
    };

    // :: (?Object, ?union<Fragment, Node, [Node]>, ?[Mark]) → Node
    // Create a `Node` of this type. The given attributes are
    // checked and defaulted (you can pass `null` to use the type's
    // defaults entirely, if no required attributes exist). `content`
    // may be a `Fragment`, a node, an array of nodes, or
    // `null`. Similarly `marks` may be `null` to default to the empty
    // set of marks.
    NodeType.prototype.create = function create (attrs, content, marks) {
      if (this.isText) { throw new Error("NodeType.create can't construct text nodes") }
      return new Node$1(this, this.computeAttrs(attrs), Fragment.from(content), Mark.setFrom(marks))
    };

    // :: (?Object, ?union<Fragment, Node, [Node]>, ?[Mark]) → Node
    // Like [`create`](#model.NodeType.create), but check the given content
    // against the node type's content restrictions, and throw an error
    // if it doesn't match.
    NodeType.prototype.createChecked = function createChecked (attrs, content, marks) {
      content = Fragment.from(content);
      if (!this.validContent(content))
        { throw new RangeError("Invalid content for node " + this.name) }
      return new Node$1(this, this.computeAttrs(attrs), content, Mark.setFrom(marks))
    };

    // :: (?Object, ?union<Fragment, Node, [Node]>, ?[Mark]) → ?Node
    // Like [`create`](#model.NodeType.create), but see if it is necessary to
    // add nodes to the start or end of the given fragment to make it
    // fit the node. If no fitting wrapping can be found, return null.
    // Note that, due to the fact that required nodes can always be
    // created, this will always succeed if you pass null or
    // `Fragment.empty` as content.
    NodeType.prototype.createAndFill = function createAndFill (attrs, content, marks) {
      attrs = this.computeAttrs(attrs);
      content = Fragment.from(content);
      if (content.size) {
        var before = this.contentMatch.fillBefore(content);
        if (!before) { return null }
        content = before.append(content);
      }
      var after = this.contentMatch.matchFragment(content).fillBefore(Fragment.empty, true);
      if (!after) { return null }
      return new Node$1(this, attrs, content.append(after), Mark.setFrom(marks))
    };

    // :: (Fragment) → bool
    // Returns true if the given fragment is valid content for this node
    // type with the given attributes.
    NodeType.prototype.validContent = function validContent (content) {
      var result = this.contentMatch.matchFragment(content);
      if (!result || !result.validEnd) { return false }
      for (var i = 0; i < content.childCount; i++)
        { if (!this.allowsMarks(content.child(i).marks)) { return false } }
      return true
    };

    // :: (MarkType) → bool
    // Check whether the given mark type is allowed in this node.
    NodeType.prototype.allowsMarkType = function allowsMarkType (markType) {
      return this.markSet == null || this.markSet.indexOf(markType) > -1
    };

    // :: ([Mark]) → bool
    // Test whether the given set of marks are allowed in this node.
    NodeType.prototype.allowsMarks = function allowsMarks (marks) {
      if (this.markSet == null) { return true }
      for (var i = 0; i < marks.length; i++) { if (!this.allowsMarkType(marks[i].type)) { return false } }
      return true
    };

    // :: ([Mark]) → [Mark]
    // Removes the marks that are not allowed in this node from the given set.
    NodeType.prototype.allowedMarks = function allowedMarks (marks) {
      if (this.markSet == null) { return marks }
      var copy;
      for (var i = 0; i < marks.length; i++) {
        if (!this.allowsMarkType(marks[i].type)) {
          if (!copy) { copy = marks.slice(0, i); }
        } else if (copy) {
          copy.push(marks[i]);
        }
      }
      return !copy ? marks : copy.length ? copy : Mark.empty
    };

    NodeType.compile = function compile (nodes, schema) {
      var result = Object.create(null);
      nodes.forEach(function (name, spec) { return result[name] = new NodeType(name, schema, spec); });

      var topType = schema.spec.topNode || "doc";
      if (!result[topType]) { throw new RangeError("Schema is missing its top node type ('" + topType + "')") }
      if (!result.text) { throw new RangeError("Every schema needs a 'text' type") }
      for (var _ in result.text.attrs) { throw new RangeError("The text node type should not have attributes") }

      return result
    };

    Object.defineProperties( NodeType.prototype, prototypeAccessors$5 );

    // Attribute descriptors

    var Attribute = function Attribute(options) {
      this.hasDefault = Object.prototype.hasOwnProperty.call(options, "default");
      this.default = options.default;
    };

    var prototypeAccessors$1$3 = { isRequired: { configurable: true } };

    prototypeAccessors$1$3.isRequired.get = function () {
      return !this.hasDefault
    };

    Object.defineProperties( Attribute.prototype, prototypeAccessors$1$3 );

    // Marks

    // ::- Like nodes, marks (which are associated with nodes to signify
    // things like emphasis or being part of a link) are
    // [tagged](#model.Mark.type) with type objects, which are
    // instantiated once per `Schema`.
    var MarkType = function MarkType(name, rank, schema, spec) {
      // :: string
      // The name of the mark type.
      this.name = name;

      // :: Schema
      // The schema that this mark type instance is part of.
      this.schema = schema;

      // :: MarkSpec
      // The spec on which the type is based.
      this.spec = spec;

      this.attrs = initAttrs(spec.attrs);

      this.rank = rank;
      this.excluded = null;
      var defaults = defaultAttrs(this.attrs);
      this.instance = defaults && new Mark(this, defaults);
    };

    // :: (?Object) → Mark
    // Create a mark of this type. `attrs` may be `null` or an object
    // containing only some of the mark's attributes. The others, if
    // they have defaults, will be added.
    MarkType.prototype.create = function create (attrs) {
      if (!attrs && this.instance) { return this.instance }
      return new Mark(this, computeAttrs(this.attrs, attrs))
    };

    MarkType.compile = function compile (marks, schema) {
      var result = Object.create(null), rank = 0;
      marks.forEach(function (name, spec) { return result[name] = new MarkType(name, rank++, schema, spec); });
      return result
    };

    // :: ([Mark]) → [Mark]
    // When there is a mark of this type in the given set, a new set
    // without it is returned. Otherwise, the input set is returned.
    MarkType.prototype.removeFromSet = function removeFromSet (set) {
      for (var i = 0; i < set.length; i++) { if (set[i].type == this) {
        set = set.slice(0, i).concat(set.slice(i + 1));
        i--;
      } }
      return set
    };

    // :: ([Mark]) → ?Mark
    // Tests whether there is a mark of this type in the given set.
    MarkType.prototype.isInSet = function isInSet (set) {
      for (var i = 0; i < set.length; i++)
        { if (set[i].type == this) { return set[i] } }
    };

    // :: (MarkType) → bool
    // Queries whether a given mark type is
    // [excluded](#model.MarkSpec.excludes) by this one.
    MarkType.prototype.excludes = function excludes (other) {
      return this.excluded.indexOf(other) > -1
    };

    // SchemaSpec:: interface
    // An object describing a schema, as passed to the [`Schema`](#model.Schema)
    // constructor.
    //
    //   nodes:: union<Object<NodeSpec>, OrderedMap<NodeSpec>>
    //   The node types in this schema. Maps names to
    //   [`NodeSpec`](#model.NodeSpec) objects that describe the node type
    //   associated with that name. Their order is significant—it
    //   determines which [parse rules](#model.NodeSpec.parseDOM) take
    //   precedence by default, and which nodes come first in a given
    //   [group](#model.NodeSpec.group).
    //
    //   marks:: ?union<Object<MarkSpec>, OrderedMap<MarkSpec>>
    //   The mark types that exist in this schema. The order in which they
    //   are provided determines the order in which [mark
    //   sets](#model.Mark.addToSet) are sorted and in which [parse
    //   rules](#model.MarkSpec.parseDOM) are tried.
    //
    //   topNode:: ?string
    //   The name of the default top-level node for the schema. Defaults
    //   to `"doc"`.

    // NodeSpec:: interface
    //
    //   content:: ?string
    //   The content expression for this node, as described in the [schema
    //   guide](/docs/guide/#schema.content_expressions). When not given,
    //   the node does not allow any content.
    //
    //   marks:: ?string
    //   The marks that are allowed inside of this node. May be a
    //   space-separated string referring to mark names or groups, `"_"`
    //   to explicitly allow all marks, or `""` to disallow marks. When
    //   not given, nodes with inline content default to allowing all
    //   marks, other nodes default to not allowing marks.
    //
    //   group:: ?string
    //   The group or space-separated groups to which this node belongs,
    //   which can be referred to in the content expressions for the
    //   schema.
    //
    //   inline:: ?bool
    //   Should be set to true for inline nodes. (Implied for text nodes.)
    //
    //   atom:: ?bool
    //   Can be set to true to indicate that, though this isn't a [leaf
    //   node](#model.NodeType.isLeaf), it doesn't have directly editable
    //   content and should be treated as a single unit in the view.
    //
    //   attrs:: ?Object<AttributeSpec>
    //   The attributes that nodes of this type get.
    //
    //   selectable:: ?bool
    //   Controls whether nodes of this type can be selected as a [node
    //   selection](#state.NodeSelection). Defaults to true for non-text
    //   nodes.
    //
    //   draggable:: ?bool
    //   Determines whether nodes of this type can be dragged without
    //   being selected. Defaults to false.
    //
    //   code:: ?bool
    //   Can be used to indicate that this node contains code, which
    //   causes some commands to behave differently.
    //
    //   defining:: ?bool
    //   Determines whether this node is considered an important parent
    //   node during replace operations (such as paste). Non-defining (the
    //   default) nodes get dropped when their entire content is replaced,
    //   whereas defining nodes persist and wrap the inserted content.
    //   Likewise, in _inserted_ content the defining parents of the
    //   content are preserved when possible. Typically,
    //   non-default-paragraph textblock types, and possibly list items,
    //   are marked as defining.
    //
    //   isolating:: ?bool
    //   When enabled (default is false), the sides of nodes of this type
    //   count as boundaries that regular editing operations, like
    //   backspacing or lifting, won't cross. An example of a node that
    //   should probably have this enabled is a table cell.
    //
    //   toDOM:: ?(node: Node) → DOMOutputSpec
    //   Defines the default way a node of this type should be serialized
    //   to DOM/HTML (as used by
    //   [`DOMSerializer.fromSchema`](#model.DOMSerializer^fromSchema)).
    //   Should return a DOM node or an [array
    //   structure](#model.DOMOutputSpec) that describes one, with an
    //   optional number zero (“hole”) in it to indicate where the node's
    //   content should be inserted.
    //
    //   For text nodes, the default is to create a text DOM node. Though
    //   it is possible to create a serializer where text is rendered
    //   differently, this is not supported inside the editor, so you
    //   shouldn't override that in your text node spec.
    //
    //   parseDOM:: ?[ParseRule]
    //   Associates DOM parser information with this node, which can be
    //   used by [`DOMParser.fromSchema`](#model.DOMParser^fromSchema) to
    //   automatically derive a parser. The `node` field in the rules is
    //   implied (the name of this node will be filled in automatically).
    //   If you supply your own parser, you do not need to also specify
    //   parsing rules in your schema.
    //
    //   toDebugString:: ?(node: Node) -> string
    //   Defines the default way a node of this type should be serialized
    //   to a string representation for debugging (e.g. in error messages).

    // MarkSpec:: interface
    //
    //   attrs:: ?Object<AttributeSpec>
    //   The attributes that marks of this type get.
    //
    //   inclusive:: ?bool
    //   Whether this mark should be active when the cursor is positioned
    //   at its end (or at its start when that is also the start of the
    //   parent node). Defaults to true.
    //
    //   excludes:: ?string
    //   Determines which other marks this mark can coexist with. Should
    //   be a space-separated strings naming other marks or groups of marks.
    //   When a mark is [added](#model.Mark.addToSet) to a set, all marks
    //   that it excludes are removed in the process. If the set contains
    //   any mark that excludes the new mark but is not, itself, excluded
    //   by the new mark, the mark can not be added an the set. You can
    //   use the value `"_"` to indicate that the mark excludes all
    //   marks in the schema.
    //
    //   Defaults to only being exclusive with marks of the same type. You
    //   can set it to an empty string (or any string not containing the
    //   mark's own name) to allow multiple marks of a given type to
    //   coexist (as long as they have different attributes).
    //
    //   group:: ?string
    //   The group or space-separated groups to which this mark belongs.
    //
    //   spanning:: ?bool
    //   Determines whether marks of this type can span multiple adjacent
    //   nodes when serialized to DOM/HTML. Defaults to true.
    //
    //   toDOM:: ?(mark: Mark, inline: bool) → DOMOutputSpec
    //   Defines the default way marks of this type should be serialized
    //   to DOM/HTML. When the resulting spec contains a hole, that is
    //   where the marked content is placed. Otherwise, it is appended to
    //   the top node.
    //
    //   parseDOM:: ?[ParseRule]
    //   Associates DOM parser information with this mark (see the
    //   corresponding [node spec field](#model.NodeSpec.parseDOM)). The
    //   `mark` field in the rules is implied.

    // AttributeSpec:: interface
    //
    // Used to [define](#model.NodeSpec.attrs) attributes on nodes or
    // marks.
    //
    //   default:: ?any
    //   The default value for this attribute, to use when no explicit
    //   value is provided. Attributes that have no default must be
    //   provided whenever a node or mark of a type that has them is
    //   created.

    // ::- A document schema. Holds [node](#model.NodeType) and [mark
    // type](#model.MarkType) objects for the nodes and marks that may
    // occur in conforming documents, and provides functionality for
    // creating and deserializing such documents.
    var Schema = function Schema(spec) {
      // :: SchemaSpec
      // The [spec](#model.SchemaSpec) on which the schema is based,
      // with the added guarantee that its `nodes` and `marks`
      // properties are
      // [`OrderedMap`](https://github.com/marijnh/orderedmap) instances
      // (not raw objects).
      this.spec = {};
      for (var prop in spec) { this.spec[prop] = spec[prop]; }
      this.spec.nodes = orderedmap.from(spec.nodes);
      this.spec.marks = orderedmap.from(spec.marks);

      // :: Object<NodeType>
      // An object mapping the schema's node names to node type objects.
      this.nodes = NodeType.compile(this.spec.nodes, this);

      // :: Object<MarkType>
      // A map from mark names to mark type objects.
      this.marks = MarkType.compile(this.spec.marks, this);

      var contentExprCache = Object.create(null);
      for (var prop$1 in this.nodes) {
        if (prop$1 in this.marks)
          { throw new RangeError(prop$1 + " can not be both a node and a mark") }
        var type = this.nodes[prop$1], contentExpr = type.spec.content || "", markExpr = type.spec.marks;
        type.contentMatch = contentExprCache[contentExpr] ||
          (contentExprCache[contentExpr] = ContentMatch.parse(contentExpr, this.nodes));
        type.inlineContent = type.contentMatch.inlineContent;
        type.markSet = markExpr == "_" ? null :
          markExpr ? gatherMarks(this, markExpr.split(" ")) :
          markExpr == "" || !type.inlineContent ? [] : null;
      }
      for (var prop$2 in this.marks) {
        var type$1 = this.marks[prop$2], excl = type$1.spec.excludes;
        type$1.excluded = excl == null ? [type$1] : excl == "" ? [] : gatherMarks(this, excl.split(" "));
      }

      this.nodeFromJSON = this.nodeFromJSON.bind(this);
      this.markFromJSON = this.markFromJSON.bind(this);

      // :: NodeType
      // The type of the [default top node](#model.SchemaSpec.topNode)
      // for this schema.
      this.topNodeType = this.nodes[this.spec.topNode || "doc"];

      // :: Object
      // An object for storing whatever values modules may want to
      // compute and cache per schema. (If you want to store something
      // in it, try to use property names unlikely to clash.)
      this.cached = Object.create(null);
      this.cached.wrappings = Object.create(null);
    };

    // :: (union<string, NodeType>, ?Object, ?union<Fragment, Node, [Node]>, ?[Mark]) → Node
    // Create a node in this schema. The `type` may be a string or a
    // `NodeType` instance. Attributes will be extended
    // with defaults, `content` may be a `Fragment`,
    // `null`, a `Node`, or an array of nodes.
    Schema.prototype.node = function node (type, attrs, content, marks) {
      if (typeof type == "string")
        { type = this.nodeType(type); }
      else if (!(type instanceof NodeType))
        { throw new RangeError("Invalid node type: " + type) }
      else if (type.schema != this)
        { throw new RangeError("Node type from different schema used (" + type.name + ")") }

      return type.createChecked(attrs, content, marks)
    };

    // :: (string, ?[Mark]) → Node
    // Create a text node in the schema. Empty text nodes are not
    // allowed.
    Schema.prototype.text = function text (text$1, marks) {
      var type = this.nodes.text;
      return new TextNode(type, type.defaultAttrs, text$1, Mark.setFrom(marks))
    };

    // :: (union<string, MarkType>, ?Object) → Mark
    // Create a mark with the given type and attributes.
    Schema.prototype.mark = function mark (type, attrs) {
      if (typeof type == "string") { type = this.marks[type]; }
      return type.create(attrs)
    };

    // :: (Object) → Node
    // Deserialize a node from its JSON representation. This method is
    // bound.
    Schema.prototype.nodeFromJSON = function nodeFromJSON (json) {
      return Node$1.fromJSON(this, json)
    };

    // :: (Object) → Mark
    // Deserialize a mark from its JSON representation. This method is
    // bound.
    Schema.prototype.markFromJSON = function markFromJSON (json) {
      return Mark.fromJSON(this, json)
    };

    Schema.prototype.nodeType = function nodeType (name) {
      var found = this.nodes[name];
      if (!found) { throw new RangeError("Unknown node type: " + name) }
      return found
    };

    function gatherMarks(schema, marks) {
      var found = [];
      for (var i = 0; i < marks.length; i++) {
        var name = marks[i], mark = schema.marks[name], ok = mark;
        if (mark) {
          found.push(mark);
        } else {
          for (var prop in schema.marks) {
            var mark$1 = schema.marks[prop];
            if (name == "_" || (mark$1.spec.group && mark$1.spec.group.split(" ").indexOf(name) > -1))
              { found.push(ok = mark$1); }
          }
        }
        if (!ok) { throw new SyntaxError("Unknown mark type: '" + marks[i] + "'") }
      }
      return found
    }

    // ParseOptions:: interface
    // These are the options recognized by the
    // [`parse`](#model.DOMParser.parse) and
    // [`parseSlice`](#model.DOMParser.parseSlice) methods.
    //
    //   preserveWhitespace:: ?union<bool, "full">
    //   By default, whitespace is collapsed as per HTML's rules. Pass
    //   `true` to preserve whitespace, but normalize newlines to
    //   spaces, and `"full"` to preserve whitespace entirely.
    //
    //   findPositions:: ?[{node: dom.Node, offset: number}]
    //   When given, the parser will, beside parsing the content,
    //   record the document positions of the given DOM positions. It
    //   will do so by writing to the objects, adding a `pos` property
    //   that holds the document position. DOM positions that are not
    //   in the parsed content will not be written to.
    //
    //   from:: ?number
    //   The child node index to start parsing from.
    //
    //   to:: ?number
    //   The child node index to stop parsing at.
    //
    //   topNode:: ?Node
    //   By default, the content is parsed into the schema's default
    //   [top node type](#model.Schema.topNodeType). You can pass this
    //   option to use the type and attributes from a different node
    //   as the top container.
    //
    //   topMatch:: ?ContentMatch
    //   Provide the starting content match that content parsed into the
    //   top node is matched against.
    //
    //   context:: ?ResolvedPos
    //   A set of additional nodes to count as
    //   [context](#model.ParseRule.context) when parsing, above the
    //   given [top node](#model.ParseOptions.topNode).

    // ParseRule:: interface
    // A value that describes how to parse a given DOM node or inline
    // style as a ProseMirror node or mark.
    //
    //   tag:: ?string
    //   A CSS selector describing the kind of DOM elements to match. A
    //   single rule should have _either_ a `tag` or a `style` property.
    //
    //   namespace:: ?string
    //   The namespace to match. This should be used with `tag`.
    //   Nodes are only matched when the namespace matches or this property
    //   is null.
    //
    //   style:: ?string
    //   A CSS property name to match. When given, this rule matches
    //   inline styles that list that property. May also have the form
    //   `"property=value"`, in which case the rule only matches if the
    //   property's value exactly matches the given value. (For more
    //   complicated filters, use [`getAttrs`](#model.ParseRule.getAttrs)
    //   and return false to indicate that the match failed.) Rules
    //   matching styles may only produce [marks](#model.ParseRule.mark),
    //   not nodes.
    //
    //   priority:: ?number
    //   Can be used to change the order in which the parse rules in a
    //   schema are tried. Those with higher priority come first. Rules
    //   without a priority are counted as having priority 50. This
    //   property is only meaningful in a schema—when directly
    //   constructing a parser, the order of the rule array is used.
    //
    //   consuming:: ?boolean
    //   By default, when a rule matches an element or style, no further
    //   rules get a chance to match it. By setting this to `false`, you
    //   indicate that even when this rule matches, other rules that come
    //   after it should also run.
    //
    //   context:: ?string
    //   When given, restricts this rule to only match when the current
    //   context—the parent nodes into which the content is being
    //   parsed—matches this expression. Should contain one or more node
    //   names or node group names followed by single or double slashes.
    //   For example `"paragraph/"` means the rule only matches when the
    //   parent node is a paragraph, `"blockquote/paragraph/"` restricts
    //   it to be in a paragraph that is inside a blockquote, and
    //   `"section//"` matches any position inside a section—a double
    //   slash matches any sequence of ancestor nodes. To allow multiple
    //   different contexts, they can be separated by a pipe (`|`)
    //   character, as in `"blockquote/|list_item/"`.
    //
    //   node:: ?string
    //   The name of the node type to create when this rule matches. Only
    //   valid for rules with a `tag` property, not for style rules. Each
    //   rule should have one of a `node`, `mark`, or `ignore` property
    //   (except when it appears in a [node](#model.NodeSpec.parseDOM) or
    //   [mark spec](#model.MarkSpec.parseDOM), in which case the `node`
    //   or `mark` property will be derived from its position).
    //
    //   mark:: ?string
    //   The name of the mark type to wrap the matched content in.
    //
    //   ignore:: ?bool
    //   When true, ignore content that matches this rule.
    //
    //   closeParent:: ?bool
    //   When true, finding an element that matches this rule will close
    //   the current node.
    //
    //   skip:: ?bool
    //   When true, ignore the node that matches this rule, but do parse
    //   its content.
    //
    //   attrs:: ?Object
    //   Attributes for the node or mark created by this rule. When
    //   `getAttrs` is provided, it takes precedence.
    //
    //   getAttrs:: ?(union<dom.Node, string>) → ?union<Object, false>
    //   A function used to compute the attributes for the node or mark
    //   created by this rule. Can also be used to describe further
    //   conditions the DOM element or style must match. When it returns
    //   `false`, the rule won't match. When it returns null or undefined,
    //   that is interpreted as an empty/default set of attributes.
    //
    //   Called with a DOM Element for `tag` rules, and with a string (the
    //   style's value) for `style` rules.
    //
    //   contentElement:: ?union<string, (dom.Node) → dom.Node>
    //   For `tag` rules that produce non-leaf nodes or marks, by default
    //   the content of the DOM element is parsed as content of the mark
    //   or node. If the child nodes are in a descendent node, this may be
    //   a CSS selector string that the parser must use to find the actual
    //   content element, or a function that returns the actual content
    //   element to the parser.
    //
    //   getContent:: ?(dom.Node, schema: Schema) → Fragment
    //   Can be used to override the content of a matched node. When
    //   present, instead of parsing the node's child nodes, the result of
    //   this function is used.
    //
    //   preserveWhitespace:: ?union<bool, "full">
    //   Controls whether whitespace should be preserved when parsing the
    //   content inside the matched element. `false` means whitespace may
    //   be collapsed, `true` means that whitespace should be preserved
    //   but newlines normalized to spaces, and `"full"` means that
    //   newlines should also be preserved.

    // ::- A DOM parser represents a strategy for parsing DOM content into
    // a ProseMirror document conforming to a given schema. Its behavior
    // is defined by an array of [rules](#model.ParseRule).
    var DOMParser = function DOMParser(schema, rules) {
      var this$1 = this;

      // :: Schema
      // The schema into which the parser parses.
      this.schema = schema;
      // :: [ParseRule]
      // The set of [parse rules](#model.ParseRule) that the parser
      // uses, in order of precedence.
      this.rules = rules;
      this.tags = [];
      this.styles = [];

      rules.forEach(function (rule) {
        if (rule.tag) { this$1.tags.push(rule); }
        else if (rule.style) { this$1.styles.push(rule); }
      });

      // Only normalize list elements when lists in the schema can't directly contain themselves
      this.normalizeLists = !this.tags.some(function (r) {
        if (!/^(ul|ol)\b/.test(r.tag) || !r.node) { return false }
        var node = schema.nodes[r.node];
        return node.contentMatch.matchType(node)
      });
    };

    // :: (dom.Node, ?ParseOptions) → Node
    // Parse a document from the content of a DOM node.
    DOMParser.prototype.parse = function parse (dom, options) {
        if ( options === void 0 ) options = {};

      var context = new ParseContext(this, options, false);
      context.addAll(dom, null, options.from, options.to);
      return context.finish()
    };

    // :: (dom.Node, ?ParseOptions) → Slice
    // Parses the content of the given DOM node, like
    // [`parse`](#model.DOMParser.parse), and takes the same set of
    // options. But unlike that method, which produces a whole node,
    // this one returns a slice that is open at the sides, meaning that
    // the schema constraints aren't applied to the start of nodes to
    // the left of the input and the end of nodes at the end.
    DOMParser.prototype.parseSlice = function parseSlice (dom, options) {
        if ( options === void 0 ) options = {};

      var context = new ParseContext(this, options, true);
      context.addAll(dom, null, options.from, options.to);
      return Slice.maxOpen(context.finish())
    };

    DOMParser.prototype.matchTag = function matchTag (dom, context, after) {
      for (var i = after ? this.tags.indexOf(after) + 1 : 0; i < this.tags.length; i++) {
        var rule = this.tags[i];
        if (matches(dom, rule.tag) &&
            (rule.namespace === undefined || dom.namespaceURI == rule.namespace) &&
            (!rule.context || context.matchesContext(rule.context))) {
          if (rule.getAttrs) {
            var result = rule.getAttrs(dom);
            if (result === false) { continue }
            rule.attrs = result;
          }
          return rule
        }
      }
    };

    DOMParser.prototype.matchStyle = function matchStyle (prop, value, context, after) {
      for (var i = after ? this.styles.indexOf(after) + 1 : 0; i < this.styles.length; i++) {
        var rule = this.styles[i];
        if (rule.style.indexOf(prop) != 0 ||
            rule.context && !context.matchesContext(rule.context) ||
            // Test that the style string either precisely matches the prop,
            // or has an '=' sign after the prop, followed by the given
            // value.
            rule.style.length > prop.length &&
            (rule.style.charCodeAt(prop.length) != 61 || rule.style.slice(prop.length + 1) != value))
          { continue }
        if (rule.getAttrs) {
          var result = rule.getAttrs(value);
          if (result === false) { continue }
          rule.attrs = result;
        }
        return rule
      }
    };

    // : (Schema) → [ParseRule]
    DOMParser.schemaRules = function schemaRules (schema) {
      var result = [];
      function insert(rule) {
        var priority = rule.priority == null ? 50 : rule.priority, i = 0;
        for (; i < result.length; i++) {
          var next = result[i], nextPriority = next.priority == null ? 50 : next.priority;
          if (nextPriority < priority) { break }
        }
        result.splice(i, 0, rule);
      }

      var loop = function ( name ) {
        var rules = schema.marks[name].spec.parseDOM;
        if (rules) { rules.forEach(function (rule) {
          insert(rule = copy(rule));
          rule.mark = name;
        }); }
      };

        for (var name in schema.marks) loop( name );
      var loop$1 = function ( name ) {
        var rules$1 = schema.nodes[name$1].spec.parseDOM;
        if (rules$1) { rules$1.forEach(function (rule) {
          insert(rule = copy(rule));
          rule.node = name$1;
        }); }
      };

        for (var name$1 in schema.nodes) loop$1();
      return result
    };

    // :: (Schema) → DOMParser
    // Construct a DOM parser using the parsing rules listed in a
    // schema's [node specs](#model.NodeSpec.parseDOM), reordered by
    // [priority](#model.ParseRule.priority).
    DOMParser.fromSchema = function fromSchema (schema) {
      return schema.cached.domParser ||
        (schema.cached.domParser = new DOMParser(schema, DOMParser.schemaRules(schema)))
    };

    // : Object<bool> The block-level tags in HTML5
    var blockTags = {
      address: true, article: true, aside: true, blockquote: true, canvas: true,
      dd: true, div: true, dl: true, fieldset: true, figcaption: true, figure: true,
      footer: true, form: true, h1: true, h2: true, h3: true, h4: true, h5: true,
      h6: true, header: true, hgroup: true, hr: true, li: true, noscript: true, ol: true,
      output: true, p: true, pre: true, section: true, table: true, tfoot: true, ul: true
    };

    // : Object<bool> The tags that we normally ignore.
    var ignoreTags = {
      head: true, noscript: true, object: true, script: true, style: true, title: true
    };

    // : Object<bool> List tags.
    var listTags = {ol: true, ul: true};

    // Using a bitfield for node context options
    var OPT_PRESERVE_WS = 1, OPT_PRESERVE_WS_FULL = 2, OPT_OPEN_LEFT = 4;

    function wsOptionsFor(preserveWhitespace) {
      return (preserveWhitespace ? OPT_PRESERVE_WS : 0) | (preserveWhitespace === "full" ? OPT_PRESERVE_WS_FULL : 0)
    }

    var NodeContext = function NodeContext(type, attrs, marks, pendingMarks, solid, match, options) {
      this.type = type;
      this.attrs = attrs;
      this.solid = solid;
      this.match = match || (options & OPT_OPEN_LEFT ? null : type.contentMatch);
      this.options = options;
      this.content = [];
      // Marks applied to this node itself
      this.marks = marks;
      // Marks applied to its children
      this.activeMarks = Mark.none;
      // Marks that can't apply here, but will be used in children if possible
      this.pendingMarks = pendingMarks;
      // Nested Marks with same type
      this.stashMarks = [];
    };

    NodeContext.prototype.findWrapping = function findWrapping (node) {
      if (!this.match) {
        if (!this.type) { return [] }
        var fill = this.type.contentMatch.fillBefore(Fragment.from(node));
        if (fill) {
          this.match = this.type.contentMatch.matchFragment(fill);
        } else {
          var start = this.type.contentMatch, wrap;
          if (wrap = start.findWrapping(node.type)) {
            this.match = start;
            return wrap
          } else {
            return null
          }
        }
      }
      return this.match.findWrapping(node.type)
    };

    NodeContext.prototype.finish = function finish (openEnd) {
      if (!(this.options & OPT_PRESERVE_WS)) { // Strip trailing whitespace
        var last = this.content[this.content.length - 1], m;
        if (last && last.isText && (m = /[ \t\r\n\u000c]+$/.exec(last.text))) {
          if (last.text.length == m[0].length) { this.content.pop(); }
          else { this.content[this.content.length - 1] = last.withText(last.text.slice(0, last.text.length - m[0].length)); }
        }
      }
      var content = Fragment.from(this.content);
      if (!openEnd && this.match)
        { content = content.append(this.match.fillBefore(Fragment.empty, true)); }
      return this.type ? this.type.create(this.attrs, content, this.marks) : content
    };

    NodeContext.prototype.popFromStashMark = function popFromStashMark (mark) {
      for (var i = this.stashMarks.length - 1; i >= 0; i--)
        { if (mark.eq(this.stashMarks[i])) { return this.stashMarks.splice(i, 1)[0] } }
    };

    NodeContext.prototype.applyPending = function applyPending (nextType) {
      for (var i = 0, pending = this.pendingMarks; i < pending.length; i++) {
        var mark = pending[i];
        if ((this.type ? this.type.allowsMarkType(mark.type) : markMayApply(mark.type, nextType)) &&
            !mark.isInSet(this.activeMarks)) {
          this.activeMarks = mark.addToSet(this.activeMarks);
          this.pendingMarks = mark.removeFromSet(this.pendingMarks);
        }
      }
    };

    var ParseContext = function ParseContext(parser, options, open) {
      // : DOMParser The parser we are using.
      this.parser = parser;
      // : Object The options passed to this parse.
      this.options = options;
      this.isOpen = open;
      var topNode = options.topNode, topContext;
      var topOptions = wsOptionsFor(options.preserveWhitespace) | (open ? OPT_OPEN_LEFT : 0);
      if (topNode)
        { topContext = new NodeContext(topNode.type, topNode.attrs, Mark.none, Mark.none, true,
                                     options.topMatch || topNode.type.contentMatch, topOptions); }
      else if (open)
        { topContext = new NodeContext(null, null, Mark.none, Mark.none, true, null, topOptions); }
      else
        { topContext = new NodeContext(parser.schema.topNodeType, null, Mark.none, Mark.none, true, null, topOptions); }
      this.nodes = [topContext];
      // : [Mark] The current set of marks
      this.open = 0;
      this.find = options.findPositions;
      this.needsBlock = false;
    };

    var prototypeAccessors$6 = { top: { configurable: true },currentPos: { configurable: true } };

    prototypeAccessors$6.top.get = function () {
      return this.nodes[this.open]
    };

    // : (dom.Node)
    // Add a DOM node to the content. Text is inserted as text node,
    // otherwise, the node is passed to `addElement` or, if it has a
    // `style` attribute, `addElementWithStyles`.
    ParseContext.prototype.addDOM = function addDOM (dom) {
      if (dom.nodeType == 3) {
        this.addTextNode(dom);
      } else if (dom.nodeType == 1) {
        var style = dom.getAttribute("style");
        var marks = style ? this.readStyles(parseStyles(style)) : null, top = this.top;
        if (marks != null) { for (var i = 0; i < marks.length; i++) { this.addPendingMark(marks[i]); } }
        this.addElement(dom);
        if (marks != null) { for (var i$1 = 0; i$1 < marks.length; i$1++) { this.removePendingMark(marks[i$1], top); } }
      }
    };

    ParseContext.prototype.addTextNode = function addTextNode (dom) {
      var value = dom.nodeValue;
      var top = this.top;
      if ((top.type ? top.type.inlineContent : top.content.length && top.content[0].isInline) || /[^ \t\r\n\u000c]/.test(value)) {
        if (!(top.options & OPT_PRESERVE_WS)) {
          value = value.replace(/[ \t\r\n\u000c]+/g, " ");
          // If this starts with whitespace, and there is no node before it, or
          // a hard break, or a text node that ends with whitespace, strip the
          // leading space.
          if (/^[ \t\r\n\u000c]/.test(value) && this.open == this.nodes.length - 1) {
            var nodeBefore = top.content[top.content.length - 1];
            var domNodeBefore = dom.previousSibling;
            if (!nodeBefore ||
                (domNodeBefore && domNodeBefore.nodeName == 'BR') ||
                (nodeBefore.isText && /[ \t\r\n\u000c]$/.test(nodeBefore.text)))
              { value = value.slice(1); }
          }
        } else if (!(top.options & OPT_PRESERVE_WS_FULL)) {
          value = value.replace(/\r?\n|\r/g, " ");
        }
        if (value) { this.insertNode(this.parser.schema.text(value)); }
        this.findInText(dom);
      } else {
        this.findInside(dom);
      }
    };

    // : (dom.Element, ?ParseRule)
    // Try to find a handler for the given tag and use that to parse. If
    // none is found, the element's content nodes are added directly.
    ParseContext.prototype.addElement = function addElement (dom, matchAfter) {
      var name = dom.nodeName.toLowerCase(), ruleID;
      if (listTags.hasOwnProperty(name) && this.parser.normalizeLists) { normalizeList(dom); }
      var rule = (this.options.ruleFromNode && this.options.ruleFromNode(dom)) ||
          (ruleID = this.parser.matchTag(dom, this, matchAfter));
      if (rule ? rule.ignore : ignoreTags.hasOwnProperty(name)) {
        this.findInside(dom);
      } else if (!rule || rule.skip || rule.closeParent) {
        if (rule && rule.closeParent) { this.open = Math.max(0, this.open - 1); }
        else if (rule && rule.skip.nodeType) { dom = rule.skip; }
        var sync, top = this.top, oldNeedsBlock = this.needsBlock;
        if (blockTags.hasOwnProperty(name)) {
          sync = true;
          if (!top.type) { this.needsBlock = true; }
        } else if (!dom.firstChild) {
          this.leafFallback(dom);
          return
        }
        this.addAll(dom);
        if (sync) { this.sync(top); }
        this.needsBlock = oldNeedsBlock;
      } else {
        this.addElementByRule(dom, rule, rule.consuming === false ? ruleID : null);
      }
    };

    // Called for leaf DOM nodes that would otherwise be ignored
    ParseContext.prototype.leafFallback = function leafFallback (dom) {
      if (dom.nodeName == "BR" && this.top.type && this.top.type.inlineContent)
        { this.addTextNode(dom.ownerDocument.createTextNode("\n")); }
    };

    // Run any style parser associated with the node's styles. Either
    // return an array of marks, or null to indicate some of the styles
    // had a rule with `ignore` set.
    ParseContext.prototype.readStyles = function readStyles (styles) {
      var marks = Mark.none;
      style: for (var i = 0; i < styles.length; i += 2) {
        for (var after = null;;) {
          var rule = this.parser.matchStyle(styles[i], styles[i + 1], this, after);
          if (!rule) { continue style }
          if (rule.ignore) { return null }
          marks = this.parser.schema.marks[rule.mark].create(rule.attrs).addToSet(marks);
          if (rule.consuming === false) { after = rule; }
          else { break }
        }
      }
      return marks
    };

    // : (dom.Element, ParseRule) → bool
    // Look up a handler for the given node. If none are found, return
    // false. Otherwise, apply it, use its return value to drive the way
    // the node's content is wrapped, and return true.
    ParseContext.prototype.addElementByRule = function addElementByRule (dom, rule, continueAfter) {
        var this$1 = this;

      var sync, nodeType, markType, mark;
      if (rule.node) {
        nodeType = this.parser.schema.nodes[rule.node];
        if (!nodeType.isLeaf) {
          sync = this.enter(nodeType, rule.attrs, rule.preserveWhitespace);
        } else if (!this.insertNode(nodeType.create(rule.attrs))) {
          this.leafFallback(dom);
        }
      } else {
        markType = this.parser.schema.marks[rule.mark];
        mark = markType.create(rule.attrs);
        this.addPendingMark(mark);
      }
      var startIn = this.top;

      if (nodeType && nodeType.isLeaf) {
        this.findInside(dom);
      } else if (continueAfter) {
        this.addElement(dom, continueAfter);
      } else if (rule.getContent) {
        this.findInside(dom);
        rule.getContent(dom, this.parser.schema).forEach(function (node) { return this$1.insertNode(node); });
      } else {
        var contentDOM = rule.contentElement;
        if (typeof contentDOM == "string") { contentDOM = dom.querySelector(contentDOM); }
        else if (typeof contentDOM == "function") { contentDOM = contentDOM(dom); }
        if (!contentDOM) { contentDOM = dom; }
        this.findAround(dom, contentDOM, true);
        this.addAll(contentDOM, sync);
      }
      if (sync) { this.sync(startIn); this.open--; }
      if (mark) { this.removePendingMark(mark, startIn); }
    };

    // : (dom.Node, ?NodeBuilder, ?number, ?number)
    // Add all child nodes between `startIndex` and `endIndex` (or the
    // whole node, if not given). If `sync` is passed, use it to
    // synchronize after every block element.
    ParseContext.prototype.addAll = function addAll (parent, sync, startIndex, endIndex) {
      var index = startIndex || 0;
      for (var dom = startIndex ? parent.childNodes[startIndex] : parent.firstChild,
               end = endIndex == null ? null : parent.childNodes[endIndex];
           dom != end; dom = dom.nextSibling, ++index) {
        this.findAtPoint(parent, index);
        this.addDOM(dom);
        if (sync && blockTags.hasOwnProperty(dom.nodeName.toLowerCase()))
          { this.sync(sync); }
      }
      this.findAtPoint(parent, index);
    };

    // Try to find a way to fit the given node type into the current
    // context. May add intermediate wrappers and/or leave non-solid
    // nodes that we're in.
    ParseContext.prototype.findPlace = function findPlace (node) {
      var route, sync;
      for (var depth = this.open; depth >= 0; depth--) {
        var cx = this.nodes[depth];
        var found = cx.findWrapping(node);
        if (found && (!route || route.length > found.length)) {
          route = found;
          sync = cx;
          if (!found.length) { break }
        }
        if (cx.solid) { break }
      }
      if (!route) { return false }
      this.sync(sync);
      for (var i = 0; i < route.length; i++)
        { this.enterInner(route[i], null, false); }
      return true
    };

    // : (Node) → ?Node
    // Try to insert the given node, adjusting the context when needed.
    ParseContext.prototype.insertNode = function insertNode (node) {
      if (node.isInline && this.needsBlock && !this.top.type) {
        var block = this.textblockFromContext();
        if (block) { this.enterInner(block); }
      }
      if (this.findPlace(node)) {
        this.closeExtra();
        var top = this.top;
        top.applyPending(node.type);
        if (top.match) { top.match = top.match.matchType(node.type); }
        var marks = top.activeMarks;
        for (var i = 0; i < node.marks.length; i++)
          { if (!top.type || top.type.allowsMarkType(node.marks[i].type))
            { marks = node.marks[i].addToSet(marks); } }
        top.content.push(node.mark(marks));
        return true
      }
      return false
    };

    // : (NodeType, ?Object) → bool
    // Try to start a node of the given type, adjusting the context when
    // necessary.
    ParseContext.prototype.enter = function enter (type, attrs, preserveWS) {
      var ok = this.findPlace(type.create(attrs));
      if (ok) { this.enterInner(type, attrs, true, preserveWS); }
      return ok
    };

    // Open a node of the given type
    ParseContext.prototype.enterInner = function enterInner (type, attrs, solid, preserveWS) {
      this.closeExtra();
      var top = this.top;
      top.applyPending(type);
      top.match = top.match && top.match.matchType(type, attrs);
      var options = preserveWS == null ? top.options & ~OPT_OPEN_LEFT : wsOptionsFor(preserveWS);
      if ((top.options & OPT_OPEN_LEFT) && top.content.length == 0) { options |= OPT_OPEN_LEFT; }
      this.nodes.push(new NodeContext(type, attrs, top.activeMarks, top.pendingMarks, solid, null, options));
      this.open++;
    };

    // Make sure all nodes above this.open are finished and added to
    // their parents
    ParseContext.prototype.closeExtra = function closeExtra (openEnd) {
      var i = this.nodes.length - 1;
      if (i > this.open) {
        for (; i > this.open; i--) { this.nodes[i - 1].content.push(this.nodes[i].finish(openEnd)); }
        this.nodes.length = this.open + 1;
      }
    };

    ParseContext.prototype.finish = function finish () {
      this.open = 0;
      this.closeExtra(this.isOpen);
      return this.nodes[0].finish(this.isOpen || this.options.topOpen)
    };

    ParseContext.prototype.sync = function sync (to) {
      for (var i = this.open; i >= 0; i--) { if (this.nodes[i] == to) {
        this.open = i;
        return
      } }
    };

    prototypeAccessors$6.currentPos.get = function () {
      this.closeExtra();
      var pos = 0;
      for (var i = this.open; i >= 0; i--) {
        var content = this.nodes[i].content;
        for (var j = content.length - 1; j >= 0; j--)
          { pos += content[j].nodeSize; }
        if (i) { pos++; }
      }
      return pos
    };

    ParseContext.prototype.findAtPoint = function findAtPoint (parent, offset) {
      if (this.find) { for (var i = 0; i < this.find.length; i++) {
        if (this.find[i].node == parent && this.find[i].offset == offset)
          { this.find[i].pos = this.currentPos; }
      } }
    };

    ParseContext.prototype.findInside = function findInside (parent) {
      if (this.find) { for (var i = 0; i < this.find.length; i++) {
        if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node))
          { this.find[i].pos = this.currentPos; }
      } }
    };

    ParseContext.prototype.findAround = function findAround (parent, content, before) {
      if (parent != content && this.find) { for (var i = 0; i < this.find.length; i++) {
        if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node)) {
          var pos = content.compareDocumentPosition(this.find[i].node);
          if (pos & (before ? 2 : 4))
            { this.find[i].pos = this.currentPos; }
        }
      } }
    };

    ParseContext.prototype.findInText = function findInText (textNode) {
      if (this.find) { for (var i = 0; i < this.find.length; i++) {
        if (this.find[i].node == textNode)
          { this.find[i].pos = this.currentPos - (textNode.nodeValue.length - this.find[i].offset); }
      } }
    };

    // : (string) → bool
    // Determines whether the given [context
    // string](#ParseRule.context) matches this context.
    ParseContext.prototype.matchesContext = function matchesContext (context) {
        var this$1 = this;

      if (context.indexOf("|") > -1)
        { return context.split(/\s*\|\s*/).some(this.matchesContext, this) }

      var parts = context.split("/");
      var option = this.options.context;
      var useRoot = !this.isOpen && (!option || option.parent.type == this.nodes[0].type);
      var minDepth = -(option ? option.depth + 1 : 0) + (useRoot ? 0 : 1);
      var match = function (i, depth) {
        for (; i >= 0; i--) {
          var part = parts[i];
          if (part == "") {
            if (i == parts.length - 1 || i == 0) { continue }
            for (; depth >= minDepth; depth--)
              { if (match(i - 1, depth)) { return true } }
            return false
          } else {
            var next = depth > 0 || (depth == 0 && useRoot) ? this$1.nodes[depth].type
                : option && depth >= minDepth ? option.node(depth - minDepth).type
                : null;
            if (!next || (next.name != part && next.groups.indexOf(part) == -1))
              { return false }
            depth--;
          }
        }
        return true
      };
      return match(parts.length - 1, this.open)
    };

    ParseContext.prototype.textblockFromContext = function textblockFromContext () {
      var $context = this.options.context;
      if ($context) { for (var d = $context.depth; d >= 0; d--) {
        var deflt = $context.node(d).contentMatchAt($context.indexAfter(d)).defaultType;
        if (deflt && deflt.isTextblock && deflt.defaultAttrs) { return deflt }
      } }
      for (var name in this.parser.schema.nodes) {
        var type = this.parser.schema.nodes[name];
        if (type.isTextblock && type.defaultAttrs) { return type }
      }
    };

    ParseContext.prototype.addPendingMark = function addPendingMark (mark) {
      var found = findSameMarkInSet(mark, this.top.pendingMarks);
      if (found) { this.top.stashMarks.push(found); }
      this.top.pendingMarks = mark.addToSet(this.top.pendingMarks);
    };

    ParseContext.prototype.removePendingMark = function removePendingMark (mark, upto) {
      for (var depth = this.open; depth >= 0; depth--) {
        var level = this.nodes[depth];
        var found = level.pendingMarks.lastIndexOf(mark);
        if (found > -1) {
          level.pendingMarks = mark.removeFromSet(level.pendingMarks);
        } else {
          level.activeMarks = mark.removeFromSet(level.activeMarks);
          var stashMark = level.popFromStashMark(mark);
          if (stashMark && level.type && level.type.allowsMarkType(stashMark.type))
            { level.activeMarks = stashMark.addToSet(level.activeMarks); }
        }
        if (level == upto) { break }
      }
    };

    Object.defineProperties( ParseContext.prototype, prototypeAccessors$6 );

    // Kludge to work around directly nested list nodes produced by some
    // tools and allowed by browsers to mean that the nested list is
    // actually part of the list item above it.
    function normalizeList(dom) {
      for (var child = dom.firstChild, prevItem = null; child; child = child.nextSibling) {
        var name = child.nodeType == 1 ? child.nodeName.toLowerCase() : null;
        if (name && listTags.hasOwnProperty(name) && prevItem) {
          prevItem.appendChild(child);
          child = prevItem;
        } else if (name == "li") {
          prevItem = child;
        } else if (name) {
          prevItem = null;
        }
      }
    }

    // Apply a CSS selector.
    function matches(dom, selector) {
      return (dom.matches || dom.msMatchesSelector || dom.webkitMatchesSelector || dom.mozMatchesSelector).call(dom, selector)
    }

    // : (string) → [string]
    // Tokenize a style attribute into property/value pairs.
    function parseStyles(style) {
      var re = /\s*([\w-]+)\s*:\s*([^;]+)/g, m, result = [];
      while (m = re.exec(style)) { result.push(m[1], m[2].trim()); }
      return result
    }

    function copy(obj) {
      var copy = {};
      for (var prop in obj) { copy[prop] = obj[prop]; }
      return copy
    }

    // Used when finding a mark at the top level of a fragment parse.
    // Checks whether it would be reasonable to apply a given mark type to
    // a given node, by looking at the way the mark occurs in the schema.
    function markMayApply(markType, nodeType) {
      var nodes = nodeType.schema.nodes;
      var loop = function ( name ) {
        var parent = nodes[name];
        if (!parent.allowsMarkType(markType)) { return }
        var seen = [], scan = function (match) {
          seen.push(match);
          for (var i = 0; i < match.edgeCount; i++) {
            var ref = match.edge(i);
            var type = ref.type;
            var next = ref.next;
            if (type == nodeType) { return true }
            if (seen.indexOf(next) < 0 && scan(next)) { return true }
          }
        };
        if (scan(parent.contentMatch)) { return { v: true } }
      };

      for (var name in nodes) {
        var returned = loop( name );

        if ( returned ) return returned.v;
      }
    }

    function findSameMarkInSet(mark, set) {
      for (var i = 0; i < set.length; i++) {
        if (mark.eq(set[i])) { return set[i] }
      }
    }

    // DOMOutputSpec:: interface
    // A description of a DOM structure. Can be either a string, which is
    // interpreted as a text node, a DOM node, which is interpreted as
    // itself, a `{dom: Node, contentDOM: ?Node}` object, or an array.
    //
    // An array describes a DOM element. The first value in the array
    // should be a string—the name of the DOM element, optionally prefixed
    // by a namespace URL and a space. If the second element is plain
    // object, it is interpreted as a set of attributes for the element.
    // Any elements after that (including the 2nd if it's not an attribute
    // object) are interpreted as children of the DOM elements, and must
    // either be valid `DOMOutputSpec` values, or the number zero.
    //
    // The number zero (pronounced “hole”) is used to indicate the place
    // where a node's child nodes should be inserted. If it occurs in an
    // output spec, it should be the only child element in its parent
    // node.

    // ::- A DOM serializer knows how to convert ProseMirror nodes and
    // marks of various types to DOM nodes.
    var DOMSerializer = function DOMSerializer(nodes, marks) {
      // :: Object<(node: Node) → DOMOutputSpec>
      // The node serialization functions.
      this.nodes = nodes || {};
      // :: Object<?(mark: Mark, inline: bool) → DOMOutputSpec>
      // The mark serialization functions.
      this.marks = marks || {};
    };

    // :: (Fragment, ?Object) → dom.DocumentFragment
    // Serialize the content of this fragment to a DOM fragment. When
    // not in the browser, the `document` option, containing a DOM
    // document, should be passed so that the serializer can create
    // nodes.
    DOMSerializer.prototype.serializeFragment = function serializeFragment (fragment, options, target) {
        var this$1 = this;
        if ( options === void 0 ) options = {};

      if (!target) { target = doc(options).createDocumentFragment(); }

      var top = target, active = null;
      fragment.forEach(function (node) {
        if (active || node.marks.length) {
          if (!active) { active = []; }
          var keep = 0, rendered = 0;
          while (keep < active.length && rendered < node.marks.length) {
            var next = node.marks[rendered];
            if (!this$1.marks[next.type.name]) { rendered++; continue }
            if (!next.eq(active[keep]) || next.type.spec.spanning === false) { break }
            keep += 2; rendered++;
          }
          while (keep < active.length) {
            top = active.pop();
            active.pop();
          }
          while (rendered < node.marks.length) {
            var add = node.marks[rendered++];
            var markDOM = this$1.serializeMark(add, node.isInline, options);
            if (markDOM) {
              active.push(add, top);
              top.appendChild(markDOM.dom);
              top = markDOM.contentDOM || markDOM.dom;
            }
          }
        }
        top.appendChild(this$1.serializeNode(node, options));
      });

      return target
    };

    // :: (Node, ?Object) → dom.Node
    // Serialize this node to a DOM node. This can be useful when you
    // need to serialize a part of a document, as opposed to the whole
    // document. To serialize a whole document, use
    // [`serializeFragment`](#model.DOMSerializer.serializeFragment) on
    // its [content](#model.Node.content).
    DOMSerializer.prototype.serializeNode = function serializeNode (node, options) {
        if ( options === void 0 ) options = {};

      var ref =
          DOMSerializer.renderSpec(doc(options), this.nodes[node.type.name](node));
        var dom = ref.dom;
        var contentDOM = ref.contentDOM;
      if (contentDOM) {
        if (node.isLeaf)
          { throw new RangeError("Content hole not allowed in a leaf node spec") }
        if (options.onContent)
          { options.onContent(node, contentDOM, options); }
        else
          { this.serializeFragment(node.content, options, contentDOM); }
      }
      return dom
    };

    DOMSerializer.prototype.serializeNodeAndMarks = function serializeNodeAndMarks (node, options) {
        if ( options === void 0 ) options = {};

      var dom = this.serializeNode(node, options);
      for (var i = node.marks.length - 1; i >= 0; i--) {
        var wrap = this.serializeMark(node.marks[i], node.isInline, options);
        if (wrap) {
    (wrap.contentDOM || wrap.dom).appendChild(dom);
          dom = wrap.dom;
        }
      }
      return dom
    };

    DOMSerializer.prototype.serializeMark = function serializeMark (mark, inline, options) {
        if ( options === void 0 ) options = {};

      var toDOM = this.marks[mark.type.name];
      return toDOM && DOMSerializer.renderSpec(doc(options), toDOM(mark, inline))
    };

    // :: (dom.Document, DOMOutputSpec) → {dom: dom.Node, contentDOM: ?dom.Node}
    // Render an [output spec](#model.DOMOutputSpec) to a DOM node. If
    // the spec has a hole (zero) in it, `contentDOM` will point at the
    // node with the hole.
    DOMSerializer.renderSpec = function renderSpec (doc, structure, xmlNS) {
        if ( xmlNS === void 0 ) xmlNS = null;

      if (typeof structure == "string")
        { return {dom: doc.createTextNode(structure)} }
      if (structure.nodeType != null)
        { return {dom: structure} }
      if (structure.dom && structure.dom.nodeType != null)
        { return structure }
      var tagName = structure[0], space = tagName.indexOf(" ");
      if (space > 0) {
        xmlNS = tagName.slice(0, space);
        tagName = tagName.slice(space + 1);
      }
      var contentDOM = null, dom = xmlNS ? doc.createElementNS(xmlNS, tagName) : doc.createElement(tagName);
      var attrs = structure[1], start = 1;
      if (attrs && typeof attrs == "object" && attrs.nodeType == null && !Array.isArray(attrs)) {
        start = 2;
        for (var name in attrs) { if (attrs[name] != null) {
          var space$1 = name.indexOf(" ");
          if (space$1 > 0) { dom.setAttributeNS(name.slice(0, space$1), name.slice(space$1 + 1), attrs[name]); }
          else { dom.setAttribute(name, attrs[name]); }
        } }
      }
      for (var i = start; i < structure.length; i++) {
        var child = structure[i];
        if (child === 0) {
          if (i < structure.length - 1 || i > start)
            { throw new RangeError("Content hole must be the only child of its parent node") }
          return {dom: dom, contentDOM: dom}
        } else {
          var ref = DOMSerializer.renderSpec(doc, child, xmlNS);
            var inner = ref.dom;
            var innerContent = ref.contentDOM;
          dom.appendChild(inner);
          if (innerContent) {
            if (contentDOM) { throw new RangeError("Multiple content holes") }
            contentDOM = innerContent;
          }
        }
      }
      return {dom: dom, contentDOM: contentDOM}
    };

    // :: (Schema) → DOMSerializer
    // Build a serializer using the [`toDOM`](#model.NodeSpec.toDOM)
    // properties in a schema's node and mark specs.
    DOMSerializer.fromSchema = function fromSchema (schema) {
      return schema.cached.domSerializer ||
        (schema.cached.domSerializer = new DOMSerializer(this.nodesFromSchema(schema), this.marksFromSchema(schema)))
    };

    // : (Schema) → Object<(node: Node) → DOMOutputSpec>
    // Gather the serializers in a schema's node specs into an object.
    // This can be useful as a base to build a custom serializer from.
    DOMSerializer.nodesFromSchema = function nodesFromSchema (schema) {
      var result = gatherToDOM(schema.nodes);
      if (!result.text) { result.text = function (node) { return node.text; }; }
      return result
    };

    // : (Schema) → Object<(mark: Mark) → DOMOutputSpec>
    // Gather the serializers in a schema's mark specs into an object.
    DOMSerializer.marksFromSchema = function marksFromSchema (schema) {
      return gatherToDOM(schema.marks)
    };

    function gatherToDOM(obj) {
      var result = {};
      for (var name in obj) {
        var toDOM = obj[name].spec.toDOM;
        if (toDOM) { result[name] = toDOM; }
      }
      return result
    }

    function doc(options) {
      // declare global: window
      return options.document || window.document
    }
    //# sourceMappingURL=index.es.js.map

    // Mappable:: interface
    // There are several things that positions can be mapped through.
    // Such objects conform to this interface.
    //
    //   map:: (pos: number, assoc: ?number) → number
    //   Map a position through this object. When given, `assoc` (should
    //   be -1 or 1, defaults to 1) determines with which side the
    //   position is associated, which determines in which direction to
    //   move when a chunk of content is inserted at the mapped position.
    //
    //   mapResult:: (pos: number, assoc: ?number) → MapResult
    //   Map a position, and return an object containing additional
    //   information about the mapping. The result's `deleted` field tells
    //   you whether the position was deleted (completely enclosed in a
    //   replaced range) during the mapping. When content on only one side
    //   is deleted, the position itself is only considered deleted when
    //   `assoc` points in the direction of the deleted content.

    // Recovery values encode a range index and an offset. They are
    // represented as numbers, because tons of them will be created when
    // mapping, for example, a large number of decorations. The number's
    // lower 16 bits provide the index, the remaining bits the offset.
    //
    // Note: We intentionally don't use bit shift operators to en- and
    // decode these, since those clip to 32 bits, which we might in rare
    // cases want to overflow. A 64-bit float can represent 48-bit
    // integers precisely.

    var lower16 = 0xffff;
    var factor16 = Math.pow(2, 16);

    function makeRecover(index, offset) { return index + offset * factor16 }
    function recoverIndex(value) { return value & lower16 }
    function recoverOffset(value) { return (value - (value & lower16)) / factor16 }

    // ::- An object representing a mapped position with extra
    // information.
    var MapResult = function MapResult(pos, deleted, recover) {
      if ( deleted === void 0 ) deleted = false;
      if ( recover === void 0 ) recover = null;

      // :: number The mapped version of the position.
      this.pos = pos;
      // :: bool Tells you whether the position was deleted, that is,
      // whether the step removed its surroundings from the document.
      this.deleted = deleted;
      this.recover = recover;
    };

    // :: class extends Mappable
    // A map describing the deletions and insertions made by a step, which
    // can be used to find the correspondence between positions in the
    // pre-step version of a document and the same position in the
    // post-step version.
    var StepMap = function StepMap(ranges, inverted) {
      if ( inverted === void 0 ) inverted = false;

      this.ranges = ranges;
      this.inverted = inverted;
    };

    StepMap.prototype.recover = function recover (value) {
      var diff = 0, index = recoverIndex(value);
      if (!this.inverted) { for (var i = 0; i < index; i++)
        { diff += this.ranges[i * 3 + 2] - this.ranges[i * 3 + 1]; } }
      return this.ranges[index * 3] + diff + recoverOffset(value)
    };

    // : (number, ?number) → MapResult
    StepMap.prototype.mapResult = function mapResult (pos, assoc) {
      if ( assoc === void 0 ) assoc = 1;
     return this._map(pos, assoc, false) };

    // : (number, ?number) → number
    StepMap.prototype.map = function map (pos, assoc) {
      if ( assoc === void 0 ) assoc = 1;
     return this._map(pos, assoc, true) };

    StepMap.prototype._map = function _map (pos, assoc, simple) {
      var diff = 0, oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
      for (var i = 0; i < this.ranges.length; i += 3) {
        var start = this.ranges[i] - (this.inverted ? diff : 0);
        if (start > pos) { break }
        var oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex], end = start + oldSize;
        if (pos <= end) {
          var side = !oldSize ? assoc : pos == start ? -1 : pos == end ? 1 : assoc;
          var result = start + diff + (side < 0 ? 0 : newSize);
          if (simple) { return result }
          var recover = pos == (assoc < 0 ? start : end) ? null : makeRecover(i / 3, pos - start);
          return new MapResult(result, assoc < 0 ? pos != start : pos != end, recover)
        }
        diff += newSize - oldSize;
      }
      return simple ? pos + diff : new MapResult(pos + diff)
    };

    StepMap.prototype.touches = function touches (pos, recover) {
      var diff = 0, index = recoverIndex(recover);
      var oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
      for (var i = 0; i < this.ranges.length; i += 3) {
        var start = this.ranges[i] - (this.inverted ? diff : 0);
        if (start > pos) { break }
        var oldSize = this.ranges[i + oldIndex], end = start + oldSize;
        if (pos <= end && i == index * 3) { return true }
        diff += this.ranges[i + newIndex] - oldSize;
      }
      return false
    };

    // :: ((oldStart: number, oldEnd: number, newStart: number, newEnd: number))
    // Calls the given function on each of the changed ranges included in
    // this map.
    StepMap.prototype.forEach = function forEach (f) {
      var oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
      for (var i = 0, diff = 0; i < this.ranges.length; i += 3) {
        var start = this.ranges[i], oldStart = start - (this.inverted ? diff : 0), newStart = start + (this.inverted ? 0 : diff);
        var oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex];
        f(oldStart, oldStart + oldSize, newStart, newStart + newSize);
        diff += newSize - oldSize;
      }
    };

    // :: () → StepMap
    // Create an inverted version of this map. The result can be used to
    // map positions in the post-step document to the pre-step document.
    StepMap.prototype.invert = function invert () {
      return new StepMap(this.ranges, !this.inverted)
    };

    StepMap.prototype.toString = function toString () {
      return (this.inverted ? "-" : "") + JSON.stringify(this.ranges)
    };

    // :: (n: number) → StepMap
    // Create a map that moves all positions by offset `n` (which may be
    // negative). This can be useful when applying steps meant for a
    // sub-document to a larger document, or vice-versa.
    StepMap.offset = function offset (n) {
      return n == 0 ? StepMap.empty : new StepMap(n < 0 ? [0, -n, 0] : [0, 0, n])
    };

    StepMap.empty = new StepMap([]);

    // :: class extends Mappable
    // A mapping represents a pipeline of zero or more [step
    // maps](#transform.StepMap). It has special provisions for losslessly
    // handling mapping positions through a series of steps in which some
    // steps are inverted versions of earlier steps. (This comes up when
    // ‘[rebasing](/docs/guide/#transform.rebasing)’ steps for
    // collaboration or history management.)
    var Mapping = function Mapping(maps, mirror, from, to) {
      // :: [StepMap]
      // The step maps in this mapping.
      this.maps = maps || [];
      // :: number
      // The starting position in the `maps` array, used when `map` or
      // `mapResult` is called.
      this.from = from || 0;
      // :: number
      // The end position in the `maps` array.
      this.to = to == null ? this.maps.length : to;
      this.mirror = mirror;
    };

    // :: (?number, ?number) → Mapping
    // Create a mapping that maps only through a part of this one.
    Mapping.prototype.slice = function slice (from, to) {
        if ( from === void 0 ) from = 0;
        if ( to === void 0 ) to = this.maps.length;

      return new Mapping(this.maps, this.mirror, from, to)
    };

    Mapping.prototype.copy = function copy () {
      return new Mapping(this.maps.slice(), this.mirror && this.mirror.slice(), this.from, this.to)
    };

    // :: (StepMap, ?number)
    // Add a step map to the end of this mapping. If `mirrors` is
    // given, it should be the index of the step map that is the mirror
    // image of this one.
    Mapping.prototype.appendMap = function appendMap (map, mirrors) {
      this.to = this.maps.push(map);
      if (mirrors != null) { this.setMirror(this.maps.length - 1, mirrors); }
    };

    // :: (Mapping)
    // Add all the step maps in a given mapping to this one (preserving
    // mirroring information).
    Mapping.prototype.appendMapping = function appendMapping (mapping) {
      for (var i = 0, startSize = this.maps.length; i < mapping.maps.length; i++) {
        var mirr = mapping.getMirror(i);
        this.appendMap(mapping.maps[i], mirr != null && mirr < i ? startSize + mirr : null);
      }
    };

    // :: (number) → ?number
    // Finds the offset of the step map that mirrors the map at the
    // given offset, in this mapping (as per the second argument to
    // `appendMap`).
    Mapping.prototype.getMirror = function getMirror (n) {
      if (this.mirror) { for (var i = 0; i < this.mirror.length; i++)
        { if (this.mirror[i] == n) { return this.mirror[i + (i % 2 ? -1 : 1)] } } }
    };

    Mapping.prototype.setMirror = function setMirror (n, m) {
      if (!this.mirror) { this.mirror = []; }
      this.mirror.push(n, m);
    };

    // :: (Mapping)
    // Append the inverse of the given mapping to this one.
    Mapping.prototype.appendMappingInverted = function appendMappingInverted (mapping) {
      for (var i = mapping.maps.length - 1, totalSize = this.maps.length + mapping.maps.length; i >= 0; i--) {
        var mirr = mapping.getMirror(i);
        this.appendMap(mapping.maps[i].invert(), mirr != null && mirr > i ? totalSize - mirr - 1 : null);
      }
    };

    // :: () → Mapping
    // Create an inverted version of this mapping.
    Mapping.prototype.invert = function invert () {
      var inverse = new Mapping;
      inverse.appendMappingInverted(this);
      return inverse
    };

    // : (number, ?number) → number
    // Map a position through this mapping.
    Mapping.prototype.map = function map (pos, assoc) {
        if ( assoc === void 0 ) assoc = 1;

      if (this.mirror) { return this._map(pos, assoc, true) }
      for (var i = this.from; i < this.to; i++)
        { pos = this.maps[i].map(pos, assoc); }
      return pos
    };

    // : (number, ?number) → MapResult
    // Map a position through this mapping, returning a mapping
    // result.
    Mapping.prototype.mapResult = function mapResult (pos, assoc) {
      if ( assoc === void 0 ) assoc = 1;
     return this._map(pos, assoc, false) };

    Mapping.prototype._map = function _map (pos, assoc, simple) {
      var deleted = false;

      for (var i = this.from; i < this.to; i++) {
        var map = this.maps[i], result = map.mapResult(pos, assoc);
        if (result.recover != null) {
          var corr = this.getMirror(i);
          if (corr != null && corr > i && corr < this.to) {
            i = corr;
            pos = this.maps[corr].recover(result.recover);
            continue
          }
        }

        if (result.deleted) { deleted = true; }
        pos = result.pos;
      }

      return simple ? pos : new MapResult(pos, deleted)
    };

    function TransformError(message) {
      var err = Error.call(this, message);
      err.__proto__ = TransformError.prototype;
      return err
    }

    TransformError.prototype = Object.create(Error.prototype);
    TransformError.prototype.constructor = TransformError;
    TransformError.prototype.name = "TransformError";

    // ::- Abstraction to build up and track an array of
    // [steps](#transform.Step) representing a document transformation.
    //
    // Most transforming methods return the `Transform` object itself, so
    // that they can be chained.
    var Transform = function Transform(doc) {
      // :: Node
      // The current document (the result of applying the steps in the
      // transform).
      this.doc = doc;
      // :: [Step]
      // The steps in this transform.
      this.steps = [];
      // :: [Node]
      // The documents before each of the steps.
      this.docs = [];
      // :: Mapping
      // A mapping with the maps for each of the steps in this transform.
      this.mapping = new Mapping;
    };

    var prototypeAccessors$7 = { before: { configurable: true },docChanged: { configurable: true } };

    // :: Node The starting document.
    prototypeAccessors$7.before.get = function () { return this.docs.length ? this.docs[0] : this.doc };

    // :: (step: Step) → this
    // Apply a new step in this transform, saving the result. Throws an
    // error when the step fails.
    Transform.prototype.step = function step (object) {
      var result = this.maybeStep(object);
      if (result.failed) { throw new TransformError(result.failed) }
      return this
    };

    // :: (Step) → StepResult
    // Try to apply a step in this transformation, ignoring it if it
    // fails. Returns the step result.
    Transform.prototype.maybeStep = function maybeStep (step) {
      var result = step.apply(this.doc);
      if (!result.failed) { this.addStep(step, result.doc); }
      return result
    };

    // :: bool
    // True when the document has been changed (when there are any
    // steps).
    prototypeAccessors$7.docChanged.get = function () {
      return this.steps.length > 0
    };

    Transform.prototype.addStep = function addStep (step, doc) {
      this.docs.push(this.doc);
      this.steps.push(step);
      this.mapping.appendMap(step.getMap());
      this.doc = doc;
    };

    Object.defineProperties( Transform.prototype, prototypeAccessors$7 );

    function mustOverride() { throw new Error("Override me") }

    var stepsByID = Object.create(null);

    // ::- A step object represents an atomic change. It generally applies
    // only to the document it was created for, since the positions
    // stored in it will only make sense for that document.
    //
    // New steps are defined by creating classes that extend `Step`,
    // overriding the `apply`, `invert`, `map`, `getMap` and `fromJSON`
    // methods, and registering your class with a unique
    // JSON-serialization identifier using
    // [`Step.jsonID`](#transform.Step^jsonID).
    var Step = function Step () {};

    Step.prototype.apply = function apply (_doc) { return mustOverride() };

    // :: () → StepMap
    // Get the step map that represents the changes made by this step,
    // and which can be used to transform between positions in the old
    // and the new document.
    Step.prototype.getMap = function getMap () { return StepMap.empty };

    // :: (doc: Node) → Step
    // Create an inverted version of this step. Needs the document as it
    // was before the step as argument.
    Step.prototype.invert = function invert (_doc) { return mustOverride() };

    // :: (mapping: Mappable) → ?Step
    // Map this step through a mappable thing, returning either a
    // version of that step with its positions adjusted, or `null` if
    // the step was entirely deleted by the mapping.
    Step.prototype.map = function map (_mapping) { return mustOverride() };

    // :: (other: Step) → ?Step
    // Try to merge this step with another one, to be applied directly
    // after it. Returns the merged step when possible, null if the
    // steps can't be merged.
    Step.prototype.merge = function merge (_other) { return null };

    // :: () → Object
    // Create a JSON-serializeable representation of this step. When
    // defining this for a custom subclass, make sure the result object
    // includes the step type's [JSON id](#transform.Step^jsonID) under
    // the `stepType` property.
    Step.prototype.toJSON = function toJSON () { return mustOverride() };

    // :: (Schema, Object) → Step
    // Deserialize a step from its JSON representation. Will call
    // through to the step class' own implementation of this method.
    Step.fromJSON = function fromJSON (schema, json) {
      if (!json || !json.stepType) { throw new RangeError("Invalid input for Step.fromJSON") }
      var type = stepsByID[json.stepType];
      if (!type) { throw new RangeError(("No step type " + (json.stepType) + " defined")) }
      return type.fromJSON(schema, json)
    };

    // :: (string, constructor<Step>)
    // To be able to serialize steps to JSON, each step needs a string
    // ID to attach to its JSON representation. Use this method to
    // register an ID for your step classes. Try to pick something
    // that's unlikely to clash with steps from other modules.
    Step.jsonID = function jsonID (id, stepClass) {
      if (id in stepsByID) { throw new RangeError("Duplicate use of step JSON ID " + id) }
      stepsByID[id] = stepClass;
      stepClass.prototype.jsonID = id;
      return stepClass
    };

    // ::- The result of [applying](#transform.Step.apply) a step. Contains either a
    // new document or a failure value.
    var StepResult = function StepResult(doc, failed) {
      // :: ?Node The transformed document.
      this.doc = doc;
      // :: ?string Text providing information about a failed step.
      this.failed = failed;
    };

    // :: (Node) → StepResult
    // Create a successful step result.
    StepResult.ok = function ok (doc) { return new StepResult(doc, null) };

    // :: (string) → StepResult
    // Create a failed step result.
    StepResult.fail = function fail (message) { return new StepResult(null, message) };

    // :: (Node, number, number, Slice) → StepResult
    // Call [`Node.replace`](#model.Node.replace) with the given
    // arguments. Create a successful result if it succeeds, and a
    // failed one if it throws a `ReplaceError`.
    StepResult.fromReplace = function fromReplace (doc, from, to, slice) {
      try {
        return StepResult.ok(doc.replace(from, to, slice))
      } catch (e) {
        if (e instanceof ReplaceError) { return StepResult.fail(e.message) }
        throw e
      }
    };

    // ::- Replace a part of the document with a slice of new content.
    var ReplaceStep = /*@__PURE__*/(function (Step) {
      function ReplaceStep(from, to, slice, structure) {
        Step.call(this);
        this.from = from;
        this.to = to;
        this.slice = slice;
        this.structure = !!structure;
      }

      if ( Step ) ReplaceStep.__proto__ = Step;
      ReplaceStep.prototype = Object.create( Step && Step.prototype );
      ReplaceStep.prototype.constructor = ReplaceStep;

      ReplaceStep.prototype.apply = function apply (doc) {
        if (this.structure && contentBetween(doc, this.from, this.to))
          { return StepResult.fail("Structure replace would overwrite content") }
        return StepResult.fromReplace(doc, this.from, this.to, this.slice)
      };

      ReplaceStep.prototype.getMap = function getMap () {
        return new StepMap([this.from, this.to - this.from, this.slice.size])
      };

      ReplaceStep.prototype.invert = function invert (doc) {
        return new ReplaceStep(this.from, this.from + this.slice.size, doc.slice(this.from, this.to))
      };

      ReplaceStep.prototype.map = function map (mapping) {
        var from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
        if (from.deleted && to.deleted) { return null }
        return new ReplaceStep(from.pos, Math.max(from.pos, to.pos), this.slice)
      };

      ReplaceStep.prototype.merge = function merge (other) {
        if (!(other instanceof ReplaceStep) || other.structure != this.structure) { return null }

        if (this.from + this.slice.size == other.from && !this.slice.openEnd && !other.slice.openStart) {
          var slice = this.slice.size + other.slice.size == 0 ? Slice.empty
              : new Slice(this.slice.content.append(other.slice.content), this.slice.openStart, other.slice.openEnd);
          return new ReplaceStep(this.from, this.to + (other.to - other.from), slice, this.structure)
        } else if (other.to == this.from && !this.slice.openStart && !other.slice.openEnd) {
          var slice$1 = this.slice.size + other.slice.size == 0 ? Slice.empty
              : new Slice(other.slice.content.append(this.slice.content), other.slice.openStart, this.slice.openEnd);
          return new ReplaceStep(other.from, this.to, slice$1, this.structure)
        } else {
          return null
        }
      };

      ReplaceStep.prototype.toJSON = function toJSON () {
        var json = {stepType: "replace", from: this.from, to: this.to};
        if (this.slice.size) { json.slice = this.slice.toJSON(); }
        if (this.structure) { json.structure = true; }
        return json
      };

      ReplaceStep.fromJSON = function fromJSON (schema, json) {
        if (typeof json.from != "number" || typeof json.to != "number")
          { throw new RangeError("Invalid input for ReplaceStep.fromJSON") }
        return new ReplaceStep(json.from, json.to, Slice.fromJSON(schema, json.slice), !!json.structure)
      };

      return ReplaceStep;
    }(Step));

    Step.jsonID("replace", ReplaceStep);

    // ::- Replace a part of the document with a slice of content, but
    // preserve a range of the replaced content by moving it into the
    // slice.
    var ReplaceAroundStep = /*@__PURE__*/(function (Step) {
      function ReplaceAroundStep(from, to, gapFrom, gapTo, slice, insert, structure) {
        Step.call(this);
        this.from = from;
        this.to = to;
        this.gapFrom = gapFrom;
        this.gapTo = gapTo;
        this.slice = slice;
        this.insert = insert;
        this.structure = !!structure;
      }

      if ( Step ) ReplaceAroundStep.__proto__ = Step;
      ReplaceAroundStep.prototype = Object.create( Step && Step.prototype );
      ReplaceAroundStep.prototype.constructor = ReplaceAroundStep;

      ReplaceAroundStep.prototype.apply = function apply (doc) {
        if (this.structure && (contentBetween(doc, this.from, this.gapFrom) ||
                               contentBetween(doc, this.gapTo, this.to)))
          { return StepResult.fail("Structure gap-replace would overwrite content") }

        var gap = doc.slice(this.gapFrom, this.gapTo);
        if (gap.openStart || gap.openEnd)
          { return StepResult.fail("Gap is not a flat range") }
        var inserted = this.slice.insertAt(this.insert, gap.content);
        if (!inserted) { return StepResult.fail("Content does not fit in gap") }
        return StepResult.fromReplace(doc, this.from, this.to, inserted)
      };

      ReplaceAroundStep.prototype.getMap = function getMap () {
        return new StepMap([this.from, this.gapFrom - this.from, this.insert,
                            this.gapTo, this.to - this.gapTo, this.slice.size - this.insert])
      };

      ReplaceAroundStep.prototype.invert = function invert (doc) {
        var gap = this.gapTo - this.gapFrom;
        return new ReplaceAroundStep(this.from, this.from + this.slice.size + gap,
                                     this.from + this.insert, this.from + this.insert + gap,
                                     doc.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from),
                                     this.gapFrom - this.from, this.structure)
      };

      ReplaceAroundStep.prototype.map = function map (mapping) {
        var from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
        var gapFrom = mapping.map(this.gapFrom, -1), gapTo = mapping.map(this.gapTo, 1);
        if ((from.deleted && to.deleted) || gapFrom < from.pos || gapTo > to.pos) { return null }
        return new ReplaceAroundStep(from.pos, to.pos, gapFrom, gapTo, this.slice, this.insert, this.structure)
      };

      ReplaceAroundStep.prototype.toJSON = function toJSON () {
        var json = {stepType: "replaceAround", from: this.from, to: this.to,
                    gapFrom: this.gapFrom, gapTo: this.gapTo, insert: this.insert};
        if (this.slice.size) { json.slice = this.slice.toJSON(); }
        if (this.structure) { json.structure = true; }
        return json
      };

      ReplaceAroundStep.fromJSON = function fromJSON (schema, json) {
        if (typeof json.from != "number" || typeof json.to != "number" ||
            typeof json.gapFrom != "number" || typeof json.gapTo != "number" || typeof json.insert != "number")
          { throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON") }
        return new ReplaceAroundStep(json.from, json.to, json.gapFrom, json.gapTo,
                                     Slice.fromJSON(schema, json.slice), json.insert, !!json.structure)
      };

      return ReplaceAroundStep;
    }(Step));

    Step.jsonID("replaceAround", ReplaceAroundStep);

    function contentBetween(doc, from, to) {
      var $from = doc.resolve(from), dist = to - from, depth = $from.depth;
      while (dist > 0 && depth > 0 && $from.indexAfter(depth) == $from.node(depth).childCount) {
        depth--;
        dist--;
      }
      if (dist > 0) {
        var next = $from.node(depth).maybeChild($from.indexAfter(depth));
        while (dist > 0) {
          if (!next || next.isLeaf) { return true }
          next = next.firstChild;
          dist--;
        }
      }
      return false
    }

    function canCut(node, start, end) {
      return (start == 0 || node.canReplace(start, node.childCount)) &&
        (end == node.childCount || node.canReplace(0, end))
    }

    // :: (NodeRange) → ?number
    // Try to find a target depth to which the content in the given range
    // can be lifted. Will not go across
    // [isolating](#model.NodeSpec.isolating) parent nodes.
    function liftTarget(range) {
      var parent = range.parent;
      var content = parent.content.cutByIndex(range.startIndex, range.endIndex);
      for (var depth = range.depth;; --depth) {
        var node = range.$from.node(depth);
        var index = range.$from.index(depth), endIndex = range.$to.indexAfter(depth);
        if (depth < range.depth && node.canReplace(index, endIndex, content))
          { return depth }
        if (depth == 0 || node.type.spec.isolating || !canCut(node, index, endIndex)) { break }
      }
    }

    // :: (NodeRange, number) → this
    // Split the content in the given range off from its parent, if there
    // is sibling content before or after it, and move it up the tree to
    // the depth specified by `target`. You'll probably want to use
    // [`liftTarget`](#transform.liftTarget) to compute `target`, to make
    // sure the lift is valid.
    Transform.prototype.lift = function(range, target) {
      var $from = range.$from;
      var $to = range.$to;
      var depth = range.depth;

      var gapStart = $from.before(depth + 1), gapEnd = $to.after(depth + 1);
      var start = gapStart, end = gapEnd;

      var before = Fragment.empty, openStart = 0;
      for (var d = depth, splitting = false; d > target; d--)
        { if (splitting || $from.index(d) > 0) {
          splitting = true;
          before = Fragment.from($from.node(d).copy(before));
          openStart++;
        } else {
          start--;
        } }
      var after = Fragment.empty, openEnd = 0;
      for (var d$1 = depth, splitting$1 = false; d$1 > target; d$1--)
        { if (splitting$1 || $to.after(d$1 + 1) < $to.end(d$1)) {
          splitting$1 = true;
          after = Fragment.from($to.node(d$1).copy(after));
          openEnd++;
        } else {
          end++;
        } }

      return this.step(new ReplaceAroundStep(start, end, gapStart, gapEnd,
                                             new Slice(before.append(after), openStart, openEnd),
                                             before.size - openStart, true))
    };

    // :: (NodeRange, NodeType, ?Object, ?NodeRange) → ?[{type: NodeType, attrs: ?Object}]
    // Try to find a valid way to wrap the content in the given range in a
    // node of the given type. May introduce extra nodes around and inside
    // the wrapper node, if necessary. Returns null if no valid wrapping
    // could be found. When `innerRange` is given, that range's content is
    // used as the content to fit into the wrapping, instead of the
    // content of `range`.
    function findWrapping(range, nodeType, attrs, innerRange) {
      if ( innerRange === void 0 ) innerRange = range;

      var around = findWrappingOutside(range, nodeType);
      var inner = around && findWrappingInside(innerRange, nodeType);
      if (!inner) { return null }
      return around.map(withAttrs).concat({type: nodeType, attrs: attrs}).concat(inner.map(withAttrs))
    }

    function withAttrs(type) { return {type: type, attrs: null} }

    function findWrappingOutside(range, type) {
      var parent = range.parent;
      var startIndex = range.startIndex;
      var endIndex = range.endIndex;
      var around = parent.contentMatchAt(startIndex).findWrapping(type);
      if (!around) { return null }
      var outer = around.length ? around[0] : type;
      return parent.canReplaceWith(startIndex, endIndex, outer) ? around : null
    }

    function findWrappingInside(range, type) {
      var parent = range.parent;
      var startIndex = range.startIndex;
      var endIndex = range.endIndex;
      var inner = parent.child(startIndex);
      var inside = type.contentMatch.findWrapping(inner.type);
      if (!inside) { return null }
      var lastType = inside.length ? inside[inside.length - 1] : type;
      var innerMatch = lastType.contentMatch;
      for (var i = startIndex; innerMatch && i < endIndex; i++)
        { innerMatch = innerMatch.matchType(parent.child(i).type); }
      if (!innerMatch || !innerMatch.validEnd) { return null }
      return inside
    }

    // :: (NodeRange, [{type: NodeType, attrs: ?Object}]) → this
    // Wrap the given [range](#model.NodeRange) in the given set of wrappers.
    // The wrappers are assumed to be valid in this position, and should
    // probably be computed with [`findWrapping`](#transform.findWrapping).
    Transform.prototype.wrap = function(range, wrappers) {
      var content = Fragment.empty;
      for (var i = wrappers.length - 1; i >= 0; i--)
        { content = Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content)); }

      var start = range.start, end = range.end;
      return this.step(new ReplaceAroundStep(start, end, start, end, new Slice(content, 0, 0), wrappers.length, true))
    };

    // :: (number, ?number, NodeType, ?Object) → this
    // Set the type of all textblocks (partly) between `from` and `to` to
    // the given node type with the given attributes.
    Transform.prototype.setBlockType = function(from, to, type, attrs) {
      var this$1 = this;
      if ( to === void 0 ) to = from;

      if (!type.isTextblock) { throw new RangeError("Type given to setBlockType should be a textblock") }
      var mapFrom = this.steps.length;
      this.doc.nodesBetween(from, to, function (node, pos) {
        if (node.isTextblock && !node.hasMarkup(type, attrs) && canChangeType(this$1.doc, this$1.mapping.slice(mapFrom).map(pos), type)) {
          // Ensure all markup that isn't allowed in the new node type is cleared
          this$1.clearIncompatible(this$1.mapping.slice(mapFrom).map(pos, 1), type);
          var mapping = this$1.mapping.slice(mapFrom);
          var startM = mapping.map(pos, 1), endM = mapping.map(pos + node.nodeSize, 1);
          this$1.step(new ReplaceAroundStep(startM, endM, startM + 1, endM - 1,
                                          new Slice(Fragment.from(type.create(attrs, null, node.marks)), 0, 0), 1, true));
          return false
        }
      });
      return this
    };

    function canChangeType(doc, pos, type) {
      var $pos = doc.resolve(pos), index = $pos.index();
      return $pos.parent.canReplaceWith(index, index + 1, type)
    }

    // :: (number, ?NodeType, ?Object, ?[Mark]) → this
    // Change the type, attributes, and/or marks of the node at `pos`.
    // When `type` isn't given, the existing node type is preserved,
    Transform.prototype.setNodeMarkup = function(pos, type, attrs, marks) {
      var node = this.doc.nodeAt(pos);
      if (!node) { throw new RangeError("No node at given position") }
      if (!type) { type = node.type; }
      var newNode = type.create(attrs, null, marks || node.marks);
      if (node.isLeaf)
        { return this.replaceWith(pos, pos + node.nodeSize, newNode) }

      if (!type.validContent(node.content))
        { throw new RangeError("Invalid content for node type " + type.name) }

      return this.step(new ReplaceAroundStep(pos, pos + node.nodeSize, pos + 1, pos + node.nodeSize - 1,
                                             new Slice(Fragment.from(newNode), 0, 0), 1, true))
    };

    // :: (Node, number, number, ?[?{type: NodeType, attrs: ?Object}]) → bool
    // Check whether splitting at the given position is allowed.
    function canSplit(doc, pos, depth, typesAfter) {
      if ( depth === void 0 ) depth = 1;

      var $pos = doc.resolve(pos), base = $pos.depth - depth;
      var innerType = (typesAfter && typesAfter[typesAfter.length - 1]) || $pos.parent;
      if (base < 0 || $pos.parent.type.spec.isolating ||
          !$pos.parent.canReplace($pos.index(), $pos.parent.childCount) ||
          !innerType.type.validContent($pos.parent.content.cutByIndex($pos.index(), $pos.parent.childCount)))
        { return false }
      for (var d = $pos.depth - 1, i = depth - 2; d > base; d--, i--) {
        var node = $pos.node(d), index$1 = $pos.index(d);
        if (node.type.spec.isolating) { return false }
        var rest = node.content.cutByIndex(index$1, node.childCount);
        var after = (typesAfter && typesAfter[i]) || node;
        if (after != node) { rest = rest.replaceChild(0, after.type.create(after.attrs)); }
        if (!node.canReplace(index$1 + 1, node.childCount) || !after.type.validContent(rest))
          { return false }
      }
      var index = $pos.indexAfter(base);
      var baseType = typesAfter && typesAfter[0];
      return $pos.node(base).canReplaceWith(index, index, baseType ? baseType.type : $pos.node(base + 1).type)
    }

    // :: (number, ?number, ?[?{type: NodeType, attrs: ?Object}]) → this
    // Split the node at the given position, and optionally, if `depth` is
    // greater than one, any number of nodes above that. By default, the
    // parts split off will inherit the node type of the original node.
    // This can be changed by passing an array of types and attributes to
    // use after the split.
    Transform.prototype.split = function(pos, depth, typesAfter) {
      if ( depth === void 0 ) depth = 1;

      var $pos = this.doc.resolve(pos), before = Fragment.empty, after = Fragment.empty;
      for (var d = $pos.depth, e = $pos.depth - depth, i = depth - 1; d > e; d--, i--) {
        before = Fragment.from($pos.node(d).copy(before));
        var typeAfter = typesAfter && typesAfter[i];
        after = Fragment.from(typeAfter ? typeAfter.type.create(typeAfter.attrs, after) : $pos.node(d).copy(after));
      }
      return this.step(new ReplaceStep(pos, pos, new Slice(before.append(after), depth, depth), true))
    };

    // :: (Node, number) → bool
    // Test whether the blocks before and after a given position can be
    // joined.
    function canJoin(doc, pos) {
      var $pos = doc.resolve(pos), index = $pos.index();
      return joinable$1($pos.nodeBefore, $pos.nodeAfter) &&
        $pos.parent.canReplace(index, index + 1)
    }

    function joinable$1(a, b) {
      return a && b && !a.isLeaf && a.canAppend(b)
    }

    // :: (Node, number, ?number) → ?number
    // Find an ancestor of the given position that can be joined to the
    // block before (or after if `dir` is positive). Returns the joinable
    // point, if any.
    function joinPoint(doc, pos, dir) {
      if ( dir === void 0 ) dir = -1;

      var $pos = doc.resolve(pos);
      for (var d = $pos.depth;; d--) {
        var before = (void 0), after = (void 0), index = $pos.index(d);
        if (d == $pos.depth) {
          before = $pos.nodeBefore;
          after = $pos.nodeAfter;
        } else if (dir > 0) {
          before = $pos.node(d + 1);
          index++;
          after = $pos.node(d).maybeChild(index);
        } else {
          before = $pos.node(d).maybeChild(index - 1);
          after = $pos.node(d + 1);
        }
        if (before && !before.isTextblock && joinable$1(before, after) &&
            $pos.node(d).canReplace(index, index + 1)) { return pos }
        if (d == 0) { break }
        pos = dir < 0 ? $pos.before(d) : $pos.after(d);
      }
    }

    // :: (number, ?number) → this
    // Join the blocks around the given position. If depth is 2, their
    // last and first siblings are also joined, and so on.
    Transform.prototype.join = function(pos, depth) {
      if ( depth === void 0 ) depth = 1;

      var step = new ReplaceStep(pos - depth, pos + depth, Slice.empty, true);
      return this.step(step)
    };

    // :: (Node, number, NodeType) → ?number
    // Try to find a point where a node of the given type can be inserted
    // near `pos`, by searching up the node hierarchy when `pos` itself
    // isn't a valid place but is at the start or end of a node. Return
    // null if no position was found.
    function insertPoint(doc, pos, nodeType) {
      var $pos = doc.resolve(pos);
      if ($pos.parent.canReplaceWith($pos.index(), $pos.index(), nodeType)) { return pos }

      if ($pos.parentOffset == 0)
        { for (var d = $pos.depth - 1; d >= 0; d--) {
          var index = $pos.index(d);
          if ($pos.node(d).canReplaceWith(index, index, nodeType)) { return $pos.before(d + 1) }
          if (index > 0) { return null }
        } }
      if ($pos.parentOffset == $pos.parent.content.size)
        { for (var d$1 = $pos.depth - 1; d$1 >= 0; d$1--) {
          var index$1 = $pos.indexAfter(d$1);
          if ($pos.node(d$1).canReplaceWith(index$1, index$1, nodeType)) { return $pos.after(d$1 + 1) }
          if (index$1 < $pos.node(d$1).childCount) { return null }
        } }
    }

    // :: (Node, number, Slice) → ?number
    // Finds a position at or around the given position where the given
    // slice can be inserted. Will look at parent nodes' nearest boundary
    // and try there, even if the original position wasn't directly at the
    // start or end of that node. Returns null when no position was found.
    function dropPoint(doc, pos, slice) {
      var $pos = doc.resolve(pos);
      if (!slice.content.size) { return pos }
      var content = slice.content;
      for (var i = 0; i < slice.openStart; i++) { content = content.firstChild.content; }
      for (var pass = 1; pass <= (slice.openStart == 0 && slice.size ? 2 : 1); pass++) {
        for (var d = $pos.depth; d >= 0; d--) {
          var bias = d == $pos.depth ? 0 : $pos.pos <= ($pos.start(d + 1) + $pos.end(d + 1)) / 2 ? -1 : 1;
          var insertPos = $pos.index(d) + (bias > 0 ? 1 : 0);
          if (pass == 1
              ? $pos.node(d).canReplace(insertPos, insertPos, content)
              : $pos.node(d).contentMatchAt(insertPos).findWrapping(content.firstChild.type))
            { return bias == 0 ? $pos.pos : bias < 0 ? $pos.before(d + 1) : $pos.after(d + 1) }
        }
      }
      return null
    }

    function mapFragment(fragment, f, parent) {
      var mapped = [];
      for (var i = 0; i < fragment.childCount; i++) {
        var child = fragment.child(i);
        if (child.content.size) { child = child.copy(mapFragment(child.content, f, child)); }
        if (child.isInline) { child = f(child, parent, i); }
        mapped.push(child);
      }
      return Fragment.fromArray(mapped)
    }

    // ::- Add a mark to all inline content between two positions.
    var AddMarkStep = /*@__PURE__*/(function (Step) {
      function AddMarkStep(from, to, mark) {
        Step.call(this);
        this.from = from;
        this.to = to;
        this.mark = mark;
      }

      if ( Step ) AddMarkStep.__proto__ = Step;
      AddMarkStep.prototype = Object.create( Step && Step.prototype );
      AddMarkStep.prototype.constructor = AddMarkStep;

      AddMarkStep.prototype.apply = function apply (doc) {
        var this$1 = this;

        var oldSlice = doc.slice(this.from, this.to), $from = doc.resolve(this.from);
        var parent = $from.node($from.sharedDepth(this.to));
        var slice = new Slice(mapFragment(oldSlice.content, function (node, parent) {
          if (!node.isAtom || !parent.type.allowsMarkType(this$1.mark.type)) { return node }
          return node.mark(this$1.mark.addToSet(node.marks))
        }, parent), oldSlice.openStart, oldSlice.openEnd);
        return StepResult.fromReplace(doc, this.from, this.to, slice)
      };

      AddMarkStep.prototype.invert = function invert () {
        return new RemoveMarkStep(this.from, this.to, this.mark)
      };

      AddMarkStep.prototype.map = function map (mapping) {
        var from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
        if (from.deleted && to.deleted || from.pos >= to.pos) { return null }
        return new AddMarkStep(from.pos, to.pos, this.mark)
      };

      AddMarkStep.prototype.merge = function merge (other) {
        if (other instanceof AddMarkStep &&
            other.mark.eq(this.mark) &&
            this.from <= other.to && this.to >= other.from)
          { return new AddMarkStep(Math.min(this.from, other.from),
                                 Math.max(this.to, other.to), this.mark) }
      };

      AddMarkStep.prototype.toJSON = function toJSON () {
        return {stepType: "addMark", mark: this.mark.toJSON(),
                from: this.from, to: this.to}
      };

      AddMarkStep.fromJSON = function fromJSON (schema, json) {
        if (typeof json.from != "number" || typeof json.to != "number")
          { throw new RangeError("Invalid input for AddMarkStep.fromJSON") }
        return new AddMarkStep(json.from, json.to, schema.markFromJSON(json.mark))
      };

      return AddMarkStep;
    }(Step));

    Step.jsonID("addMark", AddMarkStep);

    // ::- Remove a mark from all inline content between two positions.
    var RemoveMarkStep = /*@__PURE__*/(function (Step) {
      function RemoveMarkStep(from, to, mark) {
        Step.call(this);
        this.from = from;
        this.to = to;
        this.mark = mark;
      }

      if ( Step ) RemoveMarkStep.__proto__ = Step;
      RemoveMarkStep.prototype = Object.create( Step && Step.prototype );
      RemoveMarkStep.prototype.constructor = RemoveMarkStep;

      RemoveMarkStep.prototype.apply = function apply (doc) {
        var this$1 = this;

        var oldSlice = doc.slice(this.from, this.to);
        var slice = new Slice(mapFragment(oldSlice.content, function (node) {
          return node.mark(this$1.mark.removeFromSet(node.marks))
        }), oldSlice.openStart, oldSlice.openEnd);
        return StepResult.fromReplace(doc, this.from, this.to, slice)
      };

      RemoveMarkStep.prototype.invert = function invert () {
        return new AddMarkStep(this.from, this.to, this.mark)
      };

      RemoveMarkStep.prototype.map = function map (mapping) {
        var from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
        if (from.deleted && to.deleted || from.pos >= to.pos) { return null }
        return new RemoveMarkStep(from.pos, to.pos, this.mark)
      };

      RemoveMarkStep.prototype.merge = function merge (other) {
        if (other instanceof RemoveMarkStep &&
            other.mark.eq(this.mark) &&
            this.from <= other.to && this.to >= other.from)
          { return new RemoveMarkStep(Math.min(this.from, other.from),
                                    Math.max(this.to, other.to), this.mark) }
      };

      RemoveMarkStep.prototype.toJSON = function toJSON () {
        return {stepType: "removeMark", mark: this.mark.toJSON(),
                from: this.from, to: this.to}
      };

      RemoveMarkStep.fromJSON = function fromJSON (schema, json) {
        if (typeof json.from != "number" || typeof json.to != "number")
          { throw new RangeError("Invalid input for RemoveMarkStep.fromJSON") }
        return new RemoveMarkStep(json.from, json.to, schema.markFromJSON(json.mark))
      };

      return RemoveMarkStep;
    }(Step));

    Step.jsonID("removeMark", RemoveMarkStep);

    // :: (number, number, Mark) → this
    // Add the given mark to the inline content between `from` and `to`.
    Transform.prototype.addMark = function(from, to, mark) {
      var this$1 = this;

      var removed = [], added = [], removing = null, adding = null;
      this.doc.nodesBetween(from, to, function (node, pos, parent) {
        if (!node.isInline) { return }
        var marks = node.marks;
        if (!mark.isInSet(marks) && parent.type.allowsMarkType(mark.type)) {
          var start = Math.max(pos, from), end = Math.min(pos + node.nodeSize, to);
          var newSet = mark.addToSet(marks);

          for (var i = 0; i < marks.length; i++) {
            if (!marks[i].isInSet(newSet)) {
              if (removing && removing.to == start && removing.mark.eq(marks[i]))
                { removing.to = end; }
              else
                { removed.push(removing = new RemoveMarkStep(start, end, marks[i])); }
            }
          }

          if (adding && adding.to == start)
            { adding.to = end; }
          else
            { added.push(adding = new AddMarkStep(start, end, mark)); }
        }
      });

      removed.forEach(function (s) { return this$1.step(s); });
      added.forEach(function (s) { return this$1.step(s); });
      return this
    };

    // :: (number, number, ?union<Mark, MarkType>) → this
    // Remove marks from inline nodes between `from` and `to`. When `mark`
    // is a single mark, remove precisely that mark. When it is a mark type,
    // remove all marks of that type. When it is null, remove all marks of
    // any type.
    Transform.prototype.removeMark = function(from, to, mark) {
      var this$1 = this;
      if ( mark === void 0 ) mark = null;

      var matched = [], step = 0;
      this.doc.nodesBetween(from, to, function (node, pos) {
        if (!node.isInline) { return }
        step++;
        var toRemove = null;
        if (mark instanceof MarkType) {
          var set = node.marks, found;
          while (found = mark.isInSet(set)) {
    (toRemove || (toRemove = [])).push(found);
            set = found.removeFromSet(set);
          }
        } else if (mark) {
          if (mark.isInSet(node.marks)) { toRemove = [mark]; }
        } else {
          toRemove = node.marks;
        }
        if (toRemove && toRemove.length) {
          var end = Math.min(pos + node.nodeSize, to);
          for (var i = 0; i < toRemove.length; i++) {
            var style = toRemove[i], found$1 = (void 0);
            for (var j = 0; j < matched.length; j++) {
              var m = matched[j];
              if (m.step == step - 1 && style.eq(matched[j].style)) { found$1 = m; }
            }
            if (found$1) {
              found$1.to = end;
              found$1.step = step;
            } else {
              matched.push({style: style, from: Math.max(pos, from), to: end, step: step});
            }
          }
        }
      });
      matched.forEach(function (m) { return this$1.step(new RemoveMarkStep(m.from, m.to, m.style)); });
      return this
    };

    // :: (number, NodeType, ?ContentMatch) → this
    // Removes all marks and nodes from the content of the node at `pos`
    // that don't match the given new parent node type. Accepts an
    // optional starting [content match](#model.ContentMatch) as third
    // argument.
    Transform.prototype.clearIncompatible = function(pos, parentType, match) {
      if ( match === void 0 ) match = parentType.contentMatch;

      var node = this.doc.nodeAt(pos);
      var delSteps = [], cur = pos + 1;
      for (var i = 0; i < node.childCount; i++) {
        var child = node.child(i), end = cur + child.nodeSize;
        var allowed = match.matchType(child.type, child.attrs);
        if (!allowed) {
          delSteps.push(new ReplaceStep(cur, end, Slice.empty));
        } else {
          match = allowed;
          for (var j = 0; j < child.marks.length; j++) { if (!parentType.allowsMarkType(child.marks[j].type))
            { this.step(new RemoveMarkStep(cur, end, child.marks[j])); } }
        }
        cur = end;
      }
      if (!match.validEnd) {
        var fill = match.fillBefore(Fragment.empty, true);
        this.replace(cur, cur, new Slice(fill, 0, 0));
      }
      for (var i$1 = delSteps.length - 1; i$1 >= 0; i$1--) { this.step(delSteps[i$1]); }
      return this
    };

    // :: (Node, number, ?number, ?Slice) → ?Step
    // ‘Fit’ a slice into a given position in the document, producing a
    // [step](#transform.Step) that inserts it. Will return null if
    // there's no meaningful way to insert the slice here, or inserting it
    // would be a no-op (an empty slice over an empty range).
    function replaceStep(doc, from, to, slice) {
      if ( to === void 0 ) to = from;
      if ( slice === void 0 ) slice = Slice.empty;

      if (from == to && !slice.size) { return null }

      var $from = doc.resolve(from), $to = doc.resolve(to);
      // Optimization -- avoid work if it's obvious that it's not needed.
      if (fitsTrivially($from, $to, slice)) { return new ReplaceStep(from, to, slice) }
      return new Fitter($from, $to, slice).fit()
    }

    // :: (number, ?number, ?Slice) → this
    // Replace the part of the document between `from` and `to` with the
    // given `slice`.
    Transform.prototype.replace = function(from, to, slice) {
      if ( to === void 0 ) to = from;
      if ( slice === void 0 ) slice = Slice.empty;

      var step = replaceStep(this.doc, from, to, slice);
      if (step) { this.step(step); }
      return this
    };

    // :: (number, number, union<Fragment, Node, [Node]>) → this
    // Replace the given range with the given content, which may be a
    // fragment, node, or array of nodes.
    Transform.prototype.replaceWith = function(from, to, content) {
      return this.replace(from, to, new Slice(Fragment.from(content), 0, 0))
    };

    // :: (number, number) → this
    // Delete the content between the given positions.
    Transform.prototype.delete = function(from, to) {
      return this.replace(from, to, Slice.empty)
    };

    // :: (number, union<Fragment, Node, [Node]>) → this
    // Insert the given content at the given position.
    Transform.prototype.insert = function(pos, content) {
      return this.replaceWith(pos, pos, content)
    };

    function fitsTrivially($from, $to, slice) {
      return !slice.openStart && !slice.openEnd && $from.start() == $to.start() &&
        $from.parent.canReplace($from.index(), $to.index(), slice.content)
    }

    // Algorithm for 'placing' the elements of a slice into a gap:
    //
    // We consider the content of each node that is open to the left to be
    // independently placeable. I.e. in <p("foo"), p("bar")>, when the
    // paragraph on the left is open, "foo" can be placed (somewhere on
    // the left side of the replacement gap) independently from p("bar").
    //
    // This class tracks the state of the placement progress in the
    // following properties:
    //
    //  - `frontier` holds a stack of `{type, match}` objects that
    //    represent the open side of the replacement. It starts at
    //    `$from`, then moves forward as content is placed, and is finally
    //    reconciled with `$to`.
    //
    //  - `unplaced` is a slice that represents the content that hasn't
    //    been placed yet.
    //
    //  - `placed` is a fragment of placed content. Its open-start value
    //    is implicit in `$from`, and its open-end value in `frontier`.
    var Fitter = function Fitter($from, $to, slice) {
      this.$to = $to;
      this.$from = $from;
      this.unplaced = slice;

      this.frontier = [];
      for (var i = 0; i <= $from.depth; i++) {
        var node = $from.node(i);
        this.frontier.push({
          type: node.type,
          match: node.contentMatchAt($from.indexAfter(i))
        });
      }

      this.placed = Fragment.empty;
      for (var i$1 = $from.depth; i$1 > 0; i$1--)
        { this.placed = Fragment.from($from.node(i$1).copy(this.placed)); }
    };

    var prototypeAccessors$1$4 = { depth: { configurable: true } };

    prototypeAccessors$1$4.depth.get = function () { return this.frontier.length - 1 };

    Fitter.prototype.fit = function fit () {
      // As long as there's unplaced content, try to place some of it.
      // If that fails, either increase the open score of the unplaced
      // slice, or drop nodes from it, and then try again.
      while (this.unplaced.size) {
        var fit = this.findFittable();
        if (fit) { this.placeNodes(fit); }
        else { this.openMore() || this.dropNode(); }
      }
      // When there's inline content directly after the frontier _and_
      // directly after `this.$to`, we must generate a `ReplaceAround`
      // step that pulls that content into the node after the frontier.
      // That means the fitting must be done to the end of the textblock
      // node after `this.$to`, not `this.$to` itself.
      var moveInline = this.mustMoveInline(), placedSize = this.placed.size - this.depth - this.$from.depth;
      var $from = this.$from, $to = this.close(moveInline < 0 ? this.$to : $from.doc.resolve(moveInline));
      if (!$to) { return null }

      // If closing to `$to` succeeded, create a step
      var content = this.placed, openStart = $from.depth, openEnd = $to.depth;
      while (openStart && openEnd && content.childCount == 1) { // Normalize by dropping open parent nodes
        content = content.firstChild.content;
        openStart--; openEnd--;
      }
      var slice = new Slice(content, openStart, openEnd);
      if (moveInline > -1)
        { return new ReplaceAroundStep($from.pos, moveInline, this.$to.pos, this.$to.end(), slice, placedSize) }
      if (slice.size || $from.pos != this.$to.pos) // Don't generate no-op steps
        { return new ReplaceStep($from.pos, $to.pos, slice) }
    };

    // Find a position on the start spine of `this.unplaced` that has
    // content that can be moved somewhere on the frontier. Returns two
    // depths, one for the slice and one for the frontier.
    Fitter.prototype.findFittable = function findFittable () {
      // Only try wrapping nodes (pass 2) after finding a place without
      // wrapping failed.
      for (var pass = 1; pass <= 2; pass++) {
        for (var sliceDepth = this.unplaced.openStart; sliceDepth >= 0; sliceDepth--) {
          var fragment = (void 0), parent = (void 0);
          if (sliceDepth) {
            parent = contentAt(this.unplaced.content, sliceDepth - 1).firstChild;
            fragment = parent.content;
          } else {
            fragment = this.unplaced.content;
          }
          var first = fragment.firstChild;
          for (var frontierDepth = this.depth; frontierDepth >= 0; frontierDepth--) {
            var ref = this.frontier[frontierDepth];
              var type = ref.type;
              var match = ref.match;
              var wrap = (void 0), inject = (void 0);
            // In pass 1, if the next node matches, or there is no next
            // node but the parents look compatible, we've found a
            // place.
            if (pass == 1 && (first ? match.matchType(first.type) || (inject = match.fillBefore(Fragment.from(first), false))
                              : type.compatibleContent(parent.type)))
              { return {sliceDepth: sliceDepth, frontierDepth: frontierDepth, parent: parent, inject: inject} }
            // In pass 2, look for a set of wrapping nodes that make
            // `first` fit here.
            else if (pass == 2 && first && (wrap = match.findWrapping(first.type)))
              { return {sliceDepth: sliceDepth, frontierDepth: frontierDepth, parent: parent, wrap: wrap} }
            // Don't continue looking further up if the parent node
            // would fit here.
            if (parent && match.matchType(parent.type)) { break }
          }
        }
      }
    };

    Fitter.prototype.openMore = function openMore () {
      var ref = this.unplaced;
        var content = ref.content;
        var openStart = ref.openStart;
        var openEnd = ref.openEnd;
      var inner = contentAt(content, openStart);
      if (!inner.childCount || inner.firstChild.isLeaf) { return false }
      this.unplaced = new Slice(content, openStart + 1,
                                Math.max(openEnd, inner.size + openStart >= content.size - openEnd ? openStart + 1 : 0));
      return true
    };

    Fitter.prototype.dropNode = function dropNode () {
      var ref = this.unplaced;
        var content = ref.content;
        var openStart = ref.openStart;
        var openEnd = ref.openEnd;
      var inner = contentAt(content, openStart);
      if (inner.childCount <= 1 && openStart > 0) {
        var openAtEnd = content.size - openStart <= openStart + inner.size;
        this.unplaced = new Slice(dropFromFragment(content, openStart - 1, 1), openStart - 1,
                                  openAtEnd ? openStart - 1 : openEnd);
      } else {
        this.unplaced = new Slice(dropFromFragment(content, openStart, 1), openStart, openEnd);
      }
    };

    // : ({sliceDepth: number, frontierDepth: number, parent: ?Node, wrap: ?[NodeType], inject: ?Fragment})
    // Move content from the unplaced slice at `sliceDepth` to the
    // frontier node at `frontierDepth`. Close that frontier node when
    // applicable.
    Fitter.prototype.placeNodes = function placeNodes (ref) {
        var sliceDepth = ref.sliceDepth;
        var frontierDepth = ref.frontierDepth;
        var parent = ref.parent;
        var inject = ref.inject;
        var wrap = ref.wrap;

      while (this.depth > frontierDepth) { this.closeFrontierNode(); }
      if (wrap) { for (var i = 0; i < wrap.length; i++) { this.openFrontierNode(wrap[i]); } }

      var slice = this.unplaced, fragment = parent ? parent.content : slice.content;
      var openStart = slice.openStart - sliceDepth;
      var taken = 0, add = [];
      var ref$1 = this.frontier[frontierDepth];
        var match = ref$1.match;
        var type = ref$1.type;
      if (inject) {
        for (var i$1 = 0; i$1 < inject.childCount; i$1++) { add.push(inject.child(i$1)); }
        match = match.matchFragment(inject);
      }
      // Computes the amount of (end) open nodes at the end of the
      // fragment. When 0, the parent is open, but no more. When
      // negative, nothing is open.
      var openEndCount = (fragment.size + sliceDepth) - (slice.content.size - slice.openEnd);
      // Scan over the fragment, fitting as many child nodes as
      // possible.
      while (taken < fragment.childCount) {
        var next = fragment.child(taken), matches = match.matchType(next.type);
        if (!matches) { break }
        taken++;
        if (taken > 1 || openStart == 0 || next.content.size) { // Drop empty open nodes
          match = matches;
          add.push(closeNodeStart(next.mark(type.allowedMarks(next.marks)), taken == 1 ? openStart : 0,
                                  taken == fragment.childCount ? openEndCount : -1));
        }
      }
      var toEnd = taken == fragment.childCount;
      if (!toEnd) { openEndCount = -1; }

      this.placed = addToFragment(this.placed, frontierDepth, Fragment.from(add));
      this.frontier[frontierDepth].match = match;

      // If the parent types match, and the entire node was moved, and
      // it's not open, close this frontier node right away.
      if (toEnd && openEndCount < 0 && parent && parent.type == this.frontier[this.depth].type && this.frontier.length > 1)
        { this.closeFrontierNode(); }

      // Add new frontier nodes for any open nodes at the end.
      for (var i$2 = 0, cur = fragment; i$2 < openEndCount; i$2++) {
        var node = cur.lastChild;
        this.frontier.push({type: node.type, match: node.contentMatchAt(node.childCount)});
        cur = node.content;
      }

      // Update `this.unplaced`. Drop the entire node from which we
      // placed it we got to its end, otherwise just drop the placed
      // nodes.
      this.unplaced = !toEnd ? new Slice(dropFromFragment(slice.content, sliceDepth, taken), slice.openStart, slice.openEnd)
        : sliceDepth == 0 ? Slice.empty
        : new Slice(dropFromFragment(slice.content, sliceDepth - 1, 1),
                    sliceDepth - 1, openEndCount < 0 ? slice.openEnd : sliceDepth - 1);
    };

    Fitter.prototype.mustMoveInline = function mustMoveInline () {
      if (!this.$to.parent.isTextblock || this.$to.end() == this.$to.pos) { return -1 }
      var top = this.frontier[this.depth], level;
      if (!top.type.isTextblock || !contentAfterFits(this.$to, this.$to.depth, top.type, top.match, false) ||
          (this.$to.depth == this.depth && (level = this.findCloseLevel(this.$to)) && level.depth == this.depth)) { return -1 }

      var ref = this.$to;
        var depth = ref.depth;
        var after = this.$to.after(depth);
      while (depth > 1 && after == this.$to.end(--depth)) { ++after; }
      return after
    };

    Fitter.prototype.findCloseLevel = function findCloseLevel ($to) {
      scan: for (var i = Math.min(this.depth, $to.depth); i >= 0; i--) {
        var ref = this.frontier[i];
          var match = ref.match;
          var type = ref.type;
        var dropInner = i < $to.depth && $to.end(i + 1) == $to.pos + ($to.depth - (i + 1));
        var fit = contentAfterFits($to, i, type, match, dropInner);
        if (!fit) { continue }
        for (var d = i - 1; d >= 0; d--) {
          var ref$1 = this.frontier[d];
            var match$1 = ref$1.match;
            var type$1 = ref$1.type;
          var matches = contentAfterFits($to, d, type$1, match$1, true);
          if (!matches || matches.childCount) { continue scan }
        }
        return {depth: i, fit: fit, move: dropInner ? $to.doc.resolve($to.after(i + 1)) : $to}
      }
    };

    Fitter.prototype.close = function close ($to) {
      var close = this.findCloseLevel($to);
      if (!close) { return null }

      while (this.depth > close.depth) { this.closeFrontierNode(); }
      if (close.fit.childCount) { this.placed = addToFragment(this.placed, close.depth, close.fit); }
      $to = close.move;
      for (var d = close.depth + 1; d <= $to.depth; d++) {
        var node = $to.node(d), add = node.type.contentMatch.fillBefore(node.content, true, $to.index(d));
        this.openFrontierNode(node.type, node.attrs, add);
      }
      return $to
    };

    Fitter.prototype.openFrontierNode = function openFrontierNode (type, attrs, content) {
      var top = this.frontier[this.depth];
      top.match = top.match.matchType(type);
      this.placed = addToFragment(this.placed, this.depth, Fragment.from(type.create(attrs, content)));
      this.frontier.push({type: type, match: type.contentMatch});
    };

    Fitter.prototype.closeFrontierNode = function closeFrontierNode () {
      var open = this.frontier.pop();
      var add = open.match.fillBefore(Fragment.empty, true);
      if (add.childCount) { this.placed = addToFragment(this.placed, this.frontier.length, add); }
    };

    Object.defineProperties( Fitter.prototype, prototypeAccessors$1$4 );

    function dropFromFragment(fragment, depth, count) {
      if (depth == 0) { return fragment.cutByIndex(count) }
      return fragment.replaceChild(0, fragment.firstChild.copy(dropFromFragment(fragment.firstChild.content, depth - 1, count)))
    }

    function addToFragment(fragment, depth, content) {
      if (depth == 0) { return fragment.append(content) }
      return fragment.replaceChild(fragment.childCount - 1,
                                   fragment.lastChild.copy(addToFragment(fragment.lastChild.content, depth - 1, content)))
    }

    function contentAt(fragment, depth) {
      for (var i = 0; i < depth; i++) { fragment = fragment.firstChild.content; }
      return fragment
    }

    function closeNodeStart(node, openStart, openEnd) {
      if (openStart <= 0) { return node }
      var frag = node.content;
      if (openStart > 1)
        { frag = frag.replaceChild(0, closeNodeStart(frag.firstChild, openStart - 1, frag.childCount == 1 ? openEnd - 1 : 0)); }
      if (openStart > 0) {
        frag = node.type.contentMatch.fillBefore(frag).append(frag);
        if (openEnd <= 0) { frag = frag.append(node.type.contentMatch.matchFragment(frag).fillBefore(Fragment.empty, true)); }
      }
      return node.copy(frag)
    }

    function contentAfterFits($to, depth, type, match, open) {
      var node = $to.node(depth), index = open ? $to.indexAfter(depth) : $to.index(depth);
      if (index == node.childCount && !type.compatibleContent(node.type)) { return null }
      var fit = match.fillBefore(node.content, true, index);
      return fit && !invalidMarks(type, node.content, index) ? fit : null
    }

    function invalidMarks(type, fragment, start) {
      for (var i = start; i < fragment.childCount; i++)
        { if (!type.allowsMarks(fragment.child(i).marks)) { return true } }
      return false
    }

    // :: (number, number, Slice) → this
    // Replace a range of the document with a given slice, using `from`,
    // `to`, and the slice's [`openStart`](#model.Slice.openStart) property
    // as hints, rather than fixed start and end points. This method may
    // grow the replaced area or close open nodes in the slice in order to
    // get a fit that is more in line with WYSIWYG expectations, by
    // dropping fully covered parent nodes of the replaced region when
    // they are marked [non-defining](#model.NodeSpec.defining), or
    // including an open parent node from the slice that _is_ marked as
    // [defining](#model.NodeSpec.defining).
    //
    // This is the method, for example, to handle paste. The similar
    // [`replace`](#transform.Transform.replace) method is a more
    // primitive tool which will _not_ move the start and end of its given
    // range, and is useful in situations where you need more precise
    // control over what happens.
    Transform.prototype.replaceRange = function(from, to, slice) {
      if (!slice.size) { return this.deleteRange(from, to) }

      var $from = this.doc.resolve(from), $to = this.doc.resolve(to);
      if (fitsTrivially($from, $to, slice))
        { return this.step(new ReplaceStep(from, to, slice)) }

      var targetDepths = coveredDepths($from, this.doc.resolve(to));
      // Can't replace the whole document, so remove 0 if it's present
      if (targetDepths[targetDepths.length - 1] == 0) { targetDepths.pop(); }
      // Negative numbers represent not expansion over the whole node at
      // that depth, but replacing from $from.before(-D) to $to.pos.
      var preferredTarget = -($from.depth + 1);
      targetDepths.unshift(preferredTarget);
      // This loop picks a preferred target depth, if one of the covering
      // depths is not outside of a defining node, and adds negative
      // depths for any depth that has $from at its start and does not
      // cross a defining node.
      for (var d = $from.depth, pos = $from.pos - 1; d > 0; d--, pos--) {
        var spec = $from.node(d).type.spec;
        if (spec.defining || spec.isolating) { break }
        if (targetDepths.indexOf(d) > -1) { preferredTarget = d; }
        else if ($from.before(d) == pos) { targetDepths.splice(1, 0, -d); }
      }
      // Try to fit each possible depth of the slice into each possible
      // target depth, starting with the preferred depths.
      var preferredTargetIndex = targetDepths.indexOf(preferredTarget);

      var leftNodes = [], preferredDepth = slice.openStart;
      for (var content = slice.content, i = 0;; i++) {
        var node = content.firstChild;
        leftNodes.push(node);
        if (i == slice.openStart) { break }
        content = node.content;
      }
      // Back up if the node directly above openStart, or the node above
      // that separated only by a non-defining textblock node, is defining.
      if (preferredDepth > 0 && leftNodes[preferredDepth - 1].type.spec.defining &&
          $from.node(preferredTargetIndex).type != leftNodes[preferredDepth - 1].type)
        { preferredDepth -= 1; }
      else if (preferredDepth >= 2 && leftNodes[preferredDepth - 1].isTextblock && leftNodes[preferredDepth - 2].type.spec.defining &&
               $from.node(preferredTargetIndex).type != leftNodes[preferredDepth - 2].type)
        { preferredDepth -= 2; }

      for (var j = slice.openStart; j >= 0; j--) {
        var openDepth = (j + preferredDepth + 1) % (slice.openStart + 1);
        var insert = leftNodes[openDepth];
        if (!insert) { continue }
        for (var i$1 = 0; i$1 < targetDepths.length; i$1++) {
          // Loop over possible expansion levels, starting with the
          // preferred one
          var targetDepth = targetDepths[(i$1 + preferredTargetIndex) % targetDepths.length], expand = true;
          if (targetDepth < 0) { expand = false; targetDepth = -targetDepth; }
          var parent = $from.node(targetDepth - 1), index = $from.index(targetDepth - 1);
          if (parent.canReplaceWith(index, index, insert.type, insert.marks))
            { return this.replace($from.before(targetDepth), expand ? $to.after(targetDepth) : to,
                                new Slice(closeFragment(slice.content, 0, slice.openStart, openDepth),
                                          openDepth, slice.openEnd)) }
        }
      }

      var startSteps = this.steps.length;
      for (var i$2 = targetDepths.length - 1; i$2 >= 0; i$2--) {
        this.replace(from, to, slice);
        if (this.steps.length > startSteps) { break }
        var depth = targetDepths[i$2];
        if (i$2 < 0) { continue }
        from = $from.before(depth); to = $to.after(depth);
      }
      return this
    };

    function closeFragment(fragment, depth, oldOpen, newOpen, parent) {
      if (depth < oldOpen) {
        var first = fragment.firstChild;
        fragment = fragment.replaceChild(0, first.copy(closeFragment(first.content, depth + 1, oldOpen, newOpen, first)));
      }
      if (depth > newOpen) {
        var match = parent.contentMatchAt(0);
        var start = match.fillBefore(fragment).append(fragment);
        fragment = start.append(match.matchFragment(start).fillBefore(Fragment.empty, true));
      }
      return fragment
    }

    // :: (number, number, Node) → this
    // Replace the given range with a node, but use `from` and `to` as
    // hints, rather than precise positions. When from and to are the same
    // and are at the start or end of a parent node in which the given
    // node doesn't fit, this method may _move_ them out towards a parent
    // that does allow the given node to be placed. When the given range
    // completely covers a parent node, this method may completely replace
    // that parent node.
    Transform.prototype.replaceRangeWith = function(from, to, node) {
      if (!node.isInline && from == to && this.doc.resolve(from).parent.content.size) {
        var point = insertPoint(this.doc, from, node.type);
        if (point != null) { from = to = point; }
      }
      return this.replaceRange(from, to, new Slice(Fragment.from(node), 0, 0))
    };

    // :: (number, number) → this
    // Delete the given range, expanding it to cover fully covered
    // parent nodes until a valid replace is found.
    Transform.prototype.deleteRange = function(from, to) {
      var $from = this.doc.resolve(from), $to = this.doc.resolve(to);
      var covered = coveredDepths($from, $to);
      for (var i = 0; i < covered.length; i++) {
        var depth = covered[i], last = i == covered.length - 1;
        if ((last && depth == 0) || $from.node(depth).type.contentMatch.validEnd)
          { return this.delete($from.start(depth), $to.end(depth)) }
        if (depth > 0 && (last || $from.node(depth - 1).canReplace($from.index(depth - 1), $to.indexAfter(depth - 1))))
          { return this.delete($from.before(depth), $to.after(depth)) }
      }
      for (var d = 1; d <= $from.depth && d <= $to.depth; d++) {
        if (from - $from.start(d) == $from.depth - d && to > $from.end(d) && $to.end(d) - to != $to.depth - d)
          { return this.delete($from.before(d), to) }
      }
      return this.delete(from, to)
    };

    // : (ResolvedPos, ResolvedPos) → [number]
    // Returns an array of all depths for which $from - $to spans the
    // whole content of the nodes at that depth.
    function coveredDepths($from, $to) {
      var result = [], minDepth = Math.min($from.depth, $to.depth);
      for (var d = minDepth; d >= 0; d--) {
        var start = $from.start(d);
        if (start < $from.pos - ($from.depth - d) ||
            $to.end(d) > $to.pos + ($to.depth - d) ||
            $from.node(d).type.spec.isolating ||
            $to.node(d).type.spec.isolating) { break }
        if (start == $to.start(d)) { result.push(d); }
      }
      return result
    }
    //# sourceMappingURL=index.es.js.map

    var classesById = Object.create(null);

    // ::- Superclass for editor selections. Every selection type should
    // extend this. Should not be instantiated directly.
    var Selection = function Selection($anchor, $head, ranges) {
      // :: [SelectionRange]
      // The ranges covered by the selection.
      this.ranges = ranges || [new SelectionRange($anchor.min($head), $anchor.max($head))];
      // :: ResolvedPos
      // The resolved anchor of the selection (the side that stays in
      // place when the selection is modified).
      this.$anchor = $anchor;
      // :: ResolvedPos
      // The resolved head of the selection (the side that moves when
      // the selection is modified).
      this.$head = $head;
    };

    var prototypeAccessors$8 = { anchor: { configurable: true },head: { configurable: true },from: { configurable: true },to: { configurable: true },$from: { configurable: true },$to: { configurable: true },empty: { configurable: true } };

    // :: number
    // The selection's anchor, as an unresolved position.
    prototypeAccessors$8.anchor.get = function () { return this.$anchor.pos };

    // :: number
    // The selection's head.
    prototypeAccessors$8.head.get = function () { return this.$head.pos };

    // :: number
    // The lower bound of the selection's main range.
    prototypeAccessors$8.from.get = function () { return this.$from.pos };

    // :: number
    // The upper bound of the selection's main range.
    prototypeAccessors$8.to.get = function () { return this.$to.pos };

    // :: ResolvedPos
    // The resolved lowerbound of the selection's main range.
    prototypeAccessors$8.$from.get = function () {
      return this.ranges[0].$from
    };

    // :: ResolvedPos
    // The resolved upper bound of the selection's main range.
    prototypeAccessors$8.$to.get = function () {
      return this.ranges[0].$to
    };

    // :: bool
    // Indicates whether the selection contains any content.
    prototypeAccessors$8.empty.get = function () {
      var ranges = this.ranges;
      for (var i = 0; i < ranges.length; i++)
        { if (ranges[i].$from.pos != ranges[i].$to.pos) { return false } }
      return true
    };

    // eq:: (Selection) → bool
    // Test whether the selection is the same as another selection.

    // map:: (doc: Node, mapping: Mappable) → Selection
    // Map this selection through a [mappable](#transform.Mappable) thing. `doc`
    // should be the new document to which we are mapping.

    // :: () → Slice
    // Get the content of this selection as a slice.
    Selection.prototype.content = function content () {
      return this.$from.node(0).slice(this.from, this.to, true)
    };

    // :: (Transaction, ?Slice)
    // Replace the selection with a slice or, if no slice is given,
    // delete the selection. Will append to the given transaction.
    Selection.prototype.replace = function replace (tr, content) {
        if ( content === void 0 ) content = Slice.empty;

      // Put the new selection at the position after the inserted
      // content. When that ended in an inline node, search backwards,
      // to get the position after that node. If not, search forward.
      var lastNode = content.content.lastChild, lastParent = null;
      for (var i = 0; i < content.openEnd; i++) {
        lastParent = lastNode;
        lastNode = lastNode.lastChild;
      }

      var mapFrom = tr.steps.length, ranges = this.ranges;
      for (var i$1 = 0; i$1 < ranges.length; i$1++) {
        var ref = ranges[i$1];
          var $from = ref.$from;
          var $to = ref.$to;
          var mapping = tr.mapping.slice(mapFrom);
        tr.replaceRange(mapping.map($from.pos), mapping.map($to.pos), i$1 ? Slice.empty : content);
        if (i$1 == 0)
          { selectionToInsertionEnd(tr, mapFrom, (lastNode ? lastNode.isInline : lastParent && lastParent.isTextblock) ? -1 : 1); }
      }
    };

    // :: (Transaction, Node)
    // Replace the selection with the given node, appending the changes
    // to the given transaction.
    Selection.prototype.replaceWith = function replaceWith (tr, node) {
      var mapFrom = tr.steps.length, ranges = this.ranges;
      for (var i = 0; i < ranges.length; i++) {
        var ref = ranges[i];
          var $from = ref.$from;
          var $to = ref.$to;
          var mapping = tr.mapping.slice(mapFrom);
        var from = mapping.map($from.pos), to = mapping.map($to.pos);
        if (i) {
          tr.deleteRange(from, to);
        } else {
          tr.replaceRangeWith(from, to, node);
          selectionToInsertionEnd(tr, mapFrom, node.isInline ? -1 : 1);
        }
      }
    };

    // toJSON:: () → Object
    // Convert the selection to a JSON representation. When implementing
    // this for a custom selection class, make sure to give the object a
    // `type` property whose value matches the ID under which you
    // [registered](#state.Selection^jsonID) your class.

    // :: (ResolvedPos, number, ?bool) → ?Selection
    // Find a valid cursor or leaf node selection starting at the given
    // position and searching back if `dir` is negative, and forward if
    // positive. When `textOnly` is true, only consider cursor
    // selections. Will return null when no valid selection position is
    // found.
    Selection.findFrom = function findFrom ($pos, dir, textOnly) {
      var inner = $pos.parent.inlineContent ? new TextSelection($pos)
          : findSelectionIn($pos.node(0), $pos.parent, $pos.pos, $pos.index(), dir, textOnly);
      if (inner) { return inner }

      for (var depth = $pos.depth - 1; depth >= 0; depth--) {
        var found = dir < 0
            ? findSelectionIn($pos.node(0), $pos.node(depth), $pos.before(depth + 1), $pos.index(depth), dir, textOnly)
            : findSelectionIn($pos.node(0), $pos.node(depth), $pos.after(depth + 1), $pos.index(depth) + 1, dir, textOnly);
        if (found) { return found }
      }
    };

    // :: (ResolvedPos, ?number) → Selection
    // Find a valid cursor or leaf node selection near the given
    // position. Searches forward first by default, but if `bias` is
    // negative, it will search backwards first.
    Selection.near = function near ($pos, bias) {
        if ( bias === void 0 ) bias = 1;

      return this.findFrom($pos, bias) || this.findFrom($pos, -bias) || new AllSelection($pos.node(0))
    };

    // :: (Node) → Selection
    // Find the cursor or leaf node selection closest to the start of
    // the given document. Will return an
    // [`AllSelection`](#state.AllSelection) if no valid position
    // exists.
    Selection.atStart = function atStart (doc) {
      return findSelectionIn(doc, doc, 0, 0, 1) || new AllSelection(doc)
    };

    // :: (Node) → Selection
    // Find the cursor or leaf node selection closest to the end of the
    // given document.
    Selection.atEnd = function atEnd (doc) {
      return findSelectionIn(doc, doc, doc.content.size, doc.childCount, -1) || new AllSelection(doc)
    };

    // :: (Node, Object) → Selection
    // Deserialize the JSON representation of a selection. Must be
    // implemented for custom classes (as a static class method).
    Selection.fromJSON = function fromJSON (doc, json) {
      if (!json || !json.type) { throw new RangeError("Invalid input for Selection.fromJSON") }
      var cls = classesById[json.type];
      if (!cls) { throw new RangeError(("No selection type " + (json.type) + " defined")) }
      return cls.fromJSON(doc, json)
    };

    // :: (string, constructor<Selection>)
    // To be able to deserialize selections from JSON, custom selection
    // classes must register themselves with an ID string, so that they
    // can be disambiguated. Try to pick something that's unlikely to
    // clash with classes from other modules.
    Selection.jsonID = function jsonID (id, selectionClass) {
      if (id in classesById) { throw new RangeError("Duplicate use of selection JSON ID " + id) }
      classesById[id] = selectionClass;
      selectionClass.prototype.jsonID = id;
      return selectionClass
    };

    // :: () → SelectionBookmark
    // Get a [bookmark](#state.SelectionBookmark) for this selection,
    // which is a value that can be mapped without having access to a
    // current document, and later resolved to a real selection for a
    // given document again. (This is used mostly by the history to
    // track and restore old selections.) The default implementation of
    // this method just converts the selection to a text selection and
    // returns the bookmark for that.
    Selection.prototype.getBookmark = function getBookmark () {
      return TextSelection.between(this.$anchor, this.$head).getBookmark()
    };

    Object.defineProperties( Selection.prototype, prototypeAccessors$8 );

    // :: bool
    // Controls whether, when a selection of this type is active in the
    // browser, the selected range should be visible to the user. Defaults
    // to `true`.
    Selection.prototype.visible = true;

    // SelectionBookmark:: interface
    // A lightweight, document-independent representation of a selection.
    // You can define a custom bookmark type for a custom selection class
    // to make the history handle it well.
    //
    //   map:: (mapping: Mapping) → SelectionBookmark
    //   Map the bookmark through a set of changes.
    //
    //   resolve:: (doc: Node) → Selection
    //   Resolve the bookmark to a real selection again. This may need to
    //   do some error checking and may fall back to a default (usually
    //   [`TextSelection.between`](#state.TextSelection^between)) if
    //   mapping made the bookmark invalid.

    // ::- Represents a selected range in a document.
    var SelectionRange = function SelectionRange($from, $to) {
      // :: ResolvedPos
      // The lower bound of the range.
      this.$from = $from;
      // :: ResolvedPos
      // The upper bound of the range.
      this.$to = $to;
    };

    // ::- A text selection represents a classical editor selection, with
    // a head (the moving side) and anchor (immobile side), both of which
    // point into textblock nodes. It can be empty (a regular cursor
    // position).
    var TextSelection = /*@__PURE__*/(function (Selection) {
      function TextSelection($anchor, $head) {
        if ( $head === void 0 ) $head = $anchor;

        Selection.call(this, $anchor, $head);
      }

      if ( Selection ) TextSelection.__proto__ = Selection;
      TextSelection.prototype = Object.create( Selection && Selection.prototype );
      TextSelection.prototype.constructor = TextSelection;

      var prototypeAccessors$1 = { $cursor: { configurable: true } };

      // :: ?ResolvedPos
      // Returns a resolved position if this is a cursor selection (an
      // empty text selection), and null otherwise.
      prototypeAccessors$1.$cursor.get = function () { return this.$anchor.pos == this.$head.pos ? this.$head : null };

      TextSelection.prototype.map = function map (doc, mapping) {
        var $head = doc.resolve(mapping.map(this.head));
        if (!$head.parent.inlineContent) { return Selection.near($head) }
        var $anchor = doc.resolve(mapping.map(this.anchor));
        return new TextSelection($anchor.parent.inlineContent ? $anchor : $head, $head)
      };

      TextSelection.prototype.replace = function replace (tr, content) {
        if ( content === void 0 ) content = Slice.empty;

        Selection.prototype.replace.call(this, tr, content);
        if (content == Slice.empty) {
          var marks = this.$from.marksAcross(this.$to);
          if (marks) { tr.ensureMarks(marks); }
        }
      };

      TextSelection.prototype.eq = function eq (other) {
        return other instanceof TextSelection && other.anchor == this.anchor && other.head == this.head
      };

      TextSelection.prototype.getBookmark = function getBookmark () {
        return new TextBookmark(this.anchor, this.head)
      };

      TextSelection.prototype.toJSON = function toJSON () {
        return {type: "text", anchor: this.anchor, head: this.head}
      };

      TextSelection.fromJSON = function fromJSON (doc, json) {
        if (typeof json.anchor != "number" || typeof json.head != "number")
          { throw new RangeError("Invalid input for TextSelection.fromJSON") }
        return new TextSelection(doc.resolve(json.anchor), doc.resolve(json.head))
      };

      // :: (Node, number, ?number) → TextSelection
      // Create a text selection from non-resolved positions.
      TextSelection.create = function create (doc, anchor, head) {
        if ( head === void 0 ) head = anchor;

        var $anchor = doc.resolve(anchor);
        return new this($anchor, head == anchor ? $anchor : doc.resolve(head))
      };

      // :: (ResolvedPos, ResolvedPos, ?number) → Selection
      // Return a text selection that spans the given positions or, if
      // they aren't text positions, find a text selection near them.
      // `bias` determines whether the method searches forward (default)
      // or backwards (negative number) first. Will fall back to calling
      // [`Selection.near`](#state.Selection^near) when the document
      // doesn't contain a valid text position.
      TextSelection.between = function between ($anchor, $head, bias) {
        var dPos = $anchor.pos - $head.pos;
        if (!bias || dPos) { bias = dPos >= 0 ? 1 : -1; }
        if (!$head.parent.inlineContent) {
          var found = Selection.findFrom($head, bias, true) || Selection.findFrom($head, -bias, true);
          if (found) { $head = found.$head; }
          else { return Selection.near($head, bias) }
        }
        if (!$anchor.parent.inlineContent) {
          if (dPos == 0) {
            $anchor = $head;
          } else {
            $anchor = (Selection.findFrom($anchor, -bias, true) || Selection.findFrom($anchor, bias, true)).$anchor;
            if (($anchor.pos < $head.pos) != (dPos < 0)) { $anchor = $head; }
          }
        }
        return new TextSelection($anchor, $head)
      };

      Object.defineProperties( TextSelection.prototype, prototypeAccessors$1 );

      return TextSelection;
    }(Selection));

    Selection.jsonID("text", TextSelection);

    var TextBookmark = function TextBookmark(anchor, head) {
      this.anchor = anchor;
      this.head = head;
    };
    TextBookmark.prototype.map = function map (mapping) {
      return new TextBookmark(mapping.map(this.anchor), mapping.map(this.head))
    };
    TextBookmark.prototype.resolve = function resolve (doc) {
      return TextSelection.between(doc.resolve(this.anchor), doc.resolve(this.head))
    };

    // ::- A node selection is a selection that points at a single node.
    // All nodes marked [selectable](#model.NodeSpec.selectable) can be
    // the target of a node selection. In such a selection, `from` and
    // `to` point directly before and after the selected node, `anchor`
    // equals `from`, and `head` equals `to`..
    var NodeSelection = /*@__PURE__*/(function (Selection) {
      function NodeSelection($pos) {
        var node = $pos.nodeAfter;
        var $end = $pos.node(0).resolve($pos.pos + node.nodeSize);
        Selection.call(this, $pos, $end);
        // :: Node The selected node.
        this.node = node;
      }

      if ( Selection ) NodeSelection.__proto__ = Selection;
      NodeSelection.prototype = Object.create( Selection && Selection.prototype );
      NodeSelection.prototype.constructor = NodeSelection;

      NodeSelection.prototype.map = function map (doc, mapping) {
        var ref = mapping.mapResult(this.anchor);
        var deleted = ref.deleted;
        var pos = ref.pos;
        var $pos = doc.resolve(pos);
        if (deleted) { return Selection.near($pos) }
        return new NodeSelection($pos)
      };

      NodeSelection.prototype.content = function content () {
        return new Slice(Fragment.from(this.node), 0, 0)
      };

      NodeSelection.prototype.eq = function eq (other) {
        return other instanceof NodeSelection && other.anchor == this.anchor
      };

      NodeSelection.prototype.toJSON = function toJSON () {
        return {type: "node", anchor: this.anchor}
      };

      NodeSelection.prototype.getBookmark = function getBookmark () { return new NodeBookmark(this.anchor) };

      NodeSelection.fromJSON = function fromJSON (doc, json) {
        if (typeof json.anchor != "number")
          { throw new RangeError("Invalid input for NodeSelection.fromJSON") }
        return new NodeSelection(doc.resolve(json.anchor))
      };

      // :: (Node, number) → NodeSelection
      // Create a node selection from non-resolved positions.
      NodeSelection.create = function create (doc, from) {
        return new this(doc.resolve(from))
      };

      // :: (Node) → bool
      // Determines whether the given node may be selected as a node
      // selection.
      NodeSelection.isSelectable = function isSelectable (node) {
        return !node.isText && node.type.spec.selectable !== false
      };

      return NodeSelection;
    }(Selection));

    NodeSelection.prototype.visible = false;

    Selection.jsonID("node", NodeSelection);

    var NodeBookmark = function NodeBookmark(anchor) {
      this.anchor = anchor;
    };
    NodeBookmark.prototype.map = function map (mapping) {
      var ref = mapping.mapResult(this.anchor);
        var deleted = ref.deleted;
        var pos = ref.pos;
      return deleted ? new TextBookmark(pos, pos) : new NodeBookmark(pos)
    };
    NodeBookmark.prototype.resolve = function resolve (doc) {
      var $pos = doc.resolve(this.anchor), node = $pos.nodeAfter;
      if (node && NodeSelection.isSelectable(node)) { return new NodeSelection($pos) }
      return Selection.near($pos)
    };

    // ::- A selection type that represents selecting the whole document
    // (which can not necessarily be expressed with a text selection, when
    // there are for example leaf block nodes at the start or end of the
    // document).
    var AllSelection = /*@__PURE__*/(function (Selection) {
      function AllSelection(doc) {
        Selection.call(this, doc.resolve(0), doc.resolve(doc.content.size));
      }

      if ( Selection ) AllSelection.__proto__ = Selection;
      AllSelection.prototype = Object.create( Selection && Selection.prototype );
      AllSelection.prototype.constructor = AllSelection;

      AllSelection.prototype.replace = function replace (tr, content) {
        if ( content === void 0 ) content = Slice.empty;

        if (content == Slice.empty) {
          tr.delete(0, tr.doc.content.size);
          var sel = Selection.atStart(tr.doc);
          if (!sel.eq(tr.selection)) { tr.setSelection(sel); }
        } else {
          Selection.prototype.replace.call(this, tr, content);
        }
      };

      AllSelection.prototype.toJSON = function toJSON () { return {type: "all"} };

      AllSelection.fromJSON = function fromJSON (doc) { return new AllSelection(doc) };

      AllSelection.prototype.map = function map (doc) { return new AllSelection(doc) };

      AllSelection.prototype.eq = function eq (other) { return other instanceof AllSelection };

      AllSelection.prototype.getBookmark = function getBookmark () { return AllBookmark };

      return AllSelection;
    }(Selection));

    Selection.jsonID("all", AllSelection);

    var AllBookmark = {
      map: function map() { return this },
      resolve: function resolve(doc) { return new AllSelection(doc) }
    };

    // FIXME we'll need some awareness of text direction when scanning for selections

    // Try to find a selection inside the given node. `pos` points at the
    // position where the search starts. When `text` is true, only return
    // text selections.
    function findSelectionIn(doc, node, pos, index, dir, text) {
      if (node.inlineContent) { return TextSelection.create(doc, pos) }
      for (var i = index - (dir > 0 ? 0 : 1); dir > 0 ? i < node.childCount : i >= 0; i += dir) {
        var child = node.child(i);
        if (!child.isAtom) {
          var inner = findSelectionIn(doc, child, pos + dir, dir < 0 ? child.childCount : 0, dir, text);
          if (inner) { return inner }
        } else if (!text && NodeSelection.isSelectable(child)) {
          return NodeSelection.create(doc, pos - (dir < 0 ? child.nodeSize : 0))
        }
        pos += child.nodeSize * dir;
      }
    }

    function selectionToInsertionEnd(tr, startLen, bias) {
      var last = tr.steps.length - 1;
      if (last < startLen) { return }
      var step = tr.steps[last];
      if (!(step instanceof ReplaceStep || step instanceof ReplaceAroundStep)) { return }
      var map = tr.mapping.maps[last], end;
      map.forEach(function (_from, _to, _newFrom, newTo) { if (end == null) { end = newTo; } });
      tr.setSelection(Selection.near(tr.doc.resolve(end), bias));
    }

    var UPDATED_SEL = 1, UPDATED_MARKS = 2, UPDATED_SCROLL = 4;

    // ::- An editor state transaction, which can be applied to a state to
    // create an updated state. Use
    // [`EditorState.tr`](#state.EditorState.tr) to create an instance.
    //
    // Transactions track changes to the document (they are a subclass of
    // [`Transform`](#transform.Transform)), but also other state changes,
    // like selection updates and adjustments of the set of [stored
    // marks](#state.EditorState.storedMarks). In addition, you can store
    // metadata properties in a transaction, which are extra pieces of
    // information that client code or plugins can use to describe what a
    // transacion represents, so that they can update their [own
    // state](#state.StateField) accordingly.
    //
    // The [editor view](#view.EditorView) uses a few metadata properties:
    // it will attach a property `"pointer"` with the value `true` to
    // selection transactions directly caused by mouse or touch input, and
    // a `"uiEvent"` property of that may be `"paste"`, `"cut"`, or `"drop"`.
    var Transaction = /*@__PURE__*/(function (Transform) {
      function Transaction(state) {
        Transform.call(this, state.doc);
        // :: number
        // The timestamp associated with this transaction, in the same
        // format as `Date.now()`.
        this.time = Date.now();
        this.curSelection = state.selection;
        // The step count for which the current selection is valid.
        this.curSelectionFor = 0;
        // :: ?[Mark]
        // The stored marks set by this transaction, if any.
        this.storedMarks = state.storedMarks;
        // Bitfield to track which aspects of the state were updated by
        // this transaction.
        this.updated = 0;
        // Object used to store metadata properties for the transaction.
        this.meta = Object.create(null);
      }

      if ( Transform ) Transaction.__proto__ = Transform;
      Transaction.prototype = Object.create( Transform && Transform.prototype );
      Transaction.prototype.constructor = Transaction;

      var prototypeAccessors = { selection: { configurable: true },selectionSet: { configurable: true },storedMarksSet: { configurable: true },isGeneric: { configurable: true },scrolledIntoView: { configurable: true } };

      // :: Selection
      // The transaction's current selection. This defaults to the editor
      // selection [mapped](#state.Selection.map) through the steps in the
      // transaction, but can be overwritten with
      // [`setSelection`](#state.Transaction.setSelection).
      prototypeAccessors.selection.get = function () {
        if (this.curSelectionFor < this.steps.length) {
          this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor));
          this.curSelectionFor = this.steps.length;
        }
        return this.curSelection
      };

      // :: (Selection) → Transaction
      // Update the transaction's current selection. Will determine the
      // selection that the editor gets when the transaction is applied.
      Transaction.prototype.setSelection = function setSelection (selection) {
        if (selection.$from.doc != this.doc)
          { throw new RangeError("Selection passed to setSelection must point at the current document") }
        this.curSelection = selection;
        this.curSelectionFor = this.steps.length;
        this.updated = (this.updated | UPDATED_SEL) & ~UPDATED_MARKS;
        this.storedMarks = null;
        return this
      };

      // :: bool
      // Whether the selection was explicitly updated by this transaction.
      prototypeAccessors.selectionSet.get = function () {
        return (this.updated & UPDATED_SEL) > 0
      };

      // :: (?[Mark]) → Transaction
      // Set the current stored marks.
      Transaction.prototype.setStoredMarks = function setStoredMarks (marks) {
        this.storedMarks = marks;
        this.updated |= UPDATED_MARKS;
        return this
      };

      // :: ([Mark]) → Transaction
      // Make sure the current stored marks or, if that is null, the marks
      // at the selection, match the given set of marks. Does nothing if
      // this is already the case.
      Transaction.prototype.ensureMarks = function ensureMarks (marks) {
        if (!Mark.sameSet(this.storedMarks || this.selection.$from.marks(), marks))
          { this.setStoredMarks(marks); }
        return this
      };

      // :: (Mark) → Transaction
      // Add a mark to the set of stored marks.
      Transaction.prototype.addStoredMark = function addStoredMark (mark) {
        return this.ensureMarks(mark.addToSet(this.storedMarks || this.selection.$head.marks()))
      };

      // :: (union<Mark, MarkType>) → Transaction
      // Remove a mark or mark type from the set of stored marks.
      Transaction.prototype.removeStoredMark = function removeStoredMark (mark) {
        return this.ensureMarks(mark.removeFromSet(this.storedMarks || this.selection.$head.marks()))
      };

      // :: bool
      // Whether the stored marks were explicitly set for this transaction.
      prototypeAccessors.storedMarksSet.get = function () {
        return (this.updated & UPDATED_MARKS) > 0
      };

      Transaction.prototype.addStep = function addStep (step, doc) {
        Transform.prototype.addStep.call(this, step, doc);
        this.updated = this.updated & ~UPDATED_MARKS;
        this.storedMarks = null;
      };

      // :: (number) → Transaction
      // Update the timestamp for the transaction.
      Transaction.prototype.setTime = function setTime (time) {
        this.time = time;
        return this
      };

      // :: (Slice) → Transaction
      // Replace the current selection with the given slice.
      Transaction.prototype.replaceSelection = function replaceSelection (slice) {
        this.selection.replace(this, slice);
        return this
      };

      // :: (Node, ?bool) → Transaction
      // Replace the selection with the given node. When `inheritMarks` is
      // true and the content is inline, it inherits the marks from the
      // place where it is inserted.
      Transaction.prototype.replaceSelectionWith = function replaceSelectionWith (node, inheritMarks) {
        var selection = this.selection;
        if (inheritMarks !== false)
          { node = node.mark(this.storedMarks || (selection.empty ? selection.$from.marks() : (selection.$from.marksAcross(selection.$to) || Mark.none))); }
        selection.replaceWith(this, node);
        return this
      };

      // :: () → Transaction
      // Delete the selection.
      Transaction.prototype.deleteSelection = function deleteSelection () {
        this.selection.replace(this);
        return this
      };

      // :: (string, from: ?number, to: ?number) → Transaction
      // Replace the given range, or the selection if no range is given,
      // with a text node containing the given string.
      Transaction.prototype.insertText = function insertText (text, from, to) {
        if ( to === void 0 ) to = from;

        var schema = this.doc.type.schema;
        if (from == null) {
          if (!text) { return this.deleteSelection() }
          return this.replaceSelectionWith(schema.text(text), true)
        } else {
          if (!text) { return this.deleteRange(from, to) }
          var marks = this.storedMarks;
          if (!marks) {
            var $from = this.doc.resolve(from);
            marks = to == from ? $from.marks() : $from.marksAcross(this.doc.resolve(to));
          }
          this.replaceRangeWith(from, to, schema.text(text, marks));
          if (!this.selection.empty) { this.setSelection(Selection.near(this.selection.$to)); }
          return this
        }
      };

      // :: (union<string, Plugin, PluginKey>, any) → Transaction
      // Store a metadata property in this transaction, keyed either by
      // name or by plugin.
      Transaction.prototype.setMeta = function setMeta (key, value) {
        this.meta[typeof key == "string" ? key : key.key] = value;
        return this
      };

      // :: (union<string, Plugin, PluginKey>) → any
      // Retrieve a metadata property for a given name or plugin.
      Transaction.prototype.getMeta = function getMeta (key) {
        return this.meta[typeof key == "string" ? key : key.key]
      };

      // :: bool
      // Returns true if this transaction doesn't contain any metadata,
      // and can thus safely be extended.
      prototypeAccessors.isGeneric.get = function () {
        for (var _ in this.meta) { return false }
        return true
      };

      // :: () → Transaction
      // Indicate that the editor should scroll the selection into view
      // when updated to the state produced by this transaction.
      Transaction.prototype.scrollIntoView = function scrollIntoView () {
        this.updated |= UPDATED_SCROLL;
        return this
      };

      prototypeAccessors.scrolledIntoView.get = function () {
        return (this.updated & UPDATED_SCROLL) > 0
      };

      Object.defineProperties( Transaction.prototype, prototypeAccessors );

      return Transaction;
    }(Transform));

    function bind(f, self) {
      return !self || !f ? f : f.bind(self)
    }

    var FieldDesc = function FieldDesc(name, desc, self) {
      this.name = name;
      this.init = bind(desc.init, self);
      this.apply = bind(desc.apply, self);
    };

    var baseFields = [
      new FieldDesc("doc", {
        init: function init(config) { return config.doc || config.schema.topNodeType.createAndFill() },
        apply: function apply(tr) { return tr.doc }
      }),

      new FieldDesc("selection", {
        init: function init(config, instance) { return config.selection || Selection.atStart(instance.doc) },
        apply: function apply(tr) { return tr.selection }
      }),

      new FieldDesc("storedMarks", {
        init: function init(config) { return config.storedMarks || null },
        apply: function apply(tr, _marks, _old, state) { return state.selection.$cursor ? tr.storedMarks : null }
      }),

      new FieldDesc("scrollToSelection", {
        init: function init() { return 0 },
        apply: function apply(tr, prev) { return tr.scrolledIntoView ? prev + 1 : prev }
      })
    ];

    // Object wrapping the part of a state object that stays the same
    // across transactions. Stored in the state's `config` property.
    var Configuration = function Configuration(schema, plugins) {
      var this$1 = this;

      this.schema = schema;
      this.fields = baseFields.concat();
      this.plugins = [];
      this.pluginsByKey = Object.create(null);
      if (plugins) { plugins.forEach(function (plugin) {
        if (this$1.pluginsByKey[plugin.key])
          { throw new RangeError("Adding different instances of a keyed plugin (" + plugin.key + ")") }
        this$1.plugins.push(plugin);
        this$1.pluginsByKey[plugin.key] = plugin;
        if (plugin.spec.state)
          { this$1.fields.push(new FieldDesc(plugin.key, plugin.spec.state, plugin)); }
      }); }
    };

    // ::- The state of a ProseMirror editor is represented by an object
    // of this type. A state is a persistent data structure—it isn't
    // updated, but rather a new state value is computed from an old one
    // using the [`apply`](#state.EditorState.apply) method.
    //
    // A state holds a number of built-in fields, and plugins can
    // [define](#state.PluginSpec.state) additional fields.
    var EditorState = function EditorState(config) {
      this.config = config;
    };

    var prototypeAccessors$1$5 = { schema: { configurable: true },plugins: { configurable: true },tr: { configurable: true } };

    // doc:: Node
    // The current document.

    // selection:: Selection
    // The selection.

    // storedMarks:: ?[Mark]
    // A set of marks to apply to the next input. Will be null when
    // no explicit marks have been set.

    // :: Schema
    // The schema of the state's document.
    prototypeAccessors$1$5.schema.get = function () {
      return this.config.schema
    };

    // :: [Plugin]
    // The plugins that are active in this state.
    prototypeAccessors$1$5.plugins.get = function () {
      return this.config.plugins
    };

    // :: (Transaction) → EditorState
    // Apply the given transaction to produce a new state.
    EditorState.prototype.apply = function apply (tr) {
      return this.applyTransaction(tr).state
    };

    // : (Transaction) → bool
    EditorState.prototype.filterTransaction = function filterTransaction (tr, ignore) {
        if ( ignore === void 0 ) ignore = -1;

      for (var i = 0; i < this.config.plugins.length; i++) { if (i != ignore) {
        var plugin = this.config.plugins[i];
        if (plugin.spec.filterTransaction && !plugin.spec.filterTransaction.call(plugin, tr, this))
          { return false }
      } }
      return true
    };

    // :: (Transaction) → {state: EditorState, transactions: [Transaction]}
    // Verbose variant of [`apply`](#state.EditorState.apply) that
    // returns the precise transactions that were applied (which might
    // be influenced by the [transaction
    // hooks](#state.PluginSpec.filterTransaction) of
    // plugins) along with the new state.
    EditorState.prototype.applyTransaction = function applyTransaction (rootTr) {
      if (!this.filterTransaction(rootTr)) { return {state: this, transactions: []} }

      var trs = [rootTr], newState = this.applyInner(rootTr), seen = null;
      // This loop repeatedly gives plugins a chance to respond to
      // transactions as new transactions are added, making sure to only
      // pass the transactions the plugin did not see before.
       for (;;) {
        var haveNew = false;
        for (var i = 0; i < this.config.plugins.length; i++) {
          var plugin = this.config.plugins[i];
          if (plugin.spec.appendTransaction) {
            var n = seen ? seen[i].n : 0, oldState = seen ? seen[i].state : this;
            var tr = n < trs.length &&
                plugin.spec.appendTransaction.call(plugin, n ? trs.slice(n) : trs, oldState, newState);
            if (tr && newState.filterTransaction(tr, i)) {
              tr.setMeta("appendedTransaction", rootTr);
              if (!seen) {
                seen = [];
                for (var j = 0; j < this.config.plugins.length; j++)
                  { seen.push(j < i ? {state: newState, n: trs.length} : {state: this, n: 0}); }
              }
              trs.push(tr);
              newState = newState.applyInner(tr);
              haveNew = true;
            }
            if (seen) { seen[i] = {state: newState, n: trs.length}; }
          }
        }
        if (!haveNew) { return {state: newState, transactions: trs} }
      }
    };

    // : (Transaction) → EditorState
    EditorState.prototype.applyInner = function applyInner (tr) {
      if (!tr.before.eq(this.doc)) { throw new RangeError("Applying a mismatched transaction") }
      var newInstance = new EditorState(this.config), fields = this.config.fields;
      for (var i = 0; i < fields.length; i++) {
        var field = fields[i];
        newInstance[field.name] = field.apply(tr, this[field.name], this, newInstance);
      }
      for (var i$1 = 0; i$1 < applyListeners.length; i$1++) { applyListeners[i$1](this, tr, newInstance); }
      return newInstance
    };

    // :: Transaction
    // Start a [transaction](#state.Transaction) from this state.
    prototypeAccessors$1$5.tr.get = function () { return new Transaction(this) };

    // :: (Object) → EditorState
    // Create a new state.
    //
    // config::- Configuration options. Must contain `schema` or `doc` (or both).
    //
    //    schema:: ?Schema
    //    The schema to use (only relevant if no `doc` is specified).
    //
    //    doc:: ?Node
    //    The starting document.
    //
    //    selection:: ?Selection
    //    A valid selection in the document.
    //
    //    storedMarks:: ?[Mark]
    //    The initial set of [stored marks](#state.EditorState.storedMarks).
    //
    //    plugins:: ?[Plugin]
    //    The plugins that should be active in this state.
    EditorState.create = function create (config) {
      var $config = new Configuration(config.doc ? config.doc.type.schema : config.schema, config.plugins);
      var instance = new EditorState($config);
      for (var i = 0; i < $config.fields.length; i++)
        { instance[$config.fields[i].name] = $config.fields[i].init(config, instance); }
      return instance
    };

    // :: (Object) → EditorState
    // Create a new state based on this one, but with an adjusted set of
    // active plugins. State fields that exist in both sets of plugins
    // are kept unchanged. Those that no longer exist are dropped, and
    // those that are new are initialized using their
    // [`init`](#state.StateField.init) method, passing in the new
    // configuration object..
    //
    // config::- configuration options
    //
    //   plugins:: [Plugin]
    //   New set of active plugins.
    EditorState.prototype.reconfigure = function reconfigure (config) {
      var $config = new Configuration(this.schema, config.plugins);
      var fields = $config.fields, instance = new EditorState($config);
      for (var i = 0; i < fields.length; i++) {
        var name = fields[i].name;
        instance[name] = this.hasOwnProperty(name) ? this[name] : fields[i].init(config, instance);
      }
      return instance
    };

    // :: (?union<Object<Plugin>, string, number>) → Object
    // Serialize this state to JSON. If you want to serialize the state
    // of plugins, pass an object mapping property names to use in the
    // resulting JSON object to plugin objects. The argument may also be
    // a string or number, in which case it is ignored, to support the
    // way `JSON.stringify` calls `toString` methods.
    EditorState.prototype.toJSON = function toJSON (pluginFields) {
      var result = {doc: this.doc.toJSON(), selection: this.selection.toJSON()};
      if (this.storedMarks) { result.storedMarks = this.storedMarks.map(function (m) { return m.toJSON(); }); }
      if (pluginFields && typeof pluginFields == 'object') { for (var prop in pluginFields) {
        if (prop == "doc" || prop == "selection")
          { throw new RangeError("The JSON fields `doc` and `selection` are reserved") }
        var plugin = pluginFields[prop], state = plugin.spec.state;
        if (state && state.toJSON) { result[prop] = state.toJSON.call(plugin, this[plugin.key]); }
      } }
      return result
    };

    // :: (Object, Object, ?Object<Plugin>) → EditorState
    // Deserialize a JSON representation of a state. `config` should
    // have at least a `schema` field, and should contain array of
    // plugins to initialize the state with. `pluginFields` can be used
    // to deserialize the state of plugins, by associating plugin
    // instances with the property names they use in the JSON object.
    //
    // config::- configuration options
    //
    //   schema:: Schema
    //   The schema to use.
    //
    //   plugins:: ?[Plugin]
    //   The set of active plugins.
    EditorState.fromJSON = function fromJSON (config, json, pluginFields) {
      if (!json) { throw new RangeError("Invalid input for EditorState.fromJSON") }
      if (!config.schema) { throw new RangeError("Required config field 'schema' missing") }
      var $config = new Configuration(config.schema, config.plugins);
      var instance = new EditorState($config);
      $config.fields.forEach(function (field) {
        if (field.name == "doc") {
          instance.doc = Node$1.fromJSON(config.schema, json.doc);
        } else if (field.name == "selection") {
          instance.selection = Selection.fromJSON(instance.doc, json.selection);
        } else if (field.name == "storedMarks") {
          if (json.storedMarks) { instance.storedMarks = json.storedMarks.map(config.schema.markFromJSON); }
        } else {
          if (pluginFields) { for (var prop in pluginFields) {
            var plugin = pluginFields[prop], state = plugin.spec.state;
            if (plugin.key == field.name && state && state.fromJSON &&
                Object.prototype.hasOwnProperty.call(json, prop)) {
              // This field belongs to a plugin mapped to a JSON field, read it from there.
              instance[field.name] = state.fromJSON.call(plugin, config, json[prop], instance);
              return
            }
          } }
          instance[field.name] = field.init(config, instance);
        }
      });
      return instance
    };

    // Kludge to allow the view to track mappings between different
    // instances of a state.
    //
    // FIXME this is no longer needed as of prosemirror-view 1.9.0,
    // though due to backwards-compat we should probably keep it around
    // for a while (if only as a no-op)
    EditorState.addApplyListener = function addApplyListener (f) {
      applyListeners.push(f);
    };
    EditorState.removeApplyListener = function removeApplyListener (f) {
      var found = applyListeners.indexOf(f);
      if (found > -1) { applyListeners.splice(found, 1); }
    };

    Object.defineProperties( EditorState.prototype, prototypeAccessors$1$5 );

    var applyListeners = [];

    // PluginSpec:: interface
    //
    // This is the type passed to the [`Plugin`](#state.Plugin)
    // constructor. It provides a definition for a plugin.
    //
    //   props:: ?EditorProps
    //   The [view props](#view.EditorProps) added by this plugin. Props
    //   that are functions will be bound to have the plugin instance as
    //   their `this` binding.
    //
    //   state:: ?StateField<any>
    //   Allows a plugin to define a [state field](#state.StateField), an
    //   extra slot in the state object in which it can keep its own data.
    //
    //   key:: ?PluginKey
    //   Can be used to make this a keyed plugin. You can have only one
    //   plugin with a given key in a given state, but it is possible to
    //   access the plugin's configuration and state through the key,
    //   without having access to the plugin instance object.
    //
    //   view:: ?(EditorView) → Object
    //   When the plugin needs to interact with the editor view, or
    //   set something up in the DOM, use this field. The function
    //   will be called when the plugin's state is associated with an
    //   editor view.
    //
    //     return::-
    //     Should return an object with the following optional
    //     properties:
    //
    //       update:: ?(view: EditorView, prevState: EditorState)
    //       Called whenever the view's state is updated.
    //
    //       destroy:: ?()
    //       Called when the view is destroyed or receives a state
    //       with different plugins.
    //
    //   filterTransaction:: ?(Transaction, EditorState) → bool
    //   When present, this will be called before a transaction is
    //   applied by the state, allowing the plugin to cancel it (by
    //   returning false).
    //
    //   appendTransaction:: ?(transactions: [Transaction], oldState: EditorState, newState: EditorState) → ?Transaction
    //   Allows the plugin to append another transaction to be applied
    //   after the given array of transactions. When another plugin
    //   appends a transaction after this was called, it is called again
    //   with the new state and new transactions—but only the new
    //   transactions, i.e. it won't be passed transactions that it
    //   already saw.

    function bindProps(obj, self, target) {
      for (var prop in obj) {
        var val = obj[prop];
        if (val instanceof Function) { val = val.bind(self); }
        else if (prop == "handleDOMEvents") { val = bindProps(val, self, {}); }
        target[prop] = val;
      }
      return target
    }

    // ::- Plugins bundle functionality that can be added to an editor.
    // They are part of the [editor state](#state.EditorState) and
    // may influence that state and the view that contains it.
    var Plugin = function Plugin(spec) {
      // :: EditorProps
      // The [props](#view.EditorProps) exported by this plugin.
      this.props = {};
      if (spec.props) { bindProps(spec.props, this, this.props); }
      // :: Object
      // The plugin's [spec object](#state.PluginSpec).
      this.spec = spec;
      this.key = spec.key ? spec.key.key : createKey("plugin");
    };

    // :: (EditorState) → any
    // Extract the plugin's state field from an editor state.
    Plugin.prototype.getState = function getState (state) { return state[this.key] };

    // StateField:: interface<T>
    // A plugin spec may provide a state field (under its
    // [`state`](#state.PluginSpec.state) property) of this type, which
    // describes the state it wants to keep. Functions provided here are
    // always called with the plugin instance as their `this` binding.
    //
    //   init:: (config: Object, instance: EditorState) → T
    //   Initialize the value of the field. `config` will be the object
    //   passed to [`EditorState.create`](#state.EditorState^create). Note
    //   that `instance` is a half-initialized state instance, and will
    //   not have values for plugin fields initialized after this one.
    //
    //   apply:: (tr: Transaction, value: T, oldState: EditorState, newState: EditorState) → T
    //   Apply the given transaction to this state field, producing a new
    //   field value. Note that the `newState` argument is again a partially
    //   constructed state does not yet contain the state from plugins
    //   coming after this one.
    //
    //   toJSON:: ?(value: T) → *
    //   Convert this field to JSON. Optional, can be left off to disable
    //   JSON serialization for the field.
    //
    //   fromJSON:: ?(config: Object, value: *, state: EditorState) → T
    //   Deserialize the JSON representation of this field. Note that the
    //   `state` argument is again a half-initialized state.

    var keys = Object.create(null);

    function createKey(name) {
      if (name in keys) { return name + "$" + ++keys[name] }
      keys[name] = 0;
      return name + "$"
    }

    // ::- A key is used to [tag](#state.PluginSpec.key)
    // plugins in a way that makes it possible to find them, given an
    // editor state. Assigning a key does mean only one plugin of that
    // type can be active in a state.
    var PluginKey = function PluginKey(name) {
    if ( name === void 0 ) name = "key";
     this.key = createKey(name); };

    // :: (EditorState) → ?Plugin
    // Get the active plugin with this key, if any, from an editor
    // state.
    PluginKey.prototype.get = function get (state) { return state.config.pluginsByKey[this.key] };

    // :: (EditorState) → ?any
    // Get the plugin's state from an editor state.
    PluginKey.prototype.getState = function getState (state) { return state[this.key] };
    //# sourceMappingURL=index.es.js.map

    var result = {};

    if (typeof navigator != "undefined" && typeof document != "undefined") {
      var ie_edge = /Edge\/(\d+)/.exec(navigator.userAgent);
      var ie_upto10 = /MSIE \d/.test(navigator.userAgent);
      var ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);

      result.mac = /Mac/.test(navigator.platform);
      var ie = result.ie = !!(ie_upto10 || ie_11up || ie_edge);
      result.ie_version = ie_upto10 ? document.documentMode || 6 : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : null;
      result.gecko = !ie && /gecko\/(\d+)/i.test(navigator.userAgent);
      result.gecko_version = result.gecko && +(/Firefox\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1];
      var chrome = !ie && /Chrome\/(\d+)/.exec(navigator.userAgent);
      result.chrome = !!chrome;
      result.chrome_version = chrome && +chrome[1];
      // Is true for both iOS and iPadOS for convenience
      result.safari = !ie && /Apple Computer/.test(navigator.vendor);
      result.ios = result.safari && (/Mobile\/\w+/.test(navigator.userAgent) || navigator.maxTouchPoints > 2);
      result.android = /Android \d/.test(navigator.userAgent);
      result.webkit = "webkitFontSmoothing" in document.documentElement.style;
      result.webkit_version = result.webkit && +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1];
    }

    var domIndex = function(node) {
      for (var index = 0;; index++) {
        node = node.previousSibling;
        if (!node) { return index }
      }
    };

    var parentNode = function(node) {
      var parent = node.parentNode;
      return parent && parent.nodeType == 11 ? parent.host : parent
    };

    var reusedRange = null;

    // Note that this will always return the same range, because DOM range
    // objects are every expensive, and keep slowing down subsequent DOM
    // updates, for some reason.
    var textRange = function(node, from, to) {
      var range = reusedRange || (reusedRange = document.createRange());
      range.setEnd(node, to == null ? node.nodeValue.length : to);
      range.setStart(node, from || 0);
      return range
    };

    // Scans forward and backward through DOM positions equivalent to the
    // given one to see if the two are in the same place (i.e. after a
    // text node vs at the end of that text node)
    var isEquivalentPosition = function(node, off, targetNode, targetOff) {
      return targetNode && (scanFor(node, off, targetNode, targetOff, -1) ||
                            scanFor(node, off, targetNode, targetOff, 1))
    };

    var atomElements = /^(img|br|input|textarea|hr)$/i;

    function scanFor(node, off, targetNode, targetOff, dir) {
      for (;;) {
        if (node == targetNode && off == targetOff) { return true }
        if (off == (dir < 0 ? 0 : nodeSize(node))) {
          var parent = node.parentNode;
          if (parent.nodeType != 1 || hasBlockDesc(node) || atomElements.test(node.nodeName) || node.contentEditable == "false")
            { return false }
          off = domIndex(node) + (dir < 0 ? 0 : 1);
          node = parent;
        } else if (node.nodeType == 1) {
          node = node.childNodes[off + (dir < 0 ? -1 : 0)];
          if (node.contentEditable == "false") { return false }
          off = dir < 0 ? nodeSize(node) : 0;
        } else {
          return false
        }
      }
    }

    function nodeSize(node) {
      return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length
    }

    function isOnEdge(node, offset, parent) {
      for (var atStart = offset == 0, atEnd = offset == nodeSize(node); atStart || atEnd;) {
        if (node == parent) { return true }
        var index = domIndex(node);
        node = node.parentNode;
        if (!node) { return false }
        atStart = atStart && index == 0;
        atEnd = atEnd && index == nodeSize(node);
      }
    }

    function hasBlockDesc(dom) {
      var desc;
      for (var cur = dom; cur; cur = cur.parentNode) { if (desc = cur.pmViewDesc) { break } }
      return desc && desc.node && desc.node.isBlock && (desc.dom == dom || desc.contentDOM == dom)
    }

    // Work around Chrome issue https://bugs.chromium.org/p/chromium/issues/detail?id=447523
    // (isCollapsed inappropriately returns true in shadow dom)
    var selectionCollapsed = function(domSel) {
      var collapsed = domSel.isCollapsed;
      if (collapsed && result.chrome && domSel.rangeCount && !domSel.getRangeAt(0).collapsed)
        { collapsed = false; }
      return collapsed
    };

    function keyEvent(keyCode, key) {
      var event = document.createEvent("Event");
      event.initEvent("keydown", true, true);
      event.keyCode = keyCode;
      event.key = event.code = key;
      return event
    }

    function windowRect(doc) {
      return {left: 0, right: doc.documentElement.clientWidth,
              top: 0, bottom: doc.documentElement.clientHeight}
    }

    function getSide(value, side) {
      return typeof value == "number" ? value : value[side]
    }

    function clientRect(node) {
      var rect = node.getBoundingClientRect();
      // Make sure scrollbar width isn't included in the rectangle
      return {left: rect.left, right: rect.left + node.clientWidth,
              top: rect.top, bottom: rect.top + node.clientHeight}
    }

    function scrollRectIntoView(view, rect, startDOM) {
      var scrollThreshold = view.someProp("scrollThreshold") || 0, scrollMargin = view.someProp("scrollMargin") || 5;
      var doc = view.dom.ownerDocument;
      for (var parent = startDOM || view.dom;; parent = parentNode(parent)) {
        if (!parent) { break }
        if (parent.nodeType != 1) { continue }
        var atTop = parent == doc.body || parent.nodeType != 1;
        var bounding = atTop ? windowRect(doc) : clientRect(parent);
        var moveX = 0, moveY = 0;
        if (rect.top < bounding.top + getSide(scrollThreshold, "top"))
          { moveY = -(bounding.top - rect.top + getSide(scrollMargin, "top")); }
        else if (rect.bottom > bounding.bottom - getSide(scrollThreshold, "bottom"))
          { moveY = rect.bottom - bounding.bottom + getSide(scrollMargin, "bottom"); }
        if (rect.left < bounding.left + getSide(scrollThreshold, "left"))
          { moveX = -(bounding.left - rect.left + getSide(scrollMargin, "left")); }
        else if (rect.right > bounding.right - getSide(scrollThreshold, "right"))
          { moveX = rect.right - bounding.right + getSide(scrollMargin, "right"); }
        if (moveX || moveY) {
          if (atTop) {
            doc.defaultView.scrollBy(moveX, moveY);
          } else {
            var startX = parent.scrollLeft, startY = parent.scrollTop;
            if (moveY) { parent.scrollTop += moveY; }
            if (moveX) { parent.scrollLeft += moveX; }
            var dX = parent.scrollLeft - startX, dY = parent.scrollTop - startY;
            rect = {left: rect.left - dX, top: rect.top - dY, right: rect.right - dX, bottom: rect.bottom - dY};
          }
        }
        if (atTop) { break }
      }
    }

    // Store the scroll position of the editor's parent nodes, along with
    // the top position of an element near the top of the editor, which
    // will be used to make sure the visible viewport remains stable even
    // when the size of the content above changes.
    function storeScrollPos(view) {
      var rect = view.dom.getBoundingClientRect(), startY = Math.max(0, rect.top);
      var refDOM, refTop;
      for (var x = (rect.left + rect.right) / 2, y = startY + 1;
           y < Math.min(innerHeight, rect.bottom); y += 5) {
        var dom = view.root.elementFromPoint(x, y);
        if (dom == view.dom || !view.dom.contains(dom)) { continue }
        var localRect = dom.getBoundingClientRect();
        if (localRect.top >= startY - 20) {
          refDOM = dom;
          refTop = localRect.top;
          break
        }
      }
      return {refDOM: refDOM, refTop: refTop, stack: scrollStack(view.dom)}
    }

    function scrollStack(dom) {
      var stack = [], doc = dom.ownerDocument;
      for (; dom; dom = parentNode(dom)) {
        stack.push({dom: dom, top: dom.scrollTop, left: dom.scrollLeft});
        if (dom == doc) { break }
      }
      return stack
    }

    // Reset the scroll position of the editor's parent nodes to that what
    // it was before, when storeScrollPos was called.
    function resetScrollPos(ref) {
      var refDOM = ref.refDOM;
      var refTop = ref.refTop;
      var stack = ref.stack;

      var newRefTop = refDOM ? refDOM.getBoundingClientRect().top : 0;
      restoreScrollStack(stack, newRefTop == 0 ? 0 : newRefTop - refTop);
    }

    function restoreScrollStack(stack, dTop) {
      for (var i = 0; i < stack.length; i++) {
        var ref = stack[i];
        var dom = ref.dom;
        var top = ref.top;
        var left = ref.left;
        if (dom.scrollTop != top + dTop) { dom.scrollTop = top + dTop; }
        if (dom.scrollLeft != left) { dom.scrollLeft = left; }
      }
    }

    var preventScrollSupported = null;
    // Feature-detects support for .focus({preventScroll: true}), and uses
    // a fallback kludge when not supported.
    function focusPreventScroll(dom) {
      if (dom.setActive) { return dom.setActive() } // in IE
      if (preventScrollSupported) { return dom.focus(preventScrollSupported) }

      var stored = scrollStack(dom);
      dom.focus(preventScrollSupported == null ? {
        get preventScroll() {
          preventScrollSupported = {preventScroll: true};
          return true
        }
      } : undefined);
      if (!preventScrollSupported) {
        preventScrollSupported = false;
        restoreScrollStack(stored, 0);
      }
    }

    function findOffsetInNode(node, coords) {
      var closest, dxClosest = 2e8, coordsClosest, offset = 0;
      var rowBot = coords.top, rowTop = coords.top;
      for (var child = node.firstChild, childIndex = 0; child; child = child.nextSibling, childIndex++) {
        var rects = (void 0);
        if (child.nodeType == 1) { rects = child.getClientRects(); }
        else if (child.nodeType == 3) { rects = textRange(child).getClientRects(); }
        else { continue }

        for (var i = 0; i < rects.length; i++) {
          var rect = rects[i];
          if (rect.top <= rowBot && rect.bottom >= rowTop) {
            rowBot = Math.max(rect.bottom, rowBot);
            rowTop = Math.min(rect.top, rowTop);
            var dx = rect.left > coords.left ? rect.left - coords.left
                : rect.right < coords.left ? coords.left - rect.right : 0;
            if (dx < dxClosest) {
              closest = child;
              dxClosest = dx;
              coordsClosest = dx && closest.nodeType == 3 ? {left: rect.right < coords.left ? rect.right : rect.left, top: coords.top} : coords;
              if (child.nodeType == 1 && dx)
                { offset = childIndex + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0); }
              continue
            }
          }
          if (!closest && (coords.left >= rect.right && coords.top >= rect.top ||
                           coords.left >= rect.left && coords.top >= rect.bottom))
            { offset = childIndex + 1; }
        }
      }
      if (closest && closest.nodeType == 3) { return findOffsetInText(closest, coordsClosest) }
      if (!closest || (dxClosest && closest.nodeType == 1)) { return {node: node, offset: offset} }
      return findOffsetInNode(closest, coordsClosest)
    }

    function findOffsetInText(node, coords) {
      var len = node.nodeValue.length;
      var range = document.createRange();
      for (var i = 0; i < len; i++) {
        range.setEnd(node, i + 1);
        range.setStart(node, i);
        var rect = singleRect(range, 1);
        if (rect.top == rect.bottom) { continue }
        if (inRect(coords, rect))
          { return {node: node, offset: i + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0)} }
      }
      return {node: node, offset: 0}
    }

    function inRect(coords, rect) {
      return coords.left >= rect.left - 1 && coords.left <= rect.right + 1&&
        coords.top >= rect.top - 1 && coords.top <= rect.bottom + 1
    }

    function targetKludge(dom, coords) {
      var parent = dom.parentNode;
      if (parent && /^li$/i.test(parent.nodeName) && coords.left < dom.getBoundingClientRect().left)
        { return parent }
      return dom
    }

    function posFromElement(view, elt, coords) {
      var ref = findOffsetInNode(elt, coords);
      var node = ref.node;
      var offset = ref.offset;
      var bias = -1;
      if (node.nodeType == 1 && !node.firstChild) {
        var rect = node.getBoundingClientRect();
        bias = rect.left != rect.right && coords.left > (rect.left + rect.right) / 2 ? 1 : -1;
      }
      return view.docView.posFromDOM(node, offset, bias)
    }

    function posFromCaret(view, node, offset, coords) {
      // Browser (in caretPosition/RangeFromPoint) will agressively
      // normalize towards nearby inline nodes. Since we are interested in
      // positions between block nodes too, we first walk up the hierarchy
      // of nodes to see if there are block nodes that the coordinates
      // fall outside of. If so, we take the position before/after that
      // block. If not, we call `posFromDOM` on the raw node/offset.
      var outside = -1;
      for (var cur = node;;) {
        if (cur == view.dom) { break }
        var desc = view.docView.nearestDesc(cur, true);
        if (!desc) { return null }
        if (desc.node.isBlock && desc.parent) {
          var rect = desc.dom.getBoundingClientRect();
          if (rect.left > coords.left || rect.top > coords.top) { outside = desc.posBefore; }
          else if (rect.right < coords.left || rect.bottom < coords.top) { outside = desc.posAfter; }
          else { break }
        }
        cur = desc.dom.parentNode;
      }
      return outside > -1 ? outside : view.docView.posFromDOM(node, offset)
    }

    function elementFromPoint(element, coords, box) {
      var len = element.childNodes.length;
      if (len && box.top < box.bottom) {
        for (var startI = Math.max(0, Math.min(len - 1, Math.floor(len * (coords.top - box.top) / (box.bottom - box.top)) - 2)), i = startI;;) {
          var child = element.childNodes[i];
          if (child.nodeType == 1) {
            var rects = child.getClientRects();
            for (var j = 0; j < rects.length; j++) {
              var rect = rects[j];
              if (inRect(coords, rect)) { return elementFromPoint(child, coords, rect) }
            }
          }
          if ((i = (i + 1) % len) == startI) { break }
        }
      }
      return element
    }

    // Given an x,y position on the editor, get the position in the document.
    function posAtCoords(view, coords) {
      var assign, assign$1;

      var root = view.root, node, offset;
      if (root.caretPositionFromPoint) {
        try { // Firefox throws for this call in hard-to-predict circumstances (#994)
          var pos$1 = root.caretPositionFromPoint(coords.left, coords.top);
          if (pos$1) { ((assign = pos$1, node = assign.offsetNode, offset = assign.offset)); }
        } catch (_) {}
      }
      if (!node && root.caretRangeFromPoint) {
        var range = root.caretRangeFromPoint(coords.left, coords.top);
        if (range) { ((assign$1 = range, node = assign$1.startContainer, offset = assign$1.startOffset)); }
      }

      var elt = root.elementFromPoint(coords.left, coords.top + 1), pos;
      if (!elt || !view.dom.contains(elt.nodeType != 1 ? elt.parentNode : elt)) {
        var box = view.dom.getBoundingClientRect();
        if (!inRect(coords, box)) { return null }
        elt = elementFromPoint(view.dom, coords, box);
        if (!elt) { return null }
      }
      // Safari's caretRangeFromPoint returns nonsense when on a draggable element
      if (result.safari && elt.draggable) { node = offset = null; }
      elt = targetKludge(elt, coords);
      if (node) {
        if (result.gecko && node.nodeType == 1) {
          // Firefox will sometimes return offsets into <input> nodes, which
          // have no actual children, from caretPositionFromPoint (#953)
          offset = Math.min(offset, node.childNodes.length);
          // It'll also move the returned position before image nodes,
          // even if those are behind it.
          if (offset < node.childNodes.length) {
            var next = node.childNodes[offset], box$1;
            if (next.nodeName == "IMG" && (box$1 = next.getBoundingClientRect()).right <= coords.left &&
                box$1.bottom > coords.top)
              { offset++; }
          }
        }
        // Suspiciously specific kludge to work around caret*FromPoint
        // never returning a position at the end of the document
        if (node == view.dom && offset == node.childNodes.length - 1 && node.lastChild.nodeType == 1 &&
            coords.top > node.lastChild.getBoundingClientRect().bottom)
          { pos = view.state.doc.content.size; }
        // Ignore positions directly after a BR, since caret*FromPoint
        // 'round up' positions that would be more accurately placed
        // before the BR node.
        else if (offset == 0 || node.nodeType != 1 || node.childNodes[offset - 1].nodeName != "BR")
          { pos = posFromCaret(view, node, offset, coords); }
      }
      if (pos == null) { pos = posFromElement(view, elt, coords); }

      var desc = view.docView.nearestDesc(elt, true);
      return {pos: pos, inside: desc ? desc.posAtStart - desc.border : -1}
    }

    function singleRect(object, bias) {
      var rects = object.getClientRects();
      return !rects.length ? object.getBoundingClientRect() : rects[bias < 0 ? 0 : rects.length - 1]
    }

    var BIDI = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;

    // : (EditorView, number, number) → {left: number, top: number, right: number, bottom: number}
    // Given a position in the document model, get a bounding box of the
    // character at that position, relative to the window.
    function coordsAtPos(view, pos, side) {
      var ref = view.docView.domFromPos(pos, side < 0 ? -1 : 1);
      var node = ref.node;
      var offset = ref.offset;

      var supportEmptyRange = result.webkit || result.gecko;
      if (node.nodeType == 3) {
        // These browsers support querying empty text ranges. Prefer that in
        // bidi context or when at the end of a node.
        if (supportEmptyRange && (BIDI.test(node.nodeValue) || (side < 0 ? !offset : offset == node.nodeValue.length))) {
          var rect = singleRect(textRange(node, offset, offset), side);
          // Firefox returns bad results (the position before the space)
          // when querying a position directly after line-broken
          // whitespace. Detect this situation and and kludge around it
          if (result.gecko && offset && /\s/.test(node.nodeValue[offset - 1]) && offset < node.nodeValue.length) {
            var rectBefore = singleRect(textRange(node, offset - 1, offset - 1), -1);
            if (rectBefore.top == rect.top) {
              var rectAfter = singleRect(textRange(node, offset, offset + 1), -1);
              if (rectAfter.top != rect.top)
                { return flattenV(rectAfter, rectAfter.left < rectBefore.left) }
            }
          }
          return rect
        } else {
          var from = offset, to = offset, takeSide = side < 0 ? 1 : -1;
          if (side < 0 && !offset) { to++; takeSide = -1; }
          else if (side >= 0 && offset == node.nodeValue.length) { from--; takeSide = 1; }
          else if (side < 0) { from--; }
          else { to ++; }
          return flattenV(singleRect(textRange(node, from, to), takeSide), takeSide < 0)
        }
      }

      // Return a horizontal line in block context
      if (!view.state.doc.resolve(pos).parent.inlineContent) {
        if (offset && (side < 0 || offset == nodeSize(node))) {
          var before = node.childNodes[offset - 1];
          if (before.nodeType == 1) { return flattenH(before.getBoundingClientRect(), false) }
        }
        if (offset < nodeSize(node)) {
          var after = node.childNodes[offset];
          if (after.nodeType == 1) { return flattenH(after.getBoundingClientRect(), true) }
        }
        return flattenH(node.getBoundingClientRect(), side >= 0)
      }

      // Inline, not in text node (this is not Bidi-safe)
      if (offset && (side < 0 || offset == nodeSize(node))) {
        var before$1 = node.childNodes[offset - 1];
        var target = before$1.nodeType == 3 ? textRange(before$1, nodeSize(before$1) - (supportEmptyRange ? 0 : 1))
            // BR nodes tend to only return the rectangle before them.
            // Only use them if they are the last element in their parent
            : before$1.nodeType == 1 && (before$1.nodeName != "BR" || !before$1.nextSibling) ? before$1 : null;
        if (target) { return flattenV(singleRect(target, 1), false) }
      }
      if (offset < nodeSize(node)) {
        var after$1 = node.childNodes[offset];
        var target$1 = after$1.nodeType == 3 ? textRange(after$1, 0, (supportEmptyRange ? 0 : 1))
            : after$1.nodeType == 1 ? after$1 : null;
        if (target$1) { return flattenV(singleRect(target$1, -1), true) }
      }
      // All else failed, just try to get a rectangle for the target node
      return flattenV(singleRect(node.nodeType == 3 ? textRange(node) : node, -side), side >= 0)
    }

    function flattenV(rect, left) {
      if (rect.width == 0) { return rect }
      var x = left ? rect.left : rect.right;
      return {top: rect.top, bottom: rect.bottom, left: x, right: x}
    }

    function flattenH(rect, top) {
      if (rect.height == 0) { return rect }
      var y = top ? rect.top : rect.bottom;
      return {top: y, bottom: y, left: rect.left, right: rect.right}
    }

    function withFlushedState(view, state, f) {
      var viewState = view.state, active = view.root.activeElement;
      if (viewState != state) { view.updateState(state); }
      if (active != view.dom) { view.focus(); }
      try {
        return f()
      } finally {
        if (viewState != state) { view.updateState(viewState); }
        if (active != view.dom && active) { active.focus(); }
      }
    }

    // : (EditorView, number, number)
    // Whether vertical position motion in a given direction
    // from a position would leave a text block.
    function endOfTextblockVertical(view, state, dir) {
      var sel = state.selection;
      var $pos = dir == "up" ? sel.$from : sel.$to;
      return withFlushedState(view, state, function () {
        var ref = view.docView.domFromPos($pos.pos, dir == "up" ? -1 : 1);
        var dom = ref.node;
        for (;;) {
          var nearest = view.docView.nearestDesc(dom, true);
          if (!nearest) { break }
          if (nearest.node.isBlock) { dom = nearest.dom; break }
          dom = nearest.dom.parentNode;
        }
        var coords = coordsAtPos(view, $pos.pos, 1);
        for (var child = dom.firstChild; child; child = child.nextSibling) {
          var boxes = (void 0);
          if (child.nodeType == 1) { boxes = child.getClientRects(); }
          else if (child.nodeType == 3) { boxes = textRange(child, 0, child.nodeValue.length).getClientRects(); }
          else { continue }
          for (var i = 0; i < boxes.length; i++) {
            var box = boxes[i];
            if (box.bottom > box.top && (dir == "up" ? box.bottom < coords.top + 1 : box.top > coords.bottom - 1))
              { return false }
          }
        }
        return true
      })
    }

    var maybeRTL = /[\u0590-\u08ac]/;

    function endOfTextblockHorizontal(view, state, dir) {
      var ref = state.selection;
      var $head = ref.$head;
      if (!$head.parent.isTextblock) { return false }
      var offset = $head.parentOffset, atStart = !offset, atEnd = offset == $head.parent.content.size;
      var sel = getSelection();
      // If the textblock is all LTR, or the browser doesn't support
      // Selection.modify (Edge), fall back to a primitive approach
      if (!maybeRTL.test($head.parent.textContent) || !sel.modify)
        { return dir == "left" || dir == "backward" ? atStart : atEnd }

      return withFlushedState(view, state, function () {
        // This is a huge hack, but appears to be the best we can
        // currently do: use `Selection.modify` to move the selection by
        // one character, and see if that moves the cursor out of the
        // textblock (or doesn't move it at all, when at the start/end of
        // the document).
        var oldRange = sel.getRangeAt(0), oldNode = sel.focusNode, oldOff = sel.focusOffset;
        var oldBidiLevel = sel.caretBidiLevel; // Only for Firefox
        sel.modify("move", dir, "character");
        var parentDOM = $head.depth ? view.docView.domAfterPos($head.before()) : view.dom;
        var result = !parentDOM.contains(sel.focusNode.nodeType == 1 ? sel.focusNode : sel.focusNode.parentNode) ||
            (oldNode == sel.focusNode && oldOff == sel.focusOffset);
        // Restore the previous selection
        sel.removeAllRanges();
        sel.addRange(oldRange);
        if (oldBidiLevel != null) { sel.caretBidiLevel = oldBidiLevel; }
        return result
      })
    }

    var cachedState = null, cachedDir = null, cachedResult = false;
    function endOfTextblock(view, state, dir) {
      if (cachedState == state && cachedDir == dir) { return cachedResult }
      cachedState = state; cachedDir = dir;
      return cachedResult = dir == "up" || dir == "down"
        ? endOfTextblockVertical(view, state, dir)
        : endOfTextblockHorizontal(view, state, dir)
    }

    // NodeView:: interface
    //
    // By default, document nodes are rendered using the result of the
    // [`toDOM`](#model.NodeSpec.toDOM) method of their spec, and managed
    // entirely by the editor. For some use cases, such as embedded
    // node-specific editing interfaces, you want more control over
    // the behavior of a node's in-editor representation, and need to
    // [define](#view.EditorProps.nodeViews) a custom node view.
    //
    // Mark views only support `dom` and `contentDOM`, and don't support
    // any of the node view methods.
    //
    // Objects returned as node views must conform to this interface.
    //
    //   dom:: ?dom.Node
    //   The outer DOM node that represents the document node. When not
    //   given, the default strategy is used to create a DOM node.
    //
    //   contentDOM:: ?dom.Node
    //   The DOM node that should hold the node's content. Only meaningful
    //   if the node view also defines a `dom` property and if its node
    //   type is not a leaf node type. When this is present, ProseMirror
    //   will take care of rendering the node's children into it. When it
    //   is not present, the node view itself is responsible for rendering
    //   (or deciding not to render) its child nodes.
    //
    //   update:: ?(node: Node, decorations: [Decoration]) → bool
    //   When given, this will be called when the view is updating itself.
    //   It will be given a node (possibly of a different type), and an
    //   array of active decorations (which are automatically drawn, and
    //   the node view may ignore if it isn't interested in them), and
    //   should return true if it was able to update to that node, and
    //   false otherwise. If the node view has a `contentDOM` property (or
    //   no `dom` property), updating its child nodes will be handled by
    //   ProseMirror.
    //
    //   selectNode:: ?()
    //   Can be used to override the way the node's selected status (as a
    //   node selection) is displayed.
    //
    //   deselectNode:: ?()
    //   When defining a `selectNode` method, you should also provide a
    //   `deselectNode` method to remove the effect again.
    //
    //   setSelection:: ?(anchor: number, head: number, root: dom.Document)
    //   This will be called to handle setting the selection inside the
    //   node. The `anchor` and `head` positions are relative to the start
    //   of the node. By default, a DOM selection will be created between
    //   the DOM positions corresponding to those positions, but if you
    //   override it you can do something else.
    //
    //   stopEvent:: ?(event: dom.Event) → bool
    //   Can be used to prevent the editor view from trying to handle some
    //   or all DOM events that bubble up from the node view. Events for
    //   which this returns true are not handled by the editor.
    //
    //   ignoreMutation:: ?(dom.MutationRecord) → bool
    //   Called when a DOM
    //   [mutation](https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver)
    //   or a selection change happens within the view. When the change is
    //   a selection change, the record will have a `type` property of
    //   `"selection"` (which doesn't occur for native mutation records).
    //   Return false if the editor should re-read the selection or
    //   re-parse the range around the mutation, true if it can safely be
    //   ignored.
    //
    //   destroy:: ?()
    //   Called when the node view is removed from the editor or the whole
    //   editor is destroyed. (Not available for marks.)

    // View descriptions are data structures that describe the DOM that is
    // used to represent the editor's content. They are used for:
    //
    // - Incremental redrawing when the document changes
    //
    // - Figuring out what part of the document a given DOM position
    //   corresponds to
    //
    // - Wiring in custom implementations of the editing interface for a
    //   given node
    //
    // They form a doubly-linked mutable tree, starting at `view.docView`.

    var NOT_DIRTY = 0, CHILD_DIRTY = 1, CONTENT_DIRTY = 2, NODE_DIRTY = 3;

    // Superclass for the various kinds of descriptions. Defines their
    // basic structure and shared methods.
    var ViewDesc = function ViewDesc(parent, children, dom, contentDOM) {
      this.parent = parent;
      this.children = children;
      this.dom = dom;
      // An expando property on the DOM node provides a link back to its
      // description.
      dom.pmViewDesc = this;
      // This is the node that holds the child views. It may be null for
      // descs that don't have children.
      this.contentDOM = contentDOM;
      this.dirty = NOT_DIRTY;
    };

    var prototypeAccessors$9 = { beforePosition: { configurable: true },size: { configurable: true },border: { configurable: true },posBefore: { configurable: true },posAtStart: { configurable: true },posAfter: { configurable: true },posAtEnd: { configurable: true },contentLost: { configurable: true },domAtom: { configurable: true } };

    // Used to check whether a given description corresponds to a
    // widget/mark/node.
    ViewDesc.prototype.matchesWidget = function matchesWidget () { return false };
    ViewDesc.prototype.matchesMark = function matchesMark () { return false };
    ViewDesc.prototype.matchesNode = function matchesNode () { return false };
    ViewDesc.prototype.matchesHack = function matchesHack () { return false };

    prototypeAccessors$9.beforePosition.get = function () { return false };

    // : () → ?ParseRule
    // When parsing in-editor content (in domchange.js), we allow
    // descriptions to determine the parse rules that should be used to
    // parse them.
    ViewDesc.prototype.parseRule = function parseRule () { return null };

    // : (dom.Event) → bool
    // Used by the editor's event handler to ignore events that come
    // from certain descs.
    ViewDesc.prototype.stopEvent = function stopEvent () { return false };

    // The size of the content represented by this desc.
    prototypeAccessors$9.size.get = function () {
      var size = 0;
      for (var i = 0; i < this.children.length; i++) { size += this.children[i].size; }
      return size
    };

    // For block nodes, this represents the space taken up by their
    // start/end tokens.
    prototypeAccessors$9.border.get = function () { return 0 };

    ViewDesc.prototype.destroy = function destroy () {
      this.parent = null;
      if (this.dom.pmViewDesc == this) { this.dom.pmViewDesc = null; }
      for (var i = 0; i < this.children.length; i++)
        { this.children[i].destroy(); }
    };

    ViewDesc.prototype.posBeforeChild = function posBeforeChild (child) {
      for (var i = 0, pos = this.posAtStart; i < this.children.length; i++) {
        var cur = this.children[i];
        if (cur == child) { return pos }
        pos += cur.size;
      }
    };

    prototypeAccessors$9.posBefore.get = function () {
      return this.parent.posBeforeChild(this)
    };

    prototypeAccessors$9.posAtStart.get = function () {
      return this.parent ? this.parent.posBeforeChild(this) + this.border : 0
    };

    prototypeAccessors$9.posAfter.get = function () {
      return this.posBefore + this.size
    };

    prototypeAccessors$9.posAtEnd.get = function () {
      return this.posAtStart + this.size - 2 * this.border
    };

    // : (dom.Node, number, ?number) → number
    ViewDesc.prototype.localPosFromDOM = function localPosFromDOM (dom, offset, bias) {
      // If the DOM position is in the content, use the child desc after
      // it to figure out a position.
      if (this.contentDOM && this.contentDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode)) {
        if (bias < 0) {
          var domBefore, desc;
          if (dom == this.contentDOM) {
            domBefore = dom.childNodes[offset - 1];
          } else {
            while (dom.parentNode != this.contentDOM) { dom = dom.parentNode; }
            domBefore = dom.previousSibling;
          }
          while (domBefore && !((desc = domBefore.pmViewDesc) && desc.parent == this)) { domBefore = domBefore.previousSibling; }
          return domBefore ? this.posBeforeChild(desc) + desc.size : this.posAtStart
        } else {
          var domAfter, desc$1;
          if (dom == this.contentDOM) {
            domAfter = dom.childNodes[offset];
          } else {
            while (dom.parentNode != this.contentDOM) { dom = dom.parentNode; }
            domAfter = dom.nextSibling;
          }
          while (domAfter && !((desc$1 = domAfter.pmViewDesc) && desc$1.parent == this)) { domAfter = domAfter.nextSibling; }
          return domAfter ? this.posBeforeChild(desc$1) : this.posAtEnd
        }
      }
      // Otherwise, use various heuristics, falling back on the bias
      // parameter, to determine whether to return the position at the
      // start or at the end of this view desc.
      var atEnd;
      if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM)) {
        atEnd = dom.compareDocumentPosition(this.contentDOM) & 2;
      } else if (this.dom.firstChild) {
        if (offset == 0) { for (var search = dom;; search = search.parentNode) {
          if (search == this.dom) { atEnd = false; break }
          if (search.parentNode.firstChild != search) { break }
        } }
        if (atEnd == null && offset == dom.childNodes.length) { for (var search$1 = dom;; search$1 = search$1.parentNode) {
          if (search$1 == this.dom) { atEnd = true; break }
          if (search$1.parentNode.lastChild != search$1) { break }
        } }
      }
      return (atEnd == null ? bias > 0 : atEnd) ? this.posAtEnd : this.posAtStart
    };

    // Scan up the dom finding the first desc that is a descendant of
    // this one.
    ViewDesc.prototype.nearestDesc = function nearestDesc (dom, onlyNodes) {
      for (var first = true, cur = dom; cur; cur = cur.parentNode) {
        var desc = this.getDesc(cur);
        if (desc && (!onlyNodes || desc.node)) {
          // If dom is outside of this desc's nodeDOM, don't count it.
          if (first && desc.nodeDOM &&
              !(desc.nodeDOM.nodeType == 1 ? desc.nodeDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode) : desc.nodeDOM == dom))
            { first = false; }
          else
            { return desc }
        }
      }
    };

    ViewDesc.prototype.getDesc = function getDesc (dom) {
      var desc = dom.pmViewDesc;
      for (var cur = desc; cur; cur = cur.parent) { if (cur == this) { return desc } }
    };

    ViewDesc.prototype.posFromDOM = function posFromDOM (dom, offset, bias) {
      for (var scan = dom; scan; scan = scan.parentNode) {
        var desc = this.getDesc(scan);
        if (desc) { return desc.localPosFromDOM(dom, offset, bias) }
      }
      return -1
    };

    // : (number) → ?NodeViewDesc
    // Find the desc for the node after the given pos, if any. (When a
    // parent node overrode rendering, there might not be one.)
    ViewDesc.prototype.descAt = function descAt (pos) {
      for (var i = 0, offset = 0; i < this.children.length; i++) {
        var child = this.children[i], end = offset + child.size;
        if (offset == pos && end != offset) {
          while (!child.border && child.children.length) { child = child.children[0]; }
          return child
        }
        if (pos < end) { return child.descAt(pos - offset - child.border) }
        offset = end;
      }
    };

    // : (number, number) → {node: dom.Node, offset: number}
    ViewDesc.prototype.domFromPos = function domFromPos (pos, side) {
      if (!this.contentDOM) { return {node: this.dom, offset: 0} }
      for (var offset = 0, i = 0, first = true;; i++, first = false) {
        // Skip removed or always-before children
        while (i < this.children.length && (this.children[i].beforePosition ||
                                            this.children[i].dom.parentNode != this.contentDOM))
          { offset += this.children[i++].size; }
        var child = i == this.children.length ? null : this.children[i];
        if (offset == pos && (side == 0 || !child || !child.size || child.border || (side < 0 && first)) ||
            child && child.domAtom && pos < offset + child.size) { return {
          node: this.contentDOM,
          offset: child ? domIndex(child.dom) : this.contentDOM.childNodes.length
        } }
        if (!child) { throw new Error("Invalid position " + pos) }
        var end = offset + child.size;
        if (!child.domAtom && (side < 0 && !child.border ? end >= pos : end > pos))
          { return child.domFromPos(pos - offset - child.border, side) }
        offset = end;
      }
    };

    // Used to find a DOM range in a single parent for a given changed
    // range.
    ViewDesc.prototype.parseRange = function parseRange (from, to, base) {
        if ( base === void 0 ) base = 0;

      if (this.children.length == 0)
        { return {node: this.contentDOM, from: from, to: to, fromOffset: 0, toOffset: this.contentDOM.childNodes.length} }

      var fromOffset = -1, toOffset = -1;
      for (var offset = base, i = 0;; i++) {
        var child = this.children[i], end = offset + child.size;
        if (fromOffset == -1 && from <= end) {
          var childBase = offset + child.border;
          // FIXME maybe descend mark views to parse a narrower range?
          if (from >= childBase && to <= end - child.border && child.node &&
              child.contentDOM && this.contentDOM.contains(child.contentDOM))
            { return child.parseRange(from, to, childBase) }

          from = offset;
          for (var j = i; j > 0; j--) {
            var prev = this.children[j - 1];
            if (prev.size && prev.dom.parentNode == this.contentDOM && !prev.emptyChildAt(1)) {
              fromOffset = domIndex(prev.dom) + 1;
              break
            }
            from -= prev.size;
          }
          if (fromOffset == -1) { fromOffset = 0; }
        }
        if (fromOffset > -1 && (end > to || i == this.children.length - 1)) {
          to = end;
          for (var j$1 = i + 1; j$1 < this.children.length; j$1++) {
            var next = this.children[j$1];
            if (next.size && next.dom.parentNode == this.contentDOM && !next.emptyChildAt(-1)) {
              toOffset = domIndex(next.dom);
              break
            }
            to += next.size;
          }
          if (toOffset == -1) { toOffset = this.contentDOM.childNodes.length; }
          break
        }
        offset = end;
      }
      return {node: this.contentDOM, from: from, to: to, fromOffset: fromOffset, toOffset: toOffset}
    };

    ViewDesc.prototype.emptyChildAt = function emptyChildAt (side) {
      if (this.border || !this.contentDOM || !this.children.length) { return false }
      var child = this.children[side < 0 ? 0 : this.children.length - 1];
      return child.size == 0 || child.emptyChildAt(side)
    };

    // : (number) → dom.Node
    ViewDesc.prototype.domAfterPos = function domAfterPos (pos) {
      var ref = this.domFromPos(pos, 0);
        var node = ref.node;
        var offset = ref.offset;
      if (node.nodeType != 1 || offset == node.childNodes.length)
        { throw new RangeError("No node after pos " + pos) }
      return node.childNodes[offset]
    };

    // : (number, number, dom.Document)
    // View descs are responsible for setting any selection that falls
    // entirely inside of them, so that custom implementations can do
    // custom things with the selection. Note that this falls apart when
    // a selection starts in such a node and ends in another, in which
    // case we just use whatever domFromPos produces as a best effort.
    ViewDesc.prototype.setSelection = function setSelection (anchor, head, root, force) {
      // If the selection falls entirely in a child, give it to that child
      var from = Math.min(anchor, head), to = Math.max(anchor, head);
      for (var i = 0, offset = 0; i < this.children.length; i++) {
        var child = this.children[i], end = offset + child.size;
        if (from > offset && to < end)
          { return child.setSelection(anchor - offset - child.border, head - offset - child.border, root, force) }
        offset = end;
      }

      var anchorDOM = this.domFromPos(anchor, anchor ? -1 : 1);
      var headDOM = head == anchor ? anchorDOM : this.domFromPos(head, head ? -1 : 1);
      var domSel = root.getSelection();

      var brKludge = false;
      // On Firefox, using Selection.collapse to put the cursor after a
      // BR node for some reason doesn't always work (#1073). On Safari,
      // the cursor sometimes inexplicable visually lags behind its
      // reported position in such situations (#1092).
      if ((result.gecko || result.safari) && anchor == head) {
        var node = anchorDOM.node;
          var offset$1 = anchorDOM.offset;
        if (node.nodeType == 3) {
          brKludge = offset$1 && node.nodeValue[offset$1 - 1] == "\n";
          // Issue #1128
          if (brKludge && offset$1 == node.nodeValue.length &&
              node.nextSibling && node.nextSibling.nodeName == "BR")
            { anchorDOM = headDOM = {node: node.parentNode, offset: domIndex(node) + 1}; }
        } else {
          var prev = node.childNodes[offset$1 - 1];
          brKludge = prev && (prev.nodeName == "BR" || prev.contentEditable == "false");
        }
      }

      if (!(force || brKludge && result.safari) &&
          isEquivalentPosition(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset) &&
          isEquivalentPosition(headDOM.node, headDOM.offset, domSel.focusNode, domSel.focusOffset))
        { return }

      // Selection.extend can be used to create an 'inverted' selection
      // (one where the focus is before the anchor), but not all
      // browsers support it yet.
      var domSelExtended = false;
      if ((domSel.extend || anchor == head) && !brKludge) {
        domSel.collapse(anchorDOM.node, anchorDOM.offset);
        try {
          if (anchor != head) { domSel.extend(headDOM.node, headDOM.offset); }
          domSelExtended = true;
        } catch (err) {
          // In some cases with Chrome the selection is empty after calling
          // collapse, even when it should be valid. This appears to be a bug, but
          // it is difficult to isolate. If this happens fallback to the old path
          // without using extend.
          if (!(err instanceof DOMException)) { throw err }
          // declare global: DOMException
        }
      }
      if (!domSelExtended) {
        if (anchor > head) { var tmp = anchorDOM; anchorDOM = headDOM; headDOM = tmp; }
        var range = document.createRange();
        range.setEnd(headDOM.node, headDOM.offset);
        range.setStart(anchorDOM.node, anchorDOM.offset);
        domSel.removeAllRanges();
        domSel.addRange(range);
      }
    };

    // : (dom.MutationRecord) → bool
    ViewDesc.prototype.ignoreMutation = function ignoreMutation (mutation) {
      return !this.contentDOM && mutation.type != "selection"
    };

    prototypeAccessors$9.contentLost.get = function () {
      return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM)
    };

    // Remove a subtree of the element tree that has been touched
    // by a DOM change, so that the next update will redraw it.
    ViewDesc.prototype.markDirty = function markDirty (from, to) {
      for (var offset = 0, i = 0; i < this.children.length; i++) {
        var child = this.children[i], end = offset + child.size;
        if (offset == end ? from <= end && to >= offset : from < end && to > offset) {
          var startInside = offset + child.border, endInside = end - child.border;
          if (from >= startInside && to <= endInside) {
            this.dirty = from == offset || to == end ? CONTENT_DIRTY : CHILD_DIRTY;
            if (from == startInside && to == endInside &&
                (child.contentLost || child.dom.parentNode != this.contentDOM)) { child.dirty = NODE_DIRTY; }
            else { child.markDirty(from - startInside, to - startInside); }
            return
          } else {
            child.dirty = NODE_DIRTY;
          }
        }
        offset = end;
      }
      this.dirty = CONTENT_DIRTY;
    };

    ViewDesc.prototype.markParentsDirty = function markParentsDirty () {
      var level = 1;
      for (var node = this.parent; node; node = node.parent, level++) {
        var dirty = level == 1 ? CONTENT_DIRTY : CHILD_DIRTY;
        if (node.dirty < dirty) { node.dirty = dirty; }
      }
    };

    prototypeAccessors$9.domAtom.get = function () { return false };

    Object.defineProperties( ViewDesc.prototype, prototypeAccessors$9 );

    // Reused array to avoid allocating fresh arrays for things that will
    // stay empty anyway.
    var nothing = [];

    // A widget desc represents a widget decoration, which is a DOM node
    // drawn between the document nodes.
    var WidgetViewDesc = /*@__PURE__*/(function (ViewDesc) {
      function WidgetViewDesc(parent, widget, view, pos) {
        var self, dom = widget.type.toDOM;
        if (typeof dom == "function") { dom = dom(view, function () {
          if (!self) { return pos }
          if (self.parent) { return self.parent.posBeforeChild(self) }
        }); }
        if (!widget.type.spec.raw) {
          if (dom.nodeType != 1) {
            var wrap = document.createElement("span");
            wrap.appendChild(dom);
            dom = wrap;
          }
          dom.contentEditable = false;
          dom.classList.add("ProseMirror-widget");
        }
        ViewDesc.call(this, parent, nothing, dom, null);
        this.widget = widget;
        self = this;
      }

      if ( ViewDesc ) WidgetViewDesc.__proto__ = ViewDesc;
      WidgetViewDesc.prototype = Object.create( ViewDesc && ViewDesc.prototype );
      WidgetViewDesc.prototype.constructor = WidgetViewDesc;

      var prototypeAccessors$1 = { beforePosition: { configurable: true },domAtom: { configurable: true } };

      prototypeAccessors$1.beforePosition.get = function () {
        return this.widget.type.side < 0
      };

      WidgetViewDesc.prototype.matchesWidget = function matchesWidget (widget) {
        return this.dirty == NOT_DIRTY && widget.type.eq(this.widget.type)
      };

      WidgetViewDesc.prototype.parseRule = function parseRule () { return {ignore: true} };

      WidgetViewDesc.prototype.stopEvent = function stopEvent (event) {
        var stop = this.widget.spec.stopEvent;
        return stop ? stop(event) : false
      };

      WidgetViewDesc.prototype.ignoreMutation = function ignoreMutation (mutation) {
        return mutation.type != "selection" || this.widget.spec.ignoreSelection
      };

      prototypeAccessors$1.domAtom.get = function () { return true };

      Object.defineProperties( WidgetViewDesc.prototype, prototypeAccessors$1 );

      return WidgetViewDesc;
    }(ViewDesc));

    var CompositionViewDesc = /*@__PURE__*/(function (ViewDesc) {
      function CompositionViewDesc(parent, dom, textDOM, text) {
        ViewDesc.call(this, parent, nothing, dom, null);
        this.textDOM = textDOM;
        this.text = text;
      }

      if ( ViewDesc ) CompositionViewDesc.__proto__ = ViewDesc;
      CompositionViewDesc.prototype = Object.create( ViewDesc && ViewDesc.prototype );
      CompositionViewDesc.prototype.constructor = CompositionViewDesc;

      var prototypeAccessors$2 = { size: { configurable: true } };

      prototypeAccessors$2.size.get = function () { return this.text.length };

      CompositionViewDesc.prototype.localPosFromDOM = function localPosFromDOM (dom, offset) {
        if (dom != this.textDOM) { return this.posAtStart + (offset ? this.size : 0) }
        return this.posAtStart + offset
      };

      CompositionViewDesc.prototype.domFromPos = function domFromPos (pos) {
        return {node: this.textDOM, offset: pos}
      };

      CompositionViewDesc.prototype.ignoreMutation = function ignoreMutation (mut) {
        return mut.type === 'characterData' && mut.target.nodeValue == mut.oldValue
       };

      Object.defineProperties( CompositionViewDesc.prototype, prototypeAccessors$2 );

      return CompositionViewDesc;
    }(ViewDesc));

    // A mark desc represents a mark. May have multiple children,
    // depending on how the mark is split. Note that marks are drawn using
    // a fixed nesting order, for simplicity and predictability, so in
    // some cases they will be split more often than would appear
    // necessary.
    var MarkViewDesc = /*@__PURE__*/(function (ViewDesc) {
      function MarkViewDesc(parent, mark, dom, contentDOM) {
        ViewDesc.call(this, parent, [], dom, contentDOM);
        this.mark = mark;
      }

      if ( ViewDesc ) MarkViewDesc.__proto__ = ViewDesc;
      MarkViewDesc.prototype = Object.create( ViewDesc && ViewDesc.prototype );
      MarkViewDesc.prototype.constructor = MarkViewDesc;

      MarkViewDesc.create = function create (parent, mark, inline, view) {
        var custom = view.nodeViews[mark.type.name];
        var spec = custom && custom(mark, view, inline);
        if (!spec || !spec.dom)
          { spec = DOMSerializer.renderSpec(document, mark.type.spec.toDOM(mark, inline)); }
        return new MarkViewDesc(parent, mark, spec.dom, spec.contentDOM || spec.dom)
      };

      MarkViewDesc.prototype.parseRule = function parseRule () { return {mark: this.mark.type.name, attrs: this.mark.attrs, contentElement: this.contentDOM} };

      MarkViewDesc.prototype.matchesMark = function matchesMark (mark) { return this.dirty != NODE_DIRTY && this.mark.eq(mark) };

      MarkViewDesc.prototype.markDirty = function markDirty (from, to) {
        ViewDesc.prototype.markDirty.call(this, from, to);
        // Move dirty info to nearest node view
        if (this.dirty != NOT_DIRTY) {
          var parent = this.parent;
          while (!parent.node) { parent = parent.parent; }
          if (parent.dirty < this.dirty) { parent.dirty = this.dirty; }
          this.dirty = NOT_DIRTY;
        }
      };

      MarkViewDesc.prototype.slice = function slice (from, to, view) {
        var copy = MarkViewDesc.create(this.parent, this.mark, true, view);
        var nodes = this.children, size = this.size;
        if (to < size) { nodes = replaceNodes(nodes, to, size, view); }
        if (from > 0) { nodes = replaceNodes(nodes, 0, from, view); }
        for (var i = 0; i < nodes.length; i++) { nodes[i].parent = copy; }
        copy.children = nodes;
        return copy
      };

      return MarkViewDesc;
    }(ViewDesc));

    // Node view descs are the main, most common type of view desc, and
    // correspond to an actual node in the document. Unlike mark descs,
    // they populate their child array themselves.
    var NodeViewDesc = /*@__PURE__*/(function (ViewDesc) {
      function NodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos) {
        ViewDesc.call(this, parent, node.isLeaf ? nothing : [], dom, contentDOM);
        this.nodeDOM = nodeDOM;
        this.node = node;
        this.outerDeco = outerDeco;
        this.innerDeco = innerDeco;
        if (contentDOM) { this.updateChildren(view, pos); }
      }

      if ( ViewDesc ) NodeViewDesc.__proto__ = ViewDesc;
      NodeViewDesc.prototype = Object.create( ViewDesc && ViewDesc.prototype );
      NodeViewDesc.prototype.constructor = NodeViewDesc;

      var prototypeAccessors$3 = { size: { configurable: true },border: { configurable: true },domAtom: { configurable: true } };

      // By default, a node is rendered using the `toDOM` method from the
      // node type spec. But client code can use the `nodeViews` spec to
      // supply a custom node view, which can influence various aspects of
      // the way the node works.
      //
      // (Using subclassing for this was intentionally decided against,
      // since it'd require exposing a whole slew of finnicky
      // implementation details to the user code that they probably will
      // never need.)
      NodeViewDesc.create = function create (parent, node, outerDeco, innerDeco, view, pos) {
        var assign;

        var custom = view.nodeViews[node.type.name], descObj;
        var spec = custom && custom(node, view, function () {
          // (This is a function that allows the custom view to find its
          // own position)
          if (!descObj) { return pos }
          if (descObj.parent) { return descObj.parent.posBeforeChild(descObj) }
        }, outerDeco);

        var dom = spec && spec.dom, contentDOM = spec && spec.contentDOM;
        if (node.isText) {
          if (!dom) { dom = document.createTextNode(node.text); }
          else if (dom.nodeType != 3) { throw new RangeError("Text must be rendered as a DOM text node") }
        } else if (!dom) {
    ((assign = DOMSerializer.renderSpec(document, node.type.spec.toDOM(node)), dom = assign.dom, contentDOM = assign.contentDOM));
        }
        if (!contentDOM && !node.isText && dom.nodeName != "BR") { // Chrome gets confused by <br contenteditable=false>
          if (!dom.hasAttribute("contenteditable")) { dom.contentEditable = false; }
          if (node.type.spec.draggable) { dom.draggable = true; }
        }

        var nodeDOM = dom;
        dom = applyOuterDeco(dom, outerDeco, node);

        if (spec)
          { return descObj = new CustomNodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM,
                                                  spec, view, pos + 1) }
        else if (node.isText)
          { return new TextViewDesc(parent, node, outerDeco, innerDeco, dom, nodeDOM, view) }
        else
          { return new NodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos + 1) }
      };

      NodeViewDesc.prototype.parseRule = function parseRule () {
        var this$1 = this;

        // Experimental kludge to allow opt-in re-parsing of nodes
        if (this.node.type.spec.reparseInView) { return null }
        // FIXME the assumption that this can always return the current
        // attrs means that if the user somehow manages to change the
        // attrs in the dom, that won't be picked up. Not entirely sure
        // whether this is a problem
        var rule = {node: this.node.type.name, attrs: this.node.attrs};
        if (this.node.type.spec.code) { rule.preserveWhitespace = "full"; }
        if (this.contentDOM && !this.contentLost) { rule.contentElement = this.contentDOM; }
        else { rule.getContent = function () { return this$1.contentDOM ? Fragment.empty : this$1.node.content; }; }
        return rule
      };

      NodeViewDesc.prototype.matchesNode = function matchesNode (node, outerDeco, innerDeco) {
        return this.dirty == NOT_DIRTY && node.eq(this.node) &&
          sameOuterDeco(outerDeco, this.outerDeco) && innerDeco.eq(this.innerDeco)
      };

      prototypeAccessors$3.size.get = function () { return this.node.nodeSize };

      prototypeAccessors$3.border.get = function () { return this.node.isLeaf ? 0 : 1 };

      // Syncs `this.children` to match `this.node.content` and the local
      // decorations, possibly introducing nesting for marks. Then, in a
      // separate step, syncs the DOM inside `this.contentDOM` to
      // `this.children`.
      NodeViewDesc.prototype.updateChildren = function updateChildren (view, pos) {
        var this$1 = this;

        var inline = this.node.inlineContent, off = pos;
        var composition = inline && view.composing && this.localCompositionNode(view, pos);
        var updater = new ViewTreeUpdater(this, composition && composition.node);
        iterDeco(this.node, this.innerDeco, function (widget, i, insideNode) {
          if (widget.spec.marks)
            { updater.syncToMarks(widget.spec.marks, inline, view); }
          else if (widget.type.side >= 0 && !insideNode)
            { updater.syncToMarks(i == this$1.node.childCount ? Mark.none : this$1.node.child(i).marks, inline, view); }
          // If the next node is a desc matching this widget, reuse it,
          // otherwise insert the widget as a new view desc.
          updater.placeWidget(widget, view, off);
        }, function (child, outerDeco, innerDeco, i) {
          // Make sure the wrapping mark descs match the node's marks.
          updater.syncToMarks(child.marks, inline, view);
          // Either find an existing desc that exactly matches this node,
          // and drop the descs before it.
          updater.findNodeMatch(child, outerDeco, innerDeco, i) ||
            // Or try updating the next desc to reflect this node.
            updater.updateNextNode(child, outerDeco, innerDeco, view, i) ||
            // Or just add it as a new desc.
            updater.addNode(child, outerDeco, innerDeco, view, off);
          off += child.nodeSize;
        });
        // Drop all remaining descs after the current position.
        updater.syncToMarks(nothing, inline, view);
        if (this.node.isTextblock) { updater.addTextblockHacks(); }
        updater.destroyRest();

        // Sync the DOM if anything changed
        if (updater.changed || this.dirty == CONTENT_DIRTY) {
          // May have to protect focused DOM from being changed if a composition is active
          if (composition) { this.protectLocalComposition(view, composition); }
          renderDescs(this.contentDOM, this.children, view);
          if (result.ios) { iosHacks(this.dom); }
        }
      };

      NodeViewDesc.prototype.localCompositionNode = function localCompositionNode (view, pos) {
        // Only do something if both the selection and a focused text node
        // are inside of this node, and the node isn't already part of a
        // view that's a child of this view
        var ref = view.state.selection;
        var from = ref.from;
        var to = ref.to;
        if (!(view.state.selection instanceof TextSelection) || from < pos || to > pos + this.node.content.size) { return }
        var sel = view.root.getSelection();
        var textNode = nearbyTextNode(sel.focusNode, sel.focusOffset);
        if (!textNode || !this.dom.contains(textNode.parentNode)) { return }

        // Find the text in the focused node in the node, stop if it's not
        // there (may have been modified through other means, in which
        // case it should overwritten)
        var text = textNode.nodeValue;
        var textPos = findTextInFragment(this.node.content, text, from - pos, to - pos);

        return textPos < 0 ? null : {node: textNode, pos: textPos, text: text}
      };

      NodeViewDesc.prototype.protectLocalComposition = function protectLocalComposition (view, ref) {
        var node = ref.node;
        var pos = ref.pos;
        var text = ref.text;

        // The node is already part of a local view desc, leave it there
        if (this.getDesc(node)) { return }

        // Create a composition view for the orphaned nodes
        var topNode = node;
        for (;; topNode = topNode.parentNode) {
          if (topNode.parentNode == this.contentDOM) { break }
          while (topNode.previousSibling) { topNode.parentNode.removeChild(topNode.previousSibling); }
          while (topNode.nextSibling) { topNode.parentNode.removeChild(topNode.nextSibling); }
          if (topNode.pmViewDesc) { topNode.pmViewDesc = null; }
        }
        var desc = new CompositionViewDesc(this, topNode, node, text);
        view.compositionNodes.push(desc);

        // Patch up this.children to contain the composition view
        this.children = replaceNodes(this.children, pos, pos + text.length, view, desc);
      };

      // : (Node, [Decoration], DecorationSet, EditorView) → bool
      // If this desc be updated to match the given node decoration,
      // do so and return true.
      NodeViewDesc.prototype.update = function update (node, outerDeco, innerDeco, view) {
        if (this.dirty == NODE_DIRTY ||
            !node.sameMarkup(this.node)) { return false }
        this.updateInner(node, outerDeco, innerDeco, view);
        return true
      };

      NodeViewDesc.prototype.updateInner = function updateInner (node, outerDeco, innerDeco, view) {
        this.updateOuterDeco(outerDeco);
        this.node = node;
        this.innerDeco = innerDeco;
        if (this.contentDOM) { this.updateChildren(view, this.posAtStart); }
        this.dirty = NOT_DIRTY;
      };

      NodeViewDesc.prototype.updateOuterDeco = function updateOuterDeco (outerDeco) {
        if (sameOuterDeco(outerDeco, this.outerDeco)) { return }
        var needsWrap = this.nodeDOM.nodeType != 1;
        var oldDOM = this.dom;
        this.dom = patchOuterDeco(this.dom, this.nodeDOM,
                                  computeOuterDeco(this.outerDeco, this.node, needsWrap),
                                  computeOuterDeco(outerDeco, this.node, needsWrap));
        if (this.dom != oldDOM) {
          oldDOM.pmViewDesc = null;
          this.dom.pmViewDesc = this;
        }
        this.outerDeco = outerDeco;
      };

      // Mark this node as being the selected node.
      NodeViewDesc.prototype.selectNode = function selectNode () {
        this.nodeDOM.classList.add("ProseMirror-selectednode");
        if (this.contentDOM || !this.node.type.spec.draggable) { this.dom.draggable = true; }
      };

      // Remove selected node marking from this node.
      NodeViewDesc.prototype.deselectNode = function deselectNode () {
        this.nodeDOM.classList.remove("ProseMirror-selectednode");
        if (this.contentDOM || !this.node.type.spec.draggable) { this.dom.removeAttribute("draggable"); }
      };

      prototypeAccessors$3.domAtom.get = function () { return this.node.isAtom };

      Object.defineProperties( NodeViewDesc.prototype, prototypeAccessors$3 );

      return NodeViewDesc;
    }(ViewDesc));

    // Create a view desc for the top-level document node, to be exported
    // and used by the view class.
    function docViewDesc(doc, outerDeco, innerDeco, dom, view) {
      applyOuterDeco(dom, outerDeco, doc);
      return new NodeViewDesc(null, doc, outerDeco, innerDeco, dom, dom, dom, view, 0)
    }

    var TextViewDesc = /*@__PURE__*/(function (NodeViewDesc) {
      function TextViewDesc(parent, node, outerDeco, innerDeco, dom, nodeDOM, view) {
        NodeViewDesc.call(this, parent, node, outerDeco, innerDeco, dom, null, nodeDOM, view);
      }

      if ( NodeViewDesc ) TextViewDesc.__proto__ = NodeViewDesc;
      TextViewDesc.prototype = Object.create( NodeViewDesc && NodeViewDesc.prototype );
      TextViewDesc.prototype.constructor = TextViewDesc;

      var prototypeAccessors$4 = { domAtom: { configurable: true } };

      TextViewDesc.prototype.parseRule = function parseRule () {
        var skip = this.nodeDOM.parentNode;
        while (skip && skip != this.dom && !skip.pmIsDeco) { skip = skip.parentNode; }
        return {skip: skip || true}
      };

      TextViewDesc.prototype.update = function update (node, outerDeco, _, view) {
        if (this.dirty == NODE_DIRTY || (this.dirty != NOT_DIRTY && !this.inParent()) ||
            !node.sameMarkup(this.node)) { return false }
        this.updateOuterDeco(outerDeco);
        if ((this.dirty != NOT_DIRTY || node.text != this.node.text) && node.text != this.nodeDOM.nodeValue) {
          this.nodeDOM.nodeValue = node.text;
          if (view.trackWrites == this.nodeDOM) { view.trackWrites = null; }
        }
        this.node = node;
        this.dirty = NOT_DIRTY;
        return true
      };

      TextViewDesc.prototype.inParent = function inParent () {
        var parentDOM = this.parent.contentDOM;
        for (var n = this.nodeDOM; n; n = n.parentNode) { if (n == parentDOM) { return true } }
        return false
      };

      TextViewDesc.prototype.domFromPos = function domFromPos (pos) {
        return {node: this.nodeDOM, offset: pos}
      };

      TextViewDesc.prototype.localPosFromDOM = function localPosFromDOM (dom, offset, bias) {
        if (dom == this.nodeDOM) { return this.posAtStart + Math.min(offset, this.node.text.length) }
        return NodeViewDesc.prototype.localPosFromDOM.call(this, dom, offset, bias)
      };

      TextViewDesc.prototype.ignoreMutation = function ignoreMutation (mutation) {
        return mutation.type != "characterData" && mutation.type != "selection"
      };

      TextViewDesc.prototype.slice = function slice (from, to, view) {
        var node = this.node.cut(from, to), dom = document.createTextNode(node.text);
        return new TextViewDesc(this.parent, node, this.outerDeco, this.innerDeco, dom, dom, view)
      };

      prototypeAccessors$4.domAtom.get = function () { return false };

      Object.defineProperties( TextViewDesc.prototype, prototypeAccessors$4 );

      return TextViewDesc;
    }(NodeViewDesc));

    // A dummy desc used to tag trailing BR or span nodes created to work
    // around contentEditable terribleness.
    var BRHackViewDesc = /*@__PURE__*/(function (ViewDesc) {
      function BRHackViewDesc () {
        ViewDesc.apply(this, arguments);
      }

      if ( ViewDesc ) BRHackViewDesc.__proto__ = ViewDesc;
      BRHackViewDesc.prototype = Object.create( ViewDesc && ViewDesc.prototype );
      BRHackViewDesc.prototype.constructor = BRHackViewDesc;

      var prototypeAccessors$5 = { domAtom: { configurable: true } };

      BRHackViewDesc.prototype.parseRule = function parseRule () { return {ignore: true} };
      BRHackViewDesc.prototype.matchesHack = function matchesHack () { return this.dirty == NOT_DIRTY };
      prototypeAccessors$5.domAtom.get = function () { return true };

      Object.defineProperties( BRHackViewDesc.prototype, prototypeAccessors$5 );

      return BRHackViewDesc;
    }(ViewDesc));

    // A separate subclass is used for customized node views, so that the
    // extra checks only have to be made for nodes that are actually
    // customized.
    var CustomNodeViewDesc = /*@__PURE__*/(function (NodeViewDesc) {
      function CustomNodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, spec, view, pos) {
        NodeViewDesc.call(this, parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos);
        this.spec = spec;
      }

      if ( NodeViewDesc ) CustomNodeViewDesc.__proto__ = NodeViewDesc;
      CustomNodeViewDesc.prototype = Object.create( NodeViewDesc && NodeViewDesc.prototype );
      CustomNodeViewDesc.prototype.constructor = CustomNodeViewDesc;

      // A custom `update` method gets to decide whether the update goes
      // through. If it does, and there's a `contentDOM` node, our logic
      // updates the children.
      CustomNodeViewDesc.prototype.update = function update (node, outerDeco, innerDeco, view) {
        if (this.dirty == NODE_DIRTY) { return false }
        if (this.spec.update) {
          var result = this.spec.update(node, outerDeco);
          if (result) { this.updateInner(node, outerDeco, innerDeco, view); }
          return result
        } else if (!this.contentDOM && !node.isLeaf) {
          return false
        } else {
          return NodeViewDesc.prototype.update.call(this, node, outerDeco, innerDeco, view)
        }
      };

      CustomNodeViewDesc.prototype.selectNode = function selectNode () {
        this.spec.selectNode ? this.spec.selectNode() : NodeViewDesc.prototype.selectNode.call(this);
      };

      CustomNodeViewDesc.prototype.deselectNode = function deselectNode () {
        this.spec.deselectNode ? this.spec.deselectNode() : NodeViewDesc.prototype.deselectNode.call(this);
      };

      CustomNodeViewDesc.prototype.setSelection = function setSelection (anchor, head, root, force) {
        this.spec.setSelection ? this.spec.setSelection(anchor, head, root)
          : NodeViewDesc.prototype.setSelection.call(this, anchor, head, root, force);
      };

      CustomNodeViewDesc.prototype.destroy = function destroy () {
        if (this.spec.destroy) { this.spec.destroy(); }
        NodeViewDesc.prototype.destroy.call(this);
      };

      CustomNodeViewDesc.prototype.stopEvent = function stopEvent (event) {
        return this.spec.stopEvent ? this.spec.stopEvent(event) : false
      };

      CustomNodeViewDesc.prototype.ignoreMutation = function ignoreMutation (mutation) {
        return this.spec.ignoreMutation ? this.spec.ignoreMutation(mutation) : NodeViewDesc.prototype.ignoreMutation.call(this, mutation)
      };

      return CustomNodeViewDesc;
    }(NodeViewDesc));

    // : (dom.Node, [ViewDesc])
    // Sync the content of the given DOM node with the nodes associated
    // with the given array of view descs, recursing into mark descs
    // because this should sync the subtree for a whole node at a time.
    function renderDescs(parentDOM, descs, view) {
      var dom = parentDOM.firstChild, written = false;
      for (var i = 0; i < descs.length; i++) {
        var desc = descs[i], childDOM = desc.dom;
        if (childDOM.parentNode == parentDOM) {
          while (childDOM != dom) { dom = rm(dom); written = true; }
          dom = dom.nextSibling;
        } else {
          written = true;
          parentDOM.insertBefore(childDOM, dom);
        }
        if (desc instanceof MarkViewDesc) {
          var pos = dom ? dom.previousSibling : parentDOM.lastChild;
          renderDescs(desc.contentDOM, desc.children, view);
          dom = pos ? pos.nextSibling : parentDOM.firstChild;
        }
      }
      while (dom) { dom = rm(dom); written = true; }
      if (written && view.trackWrites == parentDOM) { view.trackWrites = null; }
    }

    function OuterDecoLevel(nodeName) {
      if (nodeName) { this.nodeName = nodeName; }
    }
    OuterDecoLevel.prototype = Object.create(null);

    var noDeco = [new OuterDecoLevel];

    function computeOuterDeco(outerDeco, node, needsWrap) {
      if (outerDeco.length == 0) { return noDeco }

      var top = needsWrap ? noDeco[0] : new OuterDecoLevel, result = [top];

      for (var i = 0; i < outerDeco.length; i++) {
        var attrs = outerDeco[i].type.attrs;
        if (!attrs) { continue }
        if (attrs.nodeName)
          { result.push(top = new OuterDecoLevel(attrs.nodeName)); }

        for (var name in attrs) {
          var val = attrs[name];
          if (val == null) { continue }
          if (needsWrap && result.length == 1)
            { result.push(top = new OuterDecoLevel(node.isInline ? "span" : "div")); }
          if (name == "class") { top.class = (top.class ? top.class + " " : "") + val; }
          else if (name == "style") { top.style = (top.style ? top.style + ";" : "") + val; }
          else if (name != "nodeName") { top[name] = val; }
        }
      }

      return result
    }

    function patchOuterDeco(outerDOM, nodeDOM, prevComputed, curComputed) {
      // Shortcut for trivial case
      if (prevComputed == noDeco && curComputed == noDeco) { return nodeDOM }

      var curDOM = nodeDOM;
      for (var i = 0; i < curComputed.length; i++) {
        var deco = curComputed[i], prev = prevComputed[i];
        if (i) {
          var parent = (void 0);
          if (prev && prev.nodeName == deco.nodeName && curDOM != outerDOM &&
              (parent = curDOM.parentNode) && parent.tagName.toLowerCase() == deco.nodeName) {
            curDOM = parent;
          } else {
            parent = document.createElement(deco.nodeName);
            parent.pmIsDeco = true;
            parent.appendChild(curDOM);
            prev = noDeco[0];
            curDOM = parent;
          }
        }
        patchAttributes(curDOM, prev || noDeco[0], deco);
      }
      return curDOM
    }

    function patchAttributes(dom, prev, cur) {
      for (var name in prev)
        { if (name != "class" && name != "style" && name != "nodeName" && !(name in cur))
          { dom.removeAttribute(name); } }
      for (var name$1 in cur)
        { if (name$1 != "class" && name$1 != "style" && name$1 != "nodeName" && cur[name$1] != prev[name$1])
          { dom.setAttribute(name$1, cur[name$1]); } }
      if (prev.class != cur.class) {
        var prevList = prev.class ? prev.class.split(" ") : nothing;
        var curList = cur.class ? cur.class.split(" ") : nothing;
        for (var i = 0; i < prevList.length; i++) { if (curList.indexOf(prevList[i]) == -1)
          { dom.classList.remove(prevList[i]); } }
        for (var i$1 = 0; i$1 < curList.length; i$1++) { if (prevList.indexOf(curList[i$1]) == -1)
          { dom.classList.add(curList[i$1]); } }
      }
      if (prev.style != cur.style) {
        if (prev.style) {
          var prop = /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g, m;
          while (m = prop.exec(prev.style))
            { dom.style.removeProperty(m[1]); }
        }
        if (cur.style)
          { dom.style.cssText += cur.style; }
      }
    }

    function applyOuterDeco(dom, deco, node) {
      return patchOuterDeco(dom, dom, noDeco, computeOuterDeco(deco, node, dom.nodeType != 1))
    }

    // : ([Decoration], [Decoration]) → bool
    function sameOuterDeco(a, b) {
      if (a.length != b.length) { return false }
      for (var i = 0; i < a.length; i++) { if (!a[i].type.eq(b[i].type)) { return false } }
      return true
    }

    // Remove a DOM node and return its next sibling.
    function rm(dom) {
      var next = dom.nextSibling;
      dom.parentNode.removeChild(dom);
      return next
    }

    // Helper class for incrementally updating a tree of mark descs and
    // the widget and node descs inside of them.
    var ViewTreeUpdater = function ViewTreeUpdater(top, lockedNode) {
      this.top = top;
      this.lock = lockedNode;
      // Index into `this.top`'s child array, represents the current
      // update position.
      this.index = 0;
      // When entering a mark, the current top and index are pushed
      // onto this.
      this.stack = [];
      // Tracks whether anything was changed
      this.changed = false;

      var pre = preMatch(top.node.content, top.children);
      this.preMatched = pre.nodes;
      this.preMatchOffset = pre.offset;
    };

    ViewTreeUpdater.prototype.getPreMatch = function getPreMatch (index) {
      return index >= this.preMatchOffset ? this.preMatched[index - this.preMatchOffset] : null
    };

    // Destroy and remove the children between the given indices in
    // `this.top`.
    ViewTreeUpdater.prototype.destroyBetween = function destroyBetween (start, end) {
      if (start == end) { return }
      for (var i = start; i < end; i++) { this.top.children[i].destroy(); }
      this.top.children.splice(start, end - start);
      this.changed = true;
    };

    // Destroy all remaining children in `this.top`.
    ViewTreeUpdater.prototype.destroyRest = function destroyRest () {
      this.destroyBetween(this.index, this.top.children.length);
    };

    // : ([Mark], EditorView)
    // Sync the current stack of mark descs with the given array of
    // marks, reusing existing mark descs when possible.
    ViewTreeUpdater.prototype.syncToMarks = function syncToMarks (marks, inline, view) {
      var keep = 0, depth = this.stack.length >> 1;
      var maxKeep = Math.min(depth, marks.length);
      while (keep < maxKeep &&
             (keep == depth - 1 ? this.top : this.stack[(keep + 1) << 1]).matchesMark(marks[keep]) && marks[keep].type.spec.spanning !== false)
        { keep++; }

      while (keep < depth) {
        this.destroyRest();
        this.top.dirty = NOT_DIRTY;
        this.index = this.stack.pop();
        this.top = this.stack.pop();
        depth--;
      }
      while (depth < marks.length) {
        this.stack.push(this.top, this.index + 1);
        var found = -1;
        for (var i = this.index; i < Math.min(this.index + 3, this.top.children.length); i++) {
          if (this.top.children[i].matchesMark(marks[depth])) { found = i; break }
        }
        if (found > -1) {
          if (found > this.index) {
            this.changed = true;
            this.destroyBetween(this.index, found);
          }
          this.top = this.top.children[this.index];
        } else {
          var markDesc = MarkViewDesc.create(this.top, marks[depth], inline, view);
          this.top.children.splice(this.index, 0, markDesc);
          this.top = markDesc;
          this.changed = true;
        }
        this.index = 0;
        depth++;
      }
    };

    // : (Node, [Decoration], DecorationSet) → bool
    // Try to find a node desc matching the given data. Skip over it and
    // return true when successful.
    ViewTreeUpdater.prototype.findNodeMatch = function findNodeMatch (node, outerDeco, innerDeco, index) {
      var found = -1, preMatch = index < 0 ? undefined : this.getPreMatch(index), children = this.top.children;
      if (preMatch && preMatch.matchesNode(node, outerDeco, innerDeco)) {
        found = children.indexOf(preMatch);
      } else {
        for (var i = this.index, e = Math.min(children.length, i + 5); i < e; i++) {
          var child = children[i];
          if (child.matchesNode(node, outerDeco, innerDeco) && this.preMatched.indexOf(child) < 0) {
            found = i;
            break
          }
        }
      }
      if (found < 0) { return false }
      this.destroyBetween(this.index, found);
      this.index++;
      return true
    };

    // : (Node, [Decoration], DecorationSet, EditorView, Fragment, number) → bool
    // Try to update the next node, if any, to the given data. Checks
    // pre-matches to avoid overwriting nodes that could still be used.
    ViewTreeUpdater.prototype.updateNextNode = function updateNextNode (node, outerDeco, innerDeco, view, index) {
      for (var i = this.index; i < this.top.children.length; i++) {
        var next = this.top.children[i];
        if (next instanceof NodeViewDesc) {
          var preMatch = this.preMatched.indexOf(next);
          if (preMatch > -1 && preMatch + this.preMatchOffset != index) { return false }
          var nextDOM = next.dom;

          // Can't update if nextDOM is or contains this.lock, except if
          // it's a text node whose content already matches the new text
          // and whose decorations match the new ones.
          var locked = this.lock && (nextDOM == this.lock || nextDOM.nodeType == 1 && nextDOM.contains(this.lock.parentNode)) &&
              !(node.isText && next.node && next.node.isText && next.nodeDOM.nodeValue == node.text &&
                next.dirty != NODE_DIRTY && sameOuterDeco(outerDeco, next.outerDeco));
          if (!locked && next.update(node, outerDeco, innerDeco, view)) {
            this.destroyBetween(this.index, i);
            if (next.dom != nextDOM) { this.changed = true; }
            this.index++;
            return true
          }
          break
        }
      }
      return false
    };

    // : (Node, [Decoration], DecorationSet, EditorView)
    // Insert the node as a newly created node desc.
    ViewTreeUpdater.prototype.addNode = function addNode (node, outerDeco, innerDeco, view, pos) {
      this.top.children.splice(this.index++, 0, NodeViewDesc.create(this.top, node, outerDeco, innerDeco, view, pos));
      this.changed = true;
    };

    ViewTreeUpdater.prototype.placeWidget = function placeWidget (widget, view, pos) {
      var next = this.index < this.top.children.length ? this.top.children[this.index] : null;
      if (next && next.matchesWidget(widget) && (widget == next.widget || !next.widget.type.toDOM.parentNode)) {
        this.index++;
      } else {
        var desc = new WidgetViewDesc(this.top, widget, view, pos);
        this.top.children.splice(this.index++, 0, desc);
        this.changed = true;
      }
    };

    // Make sure a textblock looks and behaves correctly in
    // contentEditable.
    ViewTreeUpdater.prototype.addTextblockHacks = function addTextblockHacks () {
      var lastChild = this.top.children[this.index - 1];
      while (lastChild instanceof MarkViewDesc) { lastChild = lastChild.children[lastChild.children.length - 1]; }

      if (!lastChild || // Empty textblock
          !(lastChild instanceof TextViewDesc) ||
          /\n$/.test(lastChild.node.text)) {
        if (this.index < this.top.children.length && this.top.children[this.index].matchesHack()) {
          this.index++;
        } else {
          var dom = document.createElement("br");
          this.top.children.splice(this.index++, 0, new BRHackViewDesc(this.top, nothing, dom, null));
          this.changed = true;
        }
      }
    };

    // : (Fragment, [ViewDesc]) → [ViewDesc]
    // Iterate from the end of the fragment and array of descs to find
    // directly matching ones, in order to avoid overeagerly reusing
    // those for other nodes. Returns an array whose positions correspond
    // to node positions in the fragment, and whose elements are either
    // descs matched to the child at that index, or empty.
    function preMatch(frag, descs) {
      var result = [], end = frag.childCount;
      for (var i = descs.length - 1; end > 0 && i >= 0; i--) {
        var desc = descs[i], node = desc.node;
        if (!node) { continue }
        if (node != frag.child(end - 1)) { break }
        result.push(desc);
        --end;
      }
      return {nodes: result.reverse(), offset: end}
    }

    function compareSide(a, b) { return a.type.side - b.type.side }

    // : (ViewDesc, DecorationSet, (Decoration, number), (Node, [Decoration], DecorationSet, number))
    // This function abstracts iterating over the nodes and decorations in
    // a fragment. Calls `onNode` for each node, with its local and child
    // decorations. Splits text nodes when there is a decoration starting
    // or ending inside of them. Calls `onWidget` for each widget.
    function iterDeco(parent, deco, onWidget, onNode) {
      var locals = deco.locals(parent), offset = 0;
      // Simple, cheap variant for when there are no local decorations
      if (locals.length == 0) {
        for (var i = 0; i < parent.childCount; i++) {
          var child = parent.child(i);
          onNode(child, locals, deco.forChild(offset, child), i);
          offset += child.nodeSize;
        }
        return
      }

      var decoIndex = 0, active = [], restNode = null;
      for (var parentIndex = 0;;) {
        if (decoIndex < locals.length && locals[decoIndex].to == offset) {
          var widget = locals[decoIndex++], widgets = (void 0);
          while (decoIndex < locals.length && locals[decoIndex].to == offset)
            { (widgets || (widgets = [widget])).push(locals[decoIndex++]); }
          if (widgets) {
            widgets.sort(compareSide);
            for (var i$1 = 0; i$1 < widgets.length; i$1++) { onWidget(widgets[i$1], parentIndex, !!restNode); }
          } else {
            onWidget(widget, parentIndex, !!restNode);
          }
        }

        var child$1 = (void 0), index = (void 0);
        if (restNode) {
          index = -1;
          child$1 = restNode;
          restNode = null;
        } else if (parentIndex < parent.childCount) {
          index = parentIndex;
          child$1 = parent.child(parentIndex++);
        } else {
          break
        }

        for (var i$2 = 0; i$2 < active.length; i$2++) { if (active[i$2].to <= offset) { active.splice(i$2--, 1); } }
        while (decoIndex < locals.length && locals[decoIndex].from <= offset && locals[decoIndex].to > offset)
          { active.push(locals[decoIndex++]); }

        var end = offset + child$1.nodeSize;
        if (child$1.isText) {
          var cutAt = end;
          if (decoIndex < locals.length && locals[decoIndex].from < cutAt) { cutAt = locals[decoIndex].from; }
          for (var i$3 = 0; i$3 < active.length; i$3++) { if (active[i$3].to < cutAt) { cutAt = active[i$3].to; } }
          if (cutAt < end) {
            restNode = child$1.cut(cutAt - offset);
            child$1 = child$1.cut(0, cutAt - offset);
            end = cutAt;
            index = -1;
          }
        }

        var outerDeco = !active.length ? nothing
            : child$1.isInline && !child$1.isLeaf ? active.filter(function (d) { return !d.inline; })
            : active.slice();
        onNode(child$1, outerDeco, deco.forChild(offset, child$1), index);
        offset = end;
      }
    }

    // List markers in Mobile Safari will mysteriously disappear
    // sometimes. This works around that.
    function iosHacks(dom) {
      if (dom.nodeName == "UL" || dom.nodeName == "OL") {
        var oldCSS = dom.style.cssText;
        dom.style.cssText = oldCSS + "; list-style: square !important";
        window.getComputedStyle(dom).listStyle;
        dom.style.cssText = oldCSS;
      }
    }

    function nearbyTextNode(node, offset) {
      for (;;) {
        if (node.nodeType == 3) { return node }
        if (node.nodeType == 1 && offset > 0) {
          if (node.childNodes.length > offset && node.childNodes[offset].nodeType == 3)
            { return node.childNodes[offset] }
          node = node.childNodes[offset - 1];
          offset = nodeSize(node);
        } else if (node.nodeType == 1 && offset < node.childNodes.length) {
          node = node.childNodes[offset];
          offset = 0;
        } else {
          return null
        }
      }
    }

    // Find a piece of text in an inline fragment, overlapping from-to
    function findTextInFragment(frag, text, from, to) {
      for (var i = 0, pos = 0; i < frag.childCount && pos <= to;) {
        var child = frag.child(i++), childStart = pos;
        pos += child.nodeSize;
        if (!child.isText) { continue }
        var str = child.text;
        while (i < frag.childCount) {
          var next = frag.child(i++);
          pos += next.nodeSize;
          if (!next.isText) { break }
          str += next.text;
        }
        if (pos >= from) {
          var found = str.lastIndexOf(text, to - childStart);
          if (found >= 0 && found + text.length + childStart >= from)
            { return childStart + found }
        }
      }
      return -1
    }

    // Replace range from-to in an array of view descs with replacement
    // (may be null to just delete). This goes very much against the grain
    // of the rest of this code, which tends to create nodes with the
    // right shape in one go, rather than messing with them after
    // creation, but is necessary in the composition hack.
    function replaceNodes(nodes, from, to, view, replacement) {
      var result = [];
      for (var i = 0, off = 0; i < nodes.length; i++) {
        var child = nodes[i], start = off, end = off += child.size;
        if (start >= to || end <= from) {
          result.push(child);
        } else {
          if (start < from) { result.push(child.slice(0, from - start, view)); }
          if (replacement) {
            result.push(replacement);
            replacement = null;
          }
          if (end > to) { result.push(child.slice(to - start, child.size, view)); }
        }
      }
      return result
    }

    function selectionFromDOM(view, origin) {
      var domSel = view.root.getSelection(), doc = view.state.doc;
      if (!domSel.focusNode) { return null }
      var nearestDesc = view.docView.nearestDesc(domSel.focusNode), inWidget = nearestDesc && nearestDesc.size == 0;
      var head = view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset);
      if (head < 0) { return null }
      var $head = doc.resolve(head), $anchor, selection;
      if (selectionCollapsed(domSel)) {
        $anchor = $head;
        while (nearestDesc && !nearestDesc.node) { nearestDesc = nearestDesc.parent; }
        if (nearestDesc && nearestDesc.node.isAtom && NodeSelection.isSelectable(nearestDesc.node) && nearestDesc.parent
            && !(nearestDesc.node.isInline && isOnEdge(domSel.focusNode, domSel.focusOffset, nearestDesc.dom))) {
          var pos = nearestDesc.posBefore;
          selection = new NodeSelection(head == pos ? $head : doc.resolve(pos));
        }
      } else {
        var anchor = view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset);
        if (anchor < 0) { return null }
        $anchor = doc.resolve(anchor);
      }

      if (!selection) {
        var bias = origin == "pointer" || (view.state.selection.head < $head.pos && !inWidget) ? 1 : -1;
        selection = selectionBetween(view, $anchor, $head, bias);
      }
      return selection
    }

    function selectionToDOM(view, force) {
      var sel = view.state.selection;
      syncNodeSelection(view, sel);

      if (view.editable ? !view.hasFocus() :
          !(hasSelection(view) && document.activeElement && document.activeElement.contains(view.dom))) { return }

      view.domObserver.disconnectSelection();

      if (view.cursorWrapper) {
        selectCursorWrapper(view);
      } else {
        var anchor = sel.anchor;
        var head = sel.head;
        var resetEditableFrom, resetEditableTo;
        if (brokenSelectBetweenUneditable && !(sel instanceof TextSelection)) {
          if (!sel.$from.parent.inlineContent)
            { resetEditableFrom = temporarilyEditableNear(view, sel.from); }
          if (!sel.empty && !sel.$from.parent.inlineContent)
            { resetEditableTo = temporarilyEditableNear(view, sel.to); }
        }
        view.docView.setSelection(anchor, head, view.root, force);
        if (brokenSelectBetweenUneditable) {
          if (resetEditableFrom) { resetEditable(resetEditableFrom); }
          if (resetEditableTo) { resetEditable(resetEditableTo); }
        }
        if (sel.visible) {
          view.dom.classList.remove("ProseMirror-hideselection");
        } else {
          view.dom.classList.add("ProseMirror-hideselection");
          if ("onselectionchange" in document) { removeClassOnSelectionChange(view); }
        }
      }

      view.domObserver.setCurSelection();
      view.domObserver.connectSelection();
    }

    // Kludge to work around Webkit not allowing a selection to start/end
    // between non-editable block nodes. We briefly make something
    // editable, set the selection, then set it uneditable again.

    var brokenSelectBetweenUneditable = result.safari || result.chrome && result.chrome_version < 63;

    function temporarilyEditableNear(view, pos) {
      var ref = view.docView.domFromPos(pos, 0);
      var node = ref.node;
      var offset = ref.offset;
      var after = offset < node.childNodes.length ? node.childNodes[offset] : null;
      var before = offset ? node.childNodes[offset - 1] : null;
      if (result.safari && after && after.contentEditable == "false") { return setEditable(after) }
      if ((!after || after.contentEditable == "false") && (!before || before.contentEditable == "false")) {
        if (after) { return setEditable(after) }
        else if (before) { return setEditable(before) }
      }
    }

    function setEditable(element) {
      element.contentEditable = "true";
      if (result.safari && element.draggable) { element.draggable = false; element.wasDraggable = true; }
      return element
    }

    function resetEditable(element) {
      element.contentEditable = "false";
      if (element.wasDraggable) { element.draggable = true; element.wasDraggable = null; }
    }

    function removeClassOnSelectionChange(view) {
      var doc = view.dom.ownerDocument;
      doc.removeEventListener("selectionchange", view.hideSelectionGuard);
      var domSel = view.root.getSelection();
      var node = domSel.anchorNode, offset = domSel.anchorOffset;
      doc.addEventListener("selectionchange", view.hideSelectionGuard = function () {
        if (domSel.anchorNode != node || domSel.anchorOffset != offset) {
          doc.removeEventListener("selectionchange", view.hideSelectionGuard);
          view.dom.classList.remove("ProseMirror-hideselection");
        }
      });
    }

    function selectCursorWrapper(view) {
      var domSel = view.root.getSelection(), range = document.createRange();
      var node = view.cursorWrapper.dom, img = node.nodeName == "IMG";
      if (img) { range.setEnd(node.parentNode, domIndex(node) + 1); }
      else { range.setEnd(node, 0); }
      range.collapse(false);
      domSel.removeAllRanges();
      domSel.addRange(range);
      // Kludge to kill 'control selection' in IE11 when selecting an
      // invisible cursor wrapper, since that would result in those weird
      // resize handles and a selection that considers the absolutely
      // positioned wrapper, rather than the root editable node, the
      // focused element.
      if (!img && !view.state.selection.visible && result.ie && result.ie_version <= 11) {
        node.disabled = true;
        node.disabled = false;
      }
    }

    function syncNodeSelection(view, sel) {
      if (sel instanceof NodeSelection) {
        var desc = view.docView.descAt(sel.from);
        if (desc != view.lastSelectedViewDesc) {
          clearNodeSelection(view);
          if (desc) { desc.selectNode(); }
          view.lastSelectedViewDesc = desc;
        }
      } else {
        clearNodeSelection(view);
      }
    }

    // Clear all DOM statefulness of the last node selection.
    function clearNodeSelection(view) {
      if (view.lastSelectedViewDesc) {
        if (view.lastSelectedViewDesc.parent)
          { view.lastSelectedViewDesc.deselectNode(); }
        view.lastSelectedViewDesc = null;
      }
    }

    function selectionBetween(view, $anchor, $head, bias) {
      return view.someProp("createSelectionBetween", function (f) { return f(view, $anchor, $head); })
        || TextSelection.between($anchor, $head, bias)
    }

    function hasFocusAndSelection(view) {
      if (view.editable && view.root.activeElement != view.dom) { return false }
      return hasSelection(view)
    }

    function hasSelection(view) {
      var sel = view.root.getSelection();
      if (!sel.anchorNode) { return false }
      try {
        // Firefox will raise 'permission denied' errors when accessing
        // properties of `sel.anchorNode` when it's in a generated CSS
        // element.
        return view.dom.contains(sel.anchorNode.nodeType == 3 ? sel.anchorNode.parentNode : sel.anchorNode) &&
          (view.editable || view.dom.contains(sel.focusNode.nodeType == 3 ? sel.focusNode.parentNode : sel.focusNode))
      } catch(_) {
        return false
      }
    }

    function anchorInRightPlace(view) {
      var anchorDOM = view.docView.domFromPos(view.state.selection.anchor, 0);
      var domSel = view.root.getSelection();
      return isEquivalentPosition(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset)
    }

    function moveSelectionBlock(state, dir) {
      var ref = state.selection;
      var $anchor = ref.$anchor;
      var $head = ref.$head;
      var $side = dir > 0 ? $anchor.max($head) : $anchor.min($head);
      var $start = !$side.parent.inlineContent ? $side : $side.depth ? state.doc.resolve(dir > 0 ? $side.after() : $side.before()) : null;
      return $start && Selection.findFrom($start, dir)
    }

    function apply(view, sel) {
      view.dispatch(view.state.tr.setSelection(sel).scrollIntoView());
      return true
    }

    function selectHorizontally(view, dir, mods) {
      var sel = view.state.selection;
      if (sel instanceof TextSelection) {
        if (!sel.empty || mods.indexOf("s") > -1) {
          return false
        } else if (view.endOfTextblock(dir > 0 ? "right" : "left")) {
          var next = moveSelectionBlock(view.state, dir);
          if (next && (next instanceof NodeSelection)) { return apply(view, next) }
          return false
        } else if (!(result.mac && mods.indexOf("m") > -1)) {
          var $head = sel.$head, node = $head.textOffset ? null : dir < 0 ? $head.nodeBefore : $head.nodeAfter, desc;
          if (!node || node.isText) { return false }
          var nodePos = dir < 0 ? $head.pos - node.nodeSize : $head.pos;
          if (!(node.isAtom || (desc = view.docView.descAt(nodePos)) && !desc.contentDOM)) { return false }
          if (NodeSelection.isSelectable(node)) {
            return apply(view, new NodeSelection(dir < 0 ? view.state.doc.resolve($head.pos - node.nodeSize) : $head))
          } else if (result.webkit) {
            // Chrome and Safari will introduce extra pointless cursor
            // positions around inline uneditable nodes, so we have to
            // take over and move the cursor past them (#937)
            return apply(view, new TextSelection(view.state.doc.resolve(dir < 0 ? nodePos : nodePos + node.nodeSize)))
          } else {
            return false
          }
        }
      } else if (sel instanceof NodeSelection && sel.node.isInline) {
        return apply(view, new TextSelection(dir > 0 ? sel.$to : sel.$from))
      } else {
        var next$1 = moveSelectionBlock(view.state, dir);
        if (next$1) { return apply(view, next$1) }
        return false
      }
    }

    function nodeLen(node) {
      return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length
    }

    function isIgnorable(dom) {
      var desc = dom.pmViewDesc;
      return desc && desc.size == 0 && (dom.nextSibling || dom.nodeName != "BR")
    }

    // Make sure the cursor isn't directly after one or more ignored
    // nodes, which will confuse the browser's cursor motion logic.
    function skipIgnoredNodesLeft(view) {
      var sel = view.root.getSelection();
      var node = sel.focusNode, offset = sel.focusOffset;
      if (!node) { return }
      var moveNode, moveOffset, force = false;
      // Gecko will do odd things when the selection is directly in front
      // of a non-editable node, so in that case, move it into the next
      // node if possible. Issue prosemirror/prosemirror#832.
      if (result.gecko && node.nodeType == 1 && offset < nodeLen(node) && isIgnorable(node.childNodes[offset])) { force = true; }
      for (;;) {
        if (offset > 0) {
          if (node.nodeType != 1) {
            break
          } else {
            var before = node.childNodes[offset - 1];
            if (isIgnorable(before)) {
              moveNode = node;
              moveOffset = --offset;
            } else if (before.nodeType == 3) {
              node = before;
              offset = node.nodeValue.length;
            } else { break }
          }
        } else if (isBlockNode(node)) {
          break
        } else {
          var prev = node.previousSibling;
          while (prev && isIgnorable(prev)) {
            moveNode = node.parentNode;
            moveOffset = domIndex(prev);
            prev = prev.previousSibling;
          }
          if (!prev) {
            node = node.parentNode;
            if (node == view.dom) { break }
            offset = 0;
          } else {
            node = prev;
            offset = nodeLen(node);
          }
        }
      }
      if (force) { setSelFocus(view, sel, node, offset); }
      else if (moveNode) { setSelFocus(view, sel, moveNode, moveOffset); }
    }

    // Make sure the cursor isn't directly before one or more ignored
    // nodes.
    function skipIgnoredNodesRight(view) {
      var sel = view.root.getSelection();
      var node = sel.focusNode, offset = sel.focusOffset;
      if (!node) { return }
      var len = nodeLen(node);
      var moveNode, moveOffset;
      for (;;) {
        if (offset < len) {
          if (node.nodeType != 1) { break }
          var after = node.childNodes[offset];
          if (isIgnorable(after)) {
            moveNode = node;
            moveOffset = ++offset;
          }
          else { break }
        } else if (isBlockNode(node)) {
          break
        } else {
          var next = node.nextSibling;
          while (next && isIgnorable(next)) {
            moveNode = next.parentNode;
            moveOffset = domIndex(next) + 1;
            next = next.nextSibling;
          }
          if (!next) {
            node = node.parentNode;
            if (node == view.dom) { break }
            offset = len = 0;
          } else {
            node = next;
            offset = 0;
            len = nodeLen(node);
          }
        }
      }
      if (moveNode) { setSelFocus(view, sel, moveNode, moveOffset); }
    }

    function isBlockNode(dom) {
      var desc = dom.pmViewDesc;
      return desc && desc.node && desc.node.isBlock
    }

    function setSelFocus(view, sel, node, offset) {
      if (selectionCollapsed(sel)) {
        var range = document.createRange();
        range.setEnd(node, offset);
        range.setStart(node, offset);
        sel.removeAllRanges();
        sel.addRange(range);
      } else if (sel.extend) {
        sel.extend(node, offset);
      }
      view.domObserver.setCurSelection();
      var state = view.state;
      // If no state update ends up happening, reset the selection.
      setTimeout(function () {
        if (view.state == state) { selectionToDOM(view); }
      }, 50);
    }

    // : (EditorState, number)
    // Check whether vertical selection motion would involve node
    // selections. If so, apply it (if not, the result is left to the
    // browser)
    function selectVertically(view, dir, mods) {
      var sel = view.state.selection;
      if (sel instanceof TextSelection && !sel.empty || mods.indexOf("s") > -1) { return false }
      if (result.mac && mods.indexOf("m") > -1) { return false }
      var $from = sel.$from;
      var $to = sel.$to;

      if (!$from.parent.inlineContent || view.endOfTextblock(dir < 0 ? "up" : "down")) {
        var next = moveSelectionBlock(view.state, dir);
        if (next && (next instanceof NodeSelection))
          { return apply(view, next) }
      }
      if (!$from.parent.inlineContent) {
        var beyond = Selection.findFrom(dir < 0 ? $from : $to, dir);
        return beyond ? apply(view, beyond) : true
      }
      return false
    }

    function stopNativeHorizontalDelete(view, dir) {
      if (!(view.state.selection instanceof TextSelection)) { return true }
      var ref = view.state.selection;
      var $head = ref.$head;
      var $anchor = ref.$anchor;
      var empty = ref.empty;
      if (!$head.sameParent($anchor)) { return true }
      if (!empty) { return false }
      if (view.endOfTextblock(dir > 0 ? "forward" : "backward")) { return true }
      var nextNode = !$head.textOffset && (dir < 0 ? $head.nodeBefore : $head.nodeAfter);
      if (nextNode && !nextNode.isText) {
        var tr = view.state.tr;
        if (dir < 0) { tr.delete($head.pos - nextNode.nodeSize, $head.pos); }
        else { tr.delete($head.pos, $head.pos + nextNode.nodeSize); }
        view.dispatch(tr);
        return true
      }
      return false
    }

    function switchEditable(view, node, state) {
      view.domObserver.stop();
      node.contentEditable = state;
      view.domObserver.start();
    }

    // Issue #867 / #1090 / https://bugs.chromium.org/p/chromium/issues/detail?id=903821
    // In which Safari (and at some point in the past, Chrome) does really
    // wrong things when the down arrow is pressed when the cursor is
    // directly at the start of a textblock and has an uneditable node
    // after it
    function safariDownArrowBug(view) {
      if (!result.safari || view.state.selection.$head.parentOffset > 0) { return }
      var ref = view.root.getSelection();
      var focusNode = ref.focusNode;
      var focusOffset = ref.focusOffset;
      if (focusNode && focusNode.nodeType == 1 && focusOffset == 0 &&
          focusNode.firstChild && focusNode.firstChild.contentEditable == "false") {
        var child = focusNode.firstChild;
        switchEditable(view, child, true);
        setTimeout(function () { return switchEditable(view, child, false); }, 20);
      }
    }

    // A backdrop key mapping used to make sure we always suppress keys
    // that have a dangerous default effect, even if the commands they are
    // bound to return false, and to make sure that cursor-motion keys
    // find a cursor (as opposed to a node selection) when pressed. For
    // cursor-motion keys, the code in the handlers also takes care of
    // block selections.

    function getMods(event) {
      var result = "";
      if (event.ctrlKey) { result += "c"; }
      if (event.metaKey) { result += "m"; }
      if (event.altKey) { result += "a"; }
      if (event.shiftKey) { result += "s"; }
      return result
    }

    function captureKeyDown(view, event) {
      var code = event.keyCode, mods = getMods(event);
      if (code == 8 || (result.mac && code == 72 && mods == "c")) { // Backspace, Ctrl-h on Mac
        return stopNativeHorizontalDelete(view, -1) || skipIgnoredNodesLeft(view)
      } else if (code == 46 || (result.mac && code == 68 && mods == "c")) { // Delete, Ctrl-d on Mac
        return stopNativeHorizontalDelete(view, 1) || skipIgnoredNodesRight(view)
      } else if (code == 13 || code == 27) { // Enter, Esc
        return true
      } else if (code == 37) { // Left arrow
        return selectHorizontally(view, -1, mods) || skipIgnoredNodesLeft(view)
      } else if (code == 39) { // Right arrow
        return selectHorizontally(view, 1, mods) || skipIgnoredNodesRight(view)
      } else if (code == 38) { // Up arrow
        return selectVertically(view, -1, mods) || skipIgnoredNodesLeft(view)
      } else if (code == 40) { // Down arrow
        return safariDownArrowBug(view) || selectVertically(view, 1, mods) || skipIgnoredNodesRight(view)
      } else if (mods == (result.mac ? "m" : "c") &&
                 (code == 66 || code == 73 || code == 89 || code == 90)) { // Mod-[biyz]
        return true
      }
      return false
    }

    // Note that all referencing and parsing is done with the
    // start-of-operation selection and document, since that's the one
    // that the DOM represents. If any changes came in in the meantime,
    // the modification is mapped over those before it is applied, in
    // readDOMChange.

    function parseBetween(view, from_, to_) {
      var ref = view.docView.parseRange(from_, to_);
      var parent = ref.node;
      var fromOffset = ref.fromOffset;
      var toOffset = ref.toOffset;
      var from = ref.from;
      var to = ref.to;

      var domSel = view.root.getSelection(), find = null, anchor = domSel.anchorNode;
      if (anchor && view.dom.contains(anchor.nodeType == 1 ? anchor : anchor.parentNode)) {
        find = [{node: anchor, offset: domSel.anchorOffset}];
        if (!selectionCollapsed(domSel))
          { find.push({node: domSel.focusNode, offset: domSel.focusOffset}); }
      }
      // Work around issue in Chrome where backspacing sometimes replaces
      // the deleted content with a random BR node (issues #799, #831)
      if (result.chrome && view.lastKeyCode === 8) {
        for (var off = toOffset; off > fromOffset; off--) {
          var node = parent.childNodes[off - 1], desc = node.pmViewDesc;
          if (node.nodeType == "BR" && !desc) { toOffset = off; break }
          if (!desc || desc.size) { break }
        }
      }
      var startDoc = view.state.doc;
      var parser = view.someProp("domParser") || DOMParser.fromSchema(view.state.schema);
      var $from = startDoc.resolve(from);

      var sel = null, doc = parser.parse(parent, {
        topNode: $from.parent,
        topMatch: $from.parent.contentMatchAt($from.index()),
        topOpen: true,
        from: fromOffset,
        to: toOffset,
        preserveWhitespace: $from.parent.type.spec.code ? "full" : true,
        editableContent: true,
        findPositions: find,
        ruleFromNode: ruleFromNode,
        context: $from
      });
      if (find && find[0].pos != null) {
        var anchor$1 = find[0].pos, head = find[1] && find[1].pos;
        if (head == null) { head = anchor$1; }
        sel = {anchor: anchor$1 + from, head: head + from};
      }
      return {doc: doc, sel: sel, from: from, to: to}
    }

    function ruleFromNode(dom) {
      var desc = dom.pmViewDesc;
      if (desc) {
        return desc.parseRule()
      } else if (dom.nodeName == "BR" && dom.parentNode) {
        // Safari replaces the list item or table cell with a BR
        // directly in the list node (?!) if you delete the last
        // character in a list item or table cell (#708, #862)
        if (result.safari && /^(ul|ol)$/i.test(dom.parentNode.nodeName)) {
          var skip = document.createElement("div");
          skip.appendChild(document.createElement("li"));
          return {skip: skip}
        } else if (dom.parentNode.lastChild == dom || result.safari && /^(tr|table)$/i.test(dom.parentNode.nodeName)) {
          return {ignore: true}
        }
      } else if (dom.nodeName == "IMG" && dom.getAttribute("mark-placeholder")) {
        return {ignore: true}
      }
    }

    function readDOMChange(view, from, to, typeOver, addedNodes) {
      if (from < 0) {
        var origin = view.lastSelectionTime > Date.now() - 50 ? view.lastSelectionOrigin : null;
        var newSel = selectionFromDOM(view, origin);
        if (newSel && !view.state.selection.eq(newSel)) {
          var tr$1 = view.state.tr.setSelection(newSel);
          if (origin == "pointer") { tr$1.setMeta("pointer", true); }
          else if (origin == "key") { tr$1.scrollIntoView(); }
          view.dispatch(tr$1);
        }
        return
      }

      var $before = view.state.doc.resolve(from);
      var shared = $before.sharedDepth(to);
      from = $before.before(shared + 1);
      to = view.state.doc.resolve(to).after(shared + 1);

      var sel = view.state.selection;
      var parse = parseBetween(view, from, to);
      // Chrome sometimes leaves the cursor before the inserted text when
      // composing after a cursor wrapper. This moves it forward.
      if (result.chrome && view.cursorWrapper && parse.sel && parse.sel.anchor == view.cursorWrapper.deco.from) {
        var text = view.cursorWrapper.deco.type.toDOM.nextSibling;
        var size = text && text.nodeValue ? text.nodeValue.length : 1;
        parse.sel = {anchor: parse.sel.anchor + size, head: parse.sel.anchor + size};
      }

      var doc = view.state.doc, compare = doc.slice(parse.from, parse.to);
      var preferredPos, preferredSide;
      // Prefer anchoring to end when Backspace is pressed
      if (view.lastKeyCode === 8 && Date.now() - 100 < view.lastKeyCodeTime) {
        preferredPos = view.state.selection.to;
        preferredSide = "end";
      } else {
        preferredPos = view.state.selection.from;
        preferredSide = "start";
      }
      view.lastKeyCode = null;

      var change = findDiff(compare.content, parse.doc.content, parse.from, preferredPos, preferredSide);
      if (!change) {
        if (typeOver && sel instanceof TextSelection && !sel.empty && sel.$head.sameParent(sel.$anchor) &&
            !view.composing && !(parse.sel && parse.sel.anchor != parse.sel.head)) {
          change = {start: sel.from, endA: sel.to, endB: sel.to};
        } else if (result.ios && view.lastIOSEnter > Date.now() - 225 &&
                   addedNodes.some(function (n) { return n.nodeName == "DIV" || n.nodeName == "P"; }) &&
                   view.someProp("handleKeyDown", function (f) { return f(view, keyEvent(13, "Enter")); })) {
          view.lastIOSEnter = 0;
          return
        } else {
          if (parse.sel) {
            var sel$1 = resolveSelection(view, view.state.doc, parse.sel);
            if (sel$1 && !sel$1.eq(view.state.selection)) { view.dispatch(view.state.tr.setSelection(sel$1)); }
          }
          return
        }
      }
      view.domChangeCount++;
      // Handle the case where overwriting a selection by typing matches
      // the start or end of the selected content, creating a change
      // that's smaller than what was actually overwritten.
      if (view.state.selection.from < view.state.selection.to &&
          change.start == change.endB &&
          view.state.selection instanceof TextSelection) {
        if (change.start > view.state.selection.from && change.start <= view.state.selection.from + 2) {
          change.start = view.state.selection.from;
        } else if (change.endA < view.state.selection.to && change.endA >= view.state.selection.to - 2) {
          change.endB += (view.state.selection.to - change.endA);
          change.endA = view.state.selection.to;
        }
      }

      // IE11 will insert a non-breaking space _ahead_ of the space after
      // the cursor space when adding a space before another space. When
      // that happened, adjust the change to cover the space instead.
      if (result.ie && result.ie_version <= 11 && change.endB == change.start + 1 &&
          change.endA == change.start && change.start > parse.from &&
          parse.doc.textBetween(change.start - parse.from - 1, change.start - parse.from + 1) == " \u00a0") {
        change.start--;
        change.endA--;
        change.endB--;
      }

      var $from = parse.doc.resolveNoCache(change.start - parse.from);
      var $to = parse.doc.resolveNoCache(change.endB - parse.from);
      var inlineChange = $from.sameParent($to) && $from.parent.inlineContent;
      var nextSel;
      // If this looks like the effect of pressing Enter (or was recorded
      // as being an iOS enter press), just dispatch an Enter key instead.
      if (((result.ios && view.lastIOSEnter > Date.now() - 225 &&
            (!inlineChange || addedNodes.some(function (n) { return n.nodeName == "DIV" || n.nodeName == "P"; }))) ||
           (!inlineChange && $from.pos < parse.doc.content.size &&
            (nextSel = Selection.findFrom(parse.doc.resolve($from.pos + 1), 1, true)) &&
            nextSel.head == $to.pos)) &&
          view.someProp("handleKeyDown", function (f) { return f(view, keyEvent(13, "Enter")); })) {
        view.lastIOSEnter = 0;
        return
      }
      // Same for backspace
      if (view.state.selection.anchor > change.start &&
          looksLikeJoin(doc, change.start, change.endA, $from, $to) &&
          view.someProp("handleKeyDown", function (f) { return f(view, keyEvent(8, "Backspace")); })) {
        if (result.android && result.chrome) { view.domObserver.suppressSelectionUpdates(); } // #820
        return
      }

      // This tries to detect Android virtual keyboard
      // enter-and-pick-suggestion action. That sometimes (see issue
      // #1059) first fires a DOM mutation, before moving the selection to
      // the newly created block. And then, because ProseMirror cleans up
      // the DOM selection, it gives up moving the selection entirely,
      // leaving the cursor in the wrong place. When that happens, we drop
      // the new paragraph from the initial change, and fire a simulated
      // enter key afterwards.
      if (result.android && !inlineChange && $from.start() != $to.start() && $to.parentOffset == 0 && $from.depth == $to.depth &&
          parse.sel && parse.sel.anchor == parse.sel.head && parse.sel.head == change.endA) {
        change.endB -= 2;
        $to = parse.doc.resolveNoCache(change.endB - parse.from);
        setTimeout(function () {
          view.someProp("handleKeyDown", function (f) { return f(view, keyEvent(13, "Enter")); });
        }, 20);
      }

      var chFrom = change.start, chTo = change.endA;

      var tr, storedMarks, markChange, $from1;
      if (inlineChange) {
        if ($from.pos == $to.pos) { // Deletion
          // IE11 sometimes weirdly moves the DOM selection around after
          // backspacing out the first element in a textblock
          if (result.ie && result.ie_version <= 11 && $from.parentOffset == 0) {
            view.domObserver.suppressSelectionUpdates();
            setTimeout(function () { return selectionToDOM(view); }, 20);
          }
          tr = view.state.tr.delete(chFrom, chTo);
          storedMarks = doc.resolve(change.start).marksAcross(doc.resolve(change.endA));
        } else if ( // Adding or removing a mark
          change.endA == change.endB && ($from1 = doc.resolve(change.start)) &&
          (markChange = isMarkChange($from.parent.content.cut($from.parentOffset, $to.parentOffset),
                                     $from1.parent.content.cut($from1.parentOffset, change.endA - $from1.start())))
        ) {
          tr = view.state.tr;
          if (markChange.type == "add") { tr.addMark(chFrom, chTo, markChange.mark); }
          else { tr.removeMark(chFrom, chTo, markChange.mark); }
        } else if ($from.parent.child($from.index()).isText && $from.index() == $to.index() - ($to.textOffset ? 0 : 1)) {
          // Both positions in the same text node -- simply insert text
          var text$1 = $from.parent.textBetween($from.parentOffset, $to.parentOffset);
          if (view.someProp("handleTextInput", function (f) { return f(view, chFrom, chTo, text$1); })) { return }
          tr = view.state.tr.insertText(text$1, chFrom, chTo);
        }
      }

      if (!tr)
        { tr = view.state.tr.replace(chFrom, chTo, parse.doc.slice(change.start - parse.from, change.endB - parse.from)); }
      if (parse.sel) {
        var sel$2 = resolveSelection(view, tr.doc, parse.sel);
        // Chrome Android will sometimes, during composition, report the
        // selection in the wrong place. If it looks like that is
        // happening, don't update the selection.
        // Edge just doesn't move the cursor forward when you start typing
        // in an empty block or between br nodes.
        if (sel$2 && !(result.chrome && result.android && view.composing && sel$2.empty &&
                       (sel$2.head == chFrom || sel$2.head == tr.mapping.map(chTo) - 1) ||
                     result.ie && sel$2.empty && sel$2.head == chFrom))
          { tr.setSelection(sel$2); }
      }
      if (storedMarks) { tr.ensureMarks(storedMarks); }
      view.dispatch(tr.scrollIntoView());
    }

    function resolveSelection(view, doc, parsedSel) {
      if (Math.max(parsedSel.anchor, parsedSel.head) > doc.content.size) { return null }
      return selectionBetween(view, doc.resolve(parsedSel.anchor), doc.resolve(parsedSel.head))
    }

    // : (Fragment, Fragment) → ?{mark: Mark, type: string}
    // Given two same-length, non-empty fragments of inline content,
    // determine whether the first could be created from the second by
    // removing or adding a single mark type.
    function isMarkChange(cur, prev) {
      var curMarks = cur.firstChild.marks, prevMarks = prev.firstChild.marks;
      var added = curMarks, removed = prevMarks, type, mark, update;
      for (var i = 0; i < prevMarks.length; i++) { added = prevMarks[i].removeFromSet(added); }
      for (var i$1 = 0; i$1 < curMarks.length; i$1++) { removed = curMarks[i$1].removeFromSet(removed); }
      if (added.length == 1 && removed.length == 0) {
        mark = added[0];
        type = "add";
        update = function (node) { return node.mark(mark.addToSet(node.marks)); };
      } else if (added.length == 0 && removed.length == 1) {
        mark = removed[0];
        type = "remove";
        update = function (node) { return node.mark(mark.removeFromSet(node.marks)); };
      } else {
        return null
      }
      var updated = [];
      for (var i$2 = 0; i$2 < prev.childCount; i$2++) { updated.push(update(prev.child(i$2))); }
      if (Fragment.from(updated).eq(cur)) { return {mark: mark, type: type} }
    }

    function looksLikeJoin(old, start, end, $newStart, $newEnd) {
      if (!$newStart.parent.isTextblock ||
          // The content must have shrunk
          end - start <= $newEnd.pos - $newStart.pos ||
          // newEnd must point directly at or after the end of the block that newStart points into
          skipClosingAndOpening($newStart, true, false) < $newEnd.pos)
        { return false }

      var $start = old.resolve(start);
      // Start must be at the end of a block
      if ($start.parentOffset < $start.parent.content.size || !$start.parent.isTextblock)
        { return false }
      var $next = old.resolve(skipClosingAndOpening($start, true, true));
      // The next textblock must start before end and end near it
      if (!$next.parent.isTextblock || $next.pos > end ||
          skipClosingAndOpening($next, true, false) < end)
        { return false }

      // The fragments after the join point must match
      return $newStart.parent.content.cut($newStart.parentOffset).eq($next.parent.content)
    }

    function skipClosingAndOpening($pos, fromEnd, mayOpen) {
      var depth = $pos.depth, end = fromEnd ? $pos.end() : $pos.pos;
      while (depth > 0 && (fromEnd || $pos.indexAfter(depth) == $pos.node(depth).childCount)) {
        depth--;
        end++;
        fromEnd = false;
      }
      if (mayOpen) {
        var next = $pos.node(depth).maybeChild($pos.indexAfter(depth));
        while (next && !next.isLeaf) {
          next = next.firstChild;
          end++;
        }
      }
      return end
    }

    function findDiff(a, b, pos, preferredPos, preferredSide) {
      var start = a.findDiffStart(b, pos);
      if (start == null) { return null }
      var ref = a.findDiffEnd(b, pos + a.size, pos + b.size);
      var endA = ref.a;
      var endB = ref.b;
      if (preferredSide == "end") {
        var adjust = Math.max(0, start - Math.min(endA, endB));
        preferredPos -= endA + adjust - start;
      }
      if (endA < start && a.size < b.size) {
        var move = preferredPos <= start && preferredPos >= endA ? start - preferredPos : 0;
        start -= move;
        endB = start + (endB - endA);
        endA = start;
      } else if (endB < start) {
        var move$1 = preferredPos <= start && preferredPos >= endB ? start - preferredPos : 0;
        start -= move$1;
        endA = start + (endA - endB);
        endB = start;
      }
      return {start: start, endA: endA, endB: endB}
    }

    function serializeForClipboard(view, slice) {
      var context = [];
      var content = slice.content;
      var openStart = slice.openStart;
      var openEnd = slice.openEnd;
      while (openStart > 1 && openEnd > 1 && content.childCount == 1 && content.firstChild.childCount == 1) {
        openStart--;
        openEnd--;
        var node = content.firstChild;
        context.push(node.type.name, node.attrs != node.type.defaultAttrs ? node.attrs : null);
        content = node.content;
      }

      var serializer = view.someProp("clipboardSerializer") || DOMSerializer.fromSchema(view.state.schema);
      var doc = detachedDoc(), wrap = doc.createElement("div");
      wrap.appendChild(serializer.serializeFragment(content, {document: doc}));

      var firstChild = wrap.firstChild, needsWrap;
      while (firstChild && firstChild.nodeType == 1 && (needsWrap = wrapMap[firstChild.nodeName.toLowerCase()])) {
        for (var i = needsWrap.length - 1; i >= 0; i--) {
          var wrapper = doc.createElement(needsWrap[i]);
          while (wrap.firstChild) { wrapper.appendChild(wrap.firstChild); }
          wrap.appendChild(wrapper);
        }
        firstChild = wrap.firstChild;
      }

      if (firstChild && firstChild.nodeType == 1)
        { firstChild.setAttribute("data-pm-slice", (openStart + " " + openEnd + " " + (JSON.stringify(context)))); }

      var text = view.someProp("clipboardTextSerializer", function (f) { return f(slice); }) ||
          slice.content.textBetween(0, slice.content.size, "\n\n");

      return {dom: wrap, text: text}
    }

    // : (EditorView, string, string, ?bool, ResolvedPos) → ?Slice
    // Read a slice of content from the clipboard (or drop data).
    function parseFromClipboard(view, text, html, plainText, $context) {
      var dom, inCode = $context.parent.type.spec.code, slice;
      if (!html && !text) { return null }
      var asText = text && (plainText || inCode || !html);
      if (asText) {
        view.someProp("transformPastedText", function (f) { text = f(text, inCode || plainText); });
        if (inCode) { return new Slice(Fragment.from(view.state.schema.text(text)), 0, 0) }
        var parsed = view.someProp("clipboardTextParser", function (f) { return f(text, $context, plainText); });
        if (parsed) {
          slice = parsed;
        } else {
          dom = document.createElement("div");
          text.trim().split(/(?:\r\n?|\n)+/).forEach(function (block) {
            dom.appendChild(document.createElement("p")).textContent = block;
          });
        }
      } else {
        view.someProp("transformPastedHTML", function (f) { html = f(html); });
        dom = readHTML(html);
      }

      var contextNode = dom && dom.querySelector("[data-pm-slice]");
      var sliceData = contextNode && /^(\d+) (\d+) (.*)/.exec(contextNode.getAttribute("data-pm-slice"));
      if (!slice) {
        var parser = view.someProp("clipboardParser") || view.someProp("domParser") || DOMParser.fromSchema(view.state.schema);
        slice = parser.parseSlice(dom, {preserveWhitespace: !!(asText || sliceData), context: $context});
      }
      if (sliceData)
        { slice = addContext(closeSlice(slice, +sliceData[1], +sliceData[2]), sliceData[3]); }
      else // HTML wasn't created by ProseMirror. Make sure top-level siblings are coherent
        { slice = Slice.maxOpen(normalizeSiblings(slice.content, $context), false); }

      view.someProp("transformPasted", function (f) { slice = f(slice); });
      return slice
    }

    // Takes a slice parsed with parseSlice, which means there hasn't been
    // any content-expression checking done on the top nodes, tries to
    // find a parent node in the current context that might fit the nodes,
    // and if successful, rebuilds the slice so that it fits into that parent.
    //
    // This addresses the problem that Transform.replace expects a
    // coherent slice, and will fail to place a set of siblings that don't
    // fit anywhere in the schema.
    function normalizeSiblings(fragment, $context) {
      if (fragment.childCount < 2) { return fragment }
      var loop = function ( d ) {
        var parent = $context.node(d);
        var match = parent.contentMatchAt($context.index(d));
        var lastWrap = (void 0), result = [];
        fragment.forEach(function (node) {
          if (!result) { return }
          var wrap = match.findWrapping(node.type), inLast;
          if (!wrap) { return result = null }
          if (inLast = result.length && lastWrap.length && addToSibling(wrap, lastWrap, node, result[result.length - 1], 0)) {
            result[result.length - 1] = inLast;
          } else {
            if (result.length) { result[result.length - 1] = closeRight(result[result.length - 1], lastWrap.length); }
            var wrapped = withWrappers(node, wrap);
            result.push(wrapped);
            match = match.matchType(wrapped.type, wrapped.attrs);
            lastWrap = wrap;
          }
        });
        if (result) { return { v: Fragment.from(result) } }
      };

      for (var d = $context.depth; d >= 0; d--) {
        var returned = loop( d );

        if ( returned ) return returned.v;
      }
      return fragment
    }

    function withWrappers(node, wrap, from) {
      if ( from === void 0 ) from = 0;

      for (var i = wrap.length - 1; i >= from; i--)
        { node = wrap[i].create(null, Fragment.from(node)); }
      return node
    }

    // Used to group adjacent nodes wrapped in similar parents by
    // normalizeSiblings into the same parent node
    function addToSibling(wrap, lastWrap, node, sibling, depth) {
      if (depth < wrap.length && depth < lastWrap.length && wrap[depth] == lastWrap[depth]) {
        var inner = addToSibling(wrap, lastWrap, node, sibling.lastChild, depth + 1);
        if (inner) { return sibling.copy(sibling.content.replaceChild(sibling.childCount - 1, inner)) }
        var match = sibling.contentMatchAt(sibling.childCount);
        if (match.matchType(depth == wrap.length - 1 ? node.type : wrap[depth + 1]))
          { return sibling.copy(sibling.content.append(Fragment.from(withWrappers(node, wrap, depth + 1)))) }
      }
    }

    function closeRight(node, depth) {
      if (depth == 0) { return node }
      var fragment = node.content.replaceChild(node.childCount - 1, closeRight(node.lastChild, depth - 1));
      var fill = node.contentMatchAt(node.childCount).fillBefore(Fragment.empty, true);
      return node.copy(fragment.append(fill))
    }

    function closeRange(fragment, side, from, to, depth, openEnd) {
      var node = side < 0 ? fragment.firstChild : fragment.lastChild, inner = node.content;
      if (depth < to - 1) { inner = closeRange(inner, side, from, to, depth + 1, openEnd); }
      if (depth >= from)
        { inner = side < 0 ? node.contentMatchAt(0).fillBefore(inner, fragment.childCount > 1 || openEnd <= depth).append(inner)
          : inner.append(node.contentMatchAt(node.childCount).fillBefore(Fragment.empty, true)); }
      return fragment.replaceChild(side < 0 ? 0 : fragment.childCount - 1, node.copy(inner))
    }

    function closeSlice(slice, openStart, openEnd) {
      if (openStart < slice.openStart)
        { slice = new Slice(closeRange(slice.content, -1, openStart, slice.openStart, 0, slice.openEnd), openStart, slice.openEnd); }
      if (openEnd < slice.openEnd)
        { slice = new Slice(closeRange(slice.content, 1, openEnd, slice.openEnd, 0, 0), slice.openStart, openEnd); }
      return slice
    }

    // Trick from jQuery -- some elements must be wrapped in other
    // elements for innerHTML to work. I.e. if you do `div.innerHTML =
    // "<td>..</td>"` the table cells are ignored.
    var wrapMap = {
      thead: ["table"],
      tbody: ["table"],
      tfoot: ["table"],
      caption: ["table"],
      colgroup: ["table"],
      col: ["table", "colgroup"],
      tr: ["table", "tbody"],
      td: ["table", "tbody", "tr"],
      th: ["table", "tbody", "tr"]
    };

    var _detachedDoc = null;
    function detachedDoc() {
      return _detachedDoc || (_detachedDoc = document.implementation.createHTMLDocument("title"))
    }

    function readHTML(html) {
      var metas = /(\s*<meta [^>]*>)*/.exec(html);
      if (metas) { html = html.slice(metas[0].length); }
      var elt = detachedDoc().createElement("div");
      var firstTag = /(?:<meta [^>]*>)*<([a-z][^>\s]+)/i.exec(html), wrap, depth = 0;
      if (wrap = firstTag && wrapMap[firstTag[1].toLowerCase()]) {
        html = wrap.map(function (n) { return "<" + n + ">"; }).join("") + html + wrap.map(function (n) { return "</" + n + ">"; }).reverse().join("");
        depth = wrap.length;
      }
      elt.innerHTML = html;
      for (var i = 0; i < depth; i++) { elt = elt.firstChild; }
      return elt
    }

    function addContext(slice, context) {
      if (!slice.size) { return slice }
      var schema = slice.content.firstChild.type.schema, array;
      try { array = JSON.parse(context); }
      catch(e) { return slice }
      var content = slice.content;
      var openStart = slice.openStart;
      var openEnd = slice.openEnd;
      for (var i = array.length - 2; i >= 0; i -= 2) {
        var type = schema.nodes[array[i]];
        if (!type || type.hasRequiredAttrs()) { break }
        content = Fragment.from(type.create(array[i + 1], content));
        openStart++; openEnd++;
      }
      return new Slice(content, openStart, openEnd)
    }

    var observeOptions = {
      childList: true,
      characterData: true,
      characterDataOldValue: true,
      attributes: true,
      attributeOldValue: true,
      subtree: true
    };
    // IE11 has very broken mutation observers, so we also listen to DOMCharacterDataModified
    var useCharData = result.ie && result.ie_version <= 11;

    var SelectionState = function SelectionState() {
      this.anchorNode = this.anchorOffset = this.focusNode = this.focusOffset = null;
    };

    SelectionState.prototype.set = function set (sel) {
      this.anchorNode = sel.anchorNode; this.anchorOffset = sel.anchorOffset;
      this.focusNode = sel.focusNode; this.focusOffset = sel.focusOffset;
    };

    SelectionState.prototype.eq = function eq (sel) {
      return sel.anchorNode == this.anchorNode && sel.anchorOffset == this.anchorOffset &&
        sel.focusNode == this.focusNode && sel.focusOffset == this.focusOffset
    };

    var DOMObserver = function DOMObserver(view, handleDOMChange) {
      var this$1 = this;

      this.view = view;
      this.handleDOMChange = handleDOMChange;
      this.queue = [];
      this.flushingSoon = -1;
      this.observer = window.MutationObserver &&
        new window.MutationObserver(function (mutations) {
          for (var i = 0; i < mutations.length; i++) { this$1.queue.push(mutations[i]); }
          // IE11 will sometimes (on backspacing out a single character
          // text node after a BR node) call the observer callback
          // before actually updating the DOM, which will cause
          // ProseMirror to miss the change (see #930)
          if (result.ie && result.ie_version <= 11 && mutations.some(
            function (m) { return m.type == "childList" && m.removedNodes.length ||
                 m.type == "characterData" && m.oldValue.length > m.target.nodeValue.length; }))
            { this$1.flushSoon(); }
          else
            { this$1.flush(); }
        });
      this.currentSelection = new SelectionState;
      if (useCharData) {
        this.onCharData = function (e) {
          this$1.queue.push({target: e.target, type: "characterData", oldValue: e.prevValue});
          this$1.flushSoon();
        };
      }
      this.onSelectionChange = this.onSelectionChange.bind(this);
      this.suppressingSelectionUpdates = false;
    };

    DOMObserver.prototype.flushSoon = function flushSoon () {
        var this$1 = this;

      if (this.flushingSoon < 0)
        { this.flushingSoon = window.setTimeout(function () { this$1.flushingSoon = -1; this$1.flush(); }, 20); }
    };

    DOMObserver.prototype.forceFlush = function forceFlush () {
      if (this.flushingSoon > -1) {
        window.clearTimeout(this.flushingSoon);
        this.flushingSoon = -1;
        this.flush();
      }
    };

    DOMObserver.prototype.start = function start () {
      if (this.observer)
        { this.observer.observe(this.view.dom, observeOptions); }
      if (useCharData)
        { this.view.dom.addEventListener("DOMCharacterDataModified", this.onCharData); }
      this.connectSelection();
    };

    DOMObserver.prototype.stop = function stop () {
        var this$1 = this;

      if (this.observer) {
        var take = this.observer.takeRecords();
        if (take.length) {
          for (var i = 0; i < take.length; i++) { this.queue.push(take[i]); }
          window.setTimeout(function () { return this$1.flush(); }, 20);
        }
        this.observer.disconnect();
      }
      if (useCharData) { this.view.dom.removeEventListener("DOMCharacterDataModified", this.onCharData); }
      this.disconnectSelection();
    };

    DOMObserver.prototype.connectSelection = function connectSelection () {
      this.view.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange);
    };

    DOMObserver.prototype.disconnectSelection = function disconnectSelection () {
      this.view.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange);
    };

    DOMObserver.prototype.suppressSelectionUpdates = function suppressSelectionUpdates () {
        var this$1 = this;

      this.suppressingSelectionUpdates = true;
      setTimeout(function () { return this$1.suppressingSelectionUpdates = false; }, 50);
    };

    DOMObserver.prototype.onSelectionChange = function onSelectionChange () {
      if (!hasFocusAndSelection(this.view)) { return }
      if (this.suppressingSelectionUpdates) { return selectionToDOM(this.view) }
      // Deletions on IE11 fire their events in the wrong order, giving
      // us a selection change event before the DOM changes are
      // reported.
      if (result.ie && result.ie_version <= 11 && !this.view.state.selection.empty) {
        var sel = this.view.root.getSelection();
        // Selection.isCollapsed isn't reliable on IE
        if (sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset))
          { return this.flushSoon() }
      }
      this.flush();
    };

    DOMObserver.prototype.setCurSelection = function setCurSelection () {
      this.currentSelection.set(this.view.root.getSelection());
    };

    DOMObserver.prototype.ignoreSelectionChange = function ignoreSelectionChange (sel) {
      if (sel.rangeCount == 0) { return true }
      var container = sel.getRangeAt(0).commonAncestorContainer;
      var desc = this.view.docView.nearestDesc(container);
      if (desc && desc.ignoreMutation({type: "selection", target: container.nodeType == 3 ? container.parentNode : container})) {
        this.setCurSelection();
        return true
      }
    };

    DOMObserver.prototype.flush = function flush () {
      if (!this.view.docView || this.flushingSoon > -1) { return }
      var mutations = this.observer ? this.observer.takeRecords() : [];
      if (this.queue.length) {
        mutations = this.queue.concat(mutations);
        this.queue.length = 0;
      }

      var sel = this.view.root.getSelection();
      var newSel = !this.suppressingSelectionUpdates && !this.currentSelection.eq(sel) && hasSelection(this.view) && !this.ignoreSelectionChange(sel);

      var from = -1, to = -1, typeOver = false, added = [];
      if (this.view.editable) {
        for (var i = 0; i < mutations.length; i++) {
          var result$1 = this.registerMutation(mutations[i], added);
          if (result$1) {
            from = from < 0 ? result$1.from : Math.min(result$1.from, from);
            to = to < 0 ? result$1.to : Math.max(result$1.to, to);
            if (result$1.typeOver) { typeOver = true; }
          }
        }
      }

      if (result.gecko && added.length > 1) {
        var brs = added.filter(function (n) { return n.nodeName == "BR"; });
        if (brs.length == 2) {
          var a = brs[0];
            var b = brs[1];
          if (a.parentNode && a.parentNode.parentNode == b.parentNode) { b.remove(); }
          else { a.remove(); }
        }
      }

      if (from > -1 || newSel) {
        if (from > -1) {
          this.view.docView.markDirty(from, to);
          checkCSS(this.view);
        }
        this.handleDOMChange(from, to, typeOver, added);
        if (this.view.docView.dirty) { this.view.updateState(this.view.state); }
        else if (!this.currentSelection.eq(sel)) { selectionToDOM(this.view); }
        this.currentSelection.set(sel);
      }
    };

    DOMObserver.prototype.registerMutation = function registerMutation (mut, added) {
      // Ignore mutations inside nodes that were already noted as inserted
      if (added.indexOf(mut.target) > -1) { return null }
      var desc = this.view.docView.nearestDesc(mut.target);
      if (mut.type == "attributes" &&
          (desc == this.view.docView || mut.attributeName == "contenteditable" ||
           // Firefox sometimes fires spurious events for null/empty styles
           (mut.attributeName == "style" && !mut.oldValue && !mut.target.getAttribute("style"))))
        { return null }
      if (!desc || desc.ignoreMutation(mut)) { return null }

      if (mut.type == "childList") {
        var prev = mut.previousSibling, next = mut.nextSibling;
        if (result.ie && result.ie_version <= 11 && mut.addedNodes.length) {
          // IE11 gives us incorrect next/prev siblings for some
          // insertions, so if there are added nodes, recompute those
          for (var i = 0; i < mut.addedNodes.length; i++) {
            var ref = mut.addedNodes[i];
              var previousSibling = ref.previousSibling;
              var nextSibling = ref.nextSibling;
            if (!previousSibling || Array.prototype.indexOf.call(mut.addedNodes, previousSibling) < 0) { prev = previousSibling; }
            if (!nextSibling || Array.prototype.indexOf.call(mut.addedNodes, nextSibling) < 0) { next = nextSibling; }
          }
        }
        var fromOffset = prev && prev.parentNode == mut.target
            ? domIndex(prev) + 1 : 0;
        var from = desc.localPosFromDOM(mut.target, fromOffset, -1);
        var toOffset = next && next.parentNode == mut.target
            ? domIndex(next) : mut.target.childNodes.length;
        for (var i$1 = 0; i$1 < mut.addedNodes.length; i$1++) { added.push(mut.addedNodes[i$1]); }
        var to = desc.localPosFromDOM(mut.target, toOffset, 1);
        return {from: from, to: to}
      } else if (mut.type == "attributes") {
        return {from: desc.posAtStart - desc.border, to: desc.posAtEnd + desc.border}
      } else { // "characterData"
        return {
          from: desc.posAtStart,
          to: desc.posAtEnd,
          // An event was generated for a text change that didn't change
          // any text. Mark the dom change to fall back to assuming the
          // selection was typed over with an identical value if it can't
          // find another change.
          typeOver: mut.target.nodeValue == mut.oldValue
        }
      }
    };

    var cssChecked = false;

    function checkCSS(view) {
      if (cssChecked) { return }
      cssChecked = true;
      if (getComputedStyle(view.dom).whiteSpace == "normal")
        { console["warn"]("ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package."); }
    }

    // A collection of DOM events that occur within the editor, and callback functions
    // to invoke when the event fires.
    var handlers = {}, editHandlers = {};

    function initInput(view) {
      view.shiftKey = false;
      view.mouseDown = null;
      view.lastKeyCode = null;
      view.lastKeyCodeTime = 0;
      view.lastClick = {time: 0, x: 0, y: 0, type: ""};
      view.lastSelectionOrigin = null;
      view.lastSelectionTime = 0;

      view.lastIOSEnter = 0;
      view.lastIOSEnterFallbackTimeout = null;

      view.composing = false;
      view.composingTimeout = null;
      view.compositionNodes = [];
      view.compositionEndedAt = -2e8;

      view.domObserver = new DOMObserver(view, function (from, to, typeOver, added) { return readDOMChange(view, from, to, typeOver, added); });
      view.domObserver.start();
      // Used by hacks like the beforeinput handler to check whether anything happened in the DOM
      view.domChangeCount = 0;

      view.eventHandlers = Object.create(null);
      var loop = function ( event ) {
        var handler = handlers[event];
        view.dom.addEventListener(event, view.eventHandlers[event] = function (event) {
          if (eventBelongsToView(view, event) && !runCustomHandler(view, event) &&
              (view.editable || !(event.type in editHandlers)))
            { handler(view, event); }
        });
      };

      for (var event in handlers) loop( event );
      // On Safari, for reasons beyond my understanding, adding an input
      // event handler makes an issue where the composition vanishes when
      // you press enter go away.
      if (result.safari) { view.dom.addEventListener("input", function () { return null; }); }

      ensureListeners(view);
    }

    function setSelectionOrigin(view, origin) {
      view.lastSelectionOrigin = origin;
      view.lastSelectionTime = Date.now();
    }

    function destroyInput(view) {
      view.domObserver.stop();
      for (var type in view.eventHandlers)
        { view.dom.removeEventListener(type, view.eventHandlers[type]); }
      clearTimeout(view.composingTimeout);
      clearTimeout(view.lastIOSEnterFallbackTimeout);
    }

    function ensureListeners(view) {
      view.someProp("handleDOMEvents", function (currentHandlers) {
        for (var type in currentHandlers) { if (!view.eventHandlers[type])
          { view.dom.addEventListener(type, view.eventHandlers[type] = function (event) { return runCustomHandler(view, event); }); } }
      });
    }

    function runCustomHandler(view, event) {
      return view.someProp("handleDOMEvents", function (handlers) {
        var handler = handlers[event.type];
        return handler ? handler(view, event) || event.defaultPrevented : false
      })
    }

    function eventBelongsToView(view, event) {
      if (!event.bubbles) { return true }
      if (event.defaultPrevented) { return false }
      for (var node = event.target; node != view.dom; node = node.parentNode)
        { if (!node || node.nodeType == 11 ||
            (node.pmViewDesc && node.pmViewDesc.stopEvent(event)))
          { return false } }
      return true
    }

    function dispatchEvent(view, event) {
      if (!runCustomHandler(view, event) && handlers[event.type] &&
          (view.editable || !(event.type in editHandlers)))
        { handlers[event.type](view, event); }
    }

    editHandlers.keydown = function (view, event) {
      view.shiftKey = event.keyCode == 16 || event.shiftKey;
      if (inOrNearComposition(view, event)) { return }
      view.domObserver.forceFlush();
      view.lastKeyCode = event.keyCode;
      view.lastKeyCodeTime = Date.now();
      // On iOS, if we preventDefault enter key presses, the virtual
      // keyboard gets confused. So the hack here is to set a flag that
      // makes the DOM change code recognize that what just happens should
      // be replaced by whatever the Enter key handlers do.
      if (result.ios && event.keyCode == 13 && !event.ctrlKey && !event.altKey && !event.metaKey) {
        var now = Date.now();
        view.lastIOSEnter = now;
        view.lastIOSEnterFallbackTimeout = setTimeout(function () {
          if (view.lastIOSEnter == now) {
            view.someProp("handleKeyDown", function (f) { return f(view, keyEvent(13, "Enter")); });
            view.lastIOSEnter = 0;
          }
        }, 200);
      } else if (view.someProp("handleKeyDown", function (f) { return f(view, event); }) || captureKeyDown(view, event)) {
        event.preventDefault();
      } else {
        setSelectionOrigin(view, "key");
      }
    };

    editHandlers.keyup = function (view, e) {
      if (e.keyCode == 16) { view.shiftKey = false; }
    };

    editHandlers.keypress = function (view, event) {
      if (inOrNearComposition(view, event) || !event.charCode ||
          event.ctrlKey && !event.altKey || result.mac && event.metaKey) { return }

      if (view.someProp("handleKeyPress", function (f) { return f(view, event); })) {
        event.preventDefault();
        return
      }

      var sel = view.state.selection;
      if (!(sel instanceof TextSelection) || !sel.$from.sameParent(sel.$to)) {
        var text = String.fromCharCode(event.charCode);
        if (!view.someProp("handleTextInput", function (f) { return f(view, sel.$from.pos, sel.$to.pos, text); }))
          { view.dispatch(view.state.tr.insertText(text).scrollIntoView()); }
        event.preventDefault();
      }
    };

    function eventCoords(event) { return {left: event.clientX, top: event.clientY} }

    function isNear(event, click) {
      var dx = click.x - event.clientX, dy = click.y - event.clientY;
      return dx * dx + dy * dy < 100
    }

    function runHandlerOnContext(view, propName, pos, inside, event) {
      if (inside == -1) { return false }
      var $pos = view.state.doc.resolve(inside);
      var loop = function ( i ) {
        if (view.someProp(propName, function (f) { return i > $pos.depth ? f(view, pos, $pos.nodeAfter, $pos.before(i), event, true)
                                                        : f(view, pos, $pos.node(i), $pos.before(i), event, false); }))
          { return { v: true } }
      };

      for (var i = $pos.depth + 1; i > 0; i--) {
        var returned = loop( i );

        if ( returned ) return returned.v;
      }
      return false
    }

    function updateSelection(view, selection, origin) {
      if (!view.focused) { view.focus(); }
      var tr = view.state.tr.setSelection(selection);
      if (origin == "pointer") { tr.setMeta("pointer", true); }
      view.dispatch(tr);
    }

    function selectClickedLeaf(view, inside) {
      if (inside == -1) { return false }
      var $pos = view.state.doc.resolve(inside), node = $pos.nodeAfter;
      if (node && node.isAtom && NodeSelection.isSelectable(node)) {
        updateSelection(view, new NodeSelection($pos), "pointer");
        return true
      }
      return false
    }

    function selectClickedNode(view, inside) {
      if (inside == -1) { return false }
      var sel = view.state.selection, selectedNode, selectAt;
      if (sel instanceof NodeSelection) { selectedNode = sel.node; }

      var $pos = view.state.doc.resolve(inside);
      for (var i = $pos.depth + 1; i > 0; i--) {
        var node = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);
        if (NodeSelection.isSelectable(node)) {
          if (selectedNode && sel.$from.depth > 0 &&
              i >= sel.$from.depth && $pos.before(sel.$from.depth + 1) == sel.$from.pos)
            { selectAt = $pos.before(sel.$from.depth); }
          else
            { selectAt = $pos.before(i); }
          break
        }
      }

      if (selectAt != null) {
        updateSelection(view, NodeSelection.create(view.state.doc, selectAt), "pointer");
        return true
      } else {
        return false
      }
    }

    function handleSingleClick(view, pos, inside, event, selectNode) {
      return runHandlerOnContext(view, "handleClickOn", pos, inside, event) ||
        view.someProp("handleClick", function (f) { return f(view, pos, event); }) ||
        (selectNode ? selectClickedNode(view, inside) : selectClickedLeaf(view, inside))
    }

    function handleDoubleClick(view, pos, inside, event) {
      return runHandlerOnContext(view, "handleDoubleClickOn", pos, inside, event) ||
        view.someProp("handleDoubleClick", function (f) { return f(view, pos, event); })
    }

    function handleTripleClick(view, pos, inside, event) {
      return runHandlerOnContext(view, "handleTripleClickOn", pos, inside, event) ||
        view.someProp("handleTripleClick", function (f) { return f(view, pos, event); }) ||
        defaultTripleClick(view, inside)
    }

    function defaultTripleClick(view, inside) {
      var doc = view.state.doc;
      if (inside == -1) {
        if (doc.inlineContent) {
          updateSelection(view, TextSelection.create(doc, 0, doc.content.size), "pointer");
          return true
        }
        return false
      }

      var $pos = doc.resolve(inside);
      for (var i = $pos.depth + 1; i > 0; i--) {
        var node = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);
        var nodePos = $pos.before(i);
        if (node.inlineContent)
          { updateSelection(view, TextSelection.create(doc, nodePos + 1, nodePos + 1 + node.content.size), "pointer"); }
        else if (NodeSelection.isSelectable(node))
          { updateSelection(view, NodeSelection.create(doc, nodePos), "pointer"); }
        else
          { continue }
        return true
      }
    }

    function forceDOMFlush(view) {
      return endComposition(view)
    }

    var selectNodeModifier = result.mac ? "metaKey" : "ctrlKey";

    handlers.mousedown = function (view, event) {
      view.shiftKey = event.shiftKey;
      var flushed = forceDOMFlush(view);
      var now = Date.now(), type = "singleClick";
      if (now - view.lastClick.time < 500 && isNear(event, view.lastClick) && !event[selectNodeModifier]) {
        if (view.lastClick.type == "singleClick") { type = "doubleClick"; }
        else if (view.lastClick.type == "doubleClick") { type = "tripleClick"; }
      }
      view.lastClick = {time: now, x: event.clientX, y: event.clientY, type: type};

      var pos = view.posAtCoords(eventCoords(event));
      if (!pos) { return }

      if (type == "singleClick")
        { view.mouseDown = new MouseDown(view, pos, event, flushed); }
      else if ((type == "doubleClick" ? handleDoubleClick : handleTripleClick)(view, pos.pos, pos.inside, event))
        { event.preventDefault(); }
      else
        { setSelectionOrigin(view, "pointer"); }
    };

    var MouseDown = function MouseDown(view, pos, event, flushed) {
      var this$1 = this;

      this.view = view;
      this.startDoc = view.state.doc;
      this.pos = pos;
      this.event = event;
      this.flushed = flushed;
      this.selectNode = event[selectNodeModifier];
      this.allowDefault = event.shiftKey;

      var targetNode, targetPos;
      if (pos.inside > -1) {
        targetNode = view.state.doc.nodeAt(pos.inside);
        targetPos = pos.inside;
      } else {
        var $pos = view.state.doc.resolve(pos.pos);
        targetNode = $pos.parent;
        targetPos = $pos.depth ? $pos.before() : 0;
      }

      this.mightDrag = null;

      var target = flushed ? null : event.target;
      var targetDesc = target ? view.docView.nearestDesc(target, true) : null;
      this.target = targetDesc ? targetDesc.dom : null;

      if (targetNode.type.spec.draggable && targetNode.type.spec.selectable !== false ||
          view.state.selection instanceof NodeSelection && targetPos == view.state.selection.from)
        { this.mightDrag = {node: targetNode,
                          pos: targetPos,
                          addAttr: this.target && !this.target.draggable,
                          setUneditable: this.target && result.gecko && !this.target.hasAttribute("contentEditable")}; }

      if (this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable)) {
        this.view.domObserver.stop();
        if (this.mightDrag.addAttr) { this.target.draggable = true; }
        if (this.mightDrag.setUneditable)
          { setTimeout(function () { return this$1.target.setAttribute("contentEditable", "false"); }, 20); }
        this.view.domObserver.start();
      }

      view.root.addEventListener("mouseup", this.up = this.up.bind(this));
      view.root.addEventListener("mousemove", this.move = this.move.bind(this));
      setSelectionOrigin(view, "pointer");
    };

    MouseDown.prototype.done = function done () {
      this.view.root.removeEventListener("mouseup", this.up);
      this.view.root.removeEventListener("mousemove", this.move);
      if (this.mightDrag && this.target) {
        this.view.domObserver.stop();
        if (this.mightDrag.addAttr) { this.target.removeAttribute("draggable"); }
        if (this.mightDrag.setUneditable) { this.target.removeAttribute("contentEditable"); }
        this.view.domObserver.start();
      }
      this.view.mouseDown = null;
    };

    MouseDown.prototype.up = function up (event) {
      this.done();

      if (!this.view.dom.contains(event.target.nodeType == 3 ? event.target.parentNode : event.target))
        { return }

      var pos = this.pos;
      if (this.view.state.doc != this.startDoc) { pos = this.view.posAtCoords(eventCoords(event)); }

      if (this.allowDefault || !pos) {
        setSelectionOrigin(this.view, "pointer");
      } else if (handleSingleClick(this.view, pos.pos, pos.inside, event, this.selectNode)) {
        event.preventDefault();
      } else if (this.flushed ||
                 // Safari ignores clicks on draggable elements
                 (result.safari && this.mightDrag && !this.mightDrag.node.isAtom) ||
                 // Chrome will sometimes treat a node selection as a
                 // cursor, but still report that the node is selected
                 // when asked through getSelection. You'll then get a
                 // situation where clicking at the point where that
                 // (hidden) cursor is doesn't change the selection, and
                 // thus doesn't get a reaction from ProseMirror. This
                 // works around that.
                 (result.chrome && !(this.view.state.selection instanceof TextSelection) &&
                  (pos.pos == this.view.state.selection.from || pos.pos == this.view.state.selection.to))) {
        updateSelection(this.view, Selection.near(this.view.state.doc.resolve(pos.pos)), "pointer");
        event.preventDefault();
      } else {
        setSelectionOrigin(this.view, "pointer");
      }
    };

    MouseDown.prototype.move = function move (event) {
      if (!this.allowDefault && (Math.abs(this.event.x - event.clientX) > 4 ||
                                 Math.abs(this.event.y - event.clientY) > 4))
        { this.allowDefault = true; }
      setSelectionOrigin(this.view, "pointer");
    };

    handlers.touchdown = function (view) {
      forceDOMFlush(view);
      setSelectionOrigin(view, "pointer");
    };

    handlers.contextmenu = function (view) { return forceDOMFlush(view); };

    function inOrNearComposition(view, event) {
      if (view.composing) { return true }
      // See https://www.stum.de/2016/06/24/handling-ime-events-in-javascript/.
      // On Japanese input method editors (IMEs), the Enter key is used to confirm character
      // selection. On Safari, when Enter is pressed, compositionend and keydown events are
      // emitted. The keydown event triggers newline insertion, which we don't want.
      // This method returns true if the keydown event should be ignored.
      // We only ignore it once, as pressing Enter a second time *should* insert a newline.
      // Furthermore, the keydown event timestamp must be close to the compositionEndedAt timestamp.
      // This guards against the case where compositionend is triggered without the keyboard
      // (e.g. character confirmation may be done with the mouse), and keydown is triggered
      // afterwards- we wouldn't want to ignore the keydown event in this case.
      if (result.safari && Math.abs(event.timeStamp - view.compositionEndedAt) < 500) {
        view.compositionEndedAt = -2e8;
        return true
      }
      return false
    }

    // Drop active composition after 5 seconds of inactivity on Android
    var timeoutComposition = result.android ? 5000 : -1;

    editHandlers.compositionstart = editHandlers.compositionupdate = function (view) {
      if (!view.composing) {
        view.domObserver.flush();
        var state = view.state;
        var $pos = state.selection.$from;
        if (state.selection.empty &&
            (state.storedMarks ||
             (!$pos.textOffset && $pos.parentOffset && $pos.nodeBefore.marks.some(function (m) { return m.type.spec.inclusive === false; })))) {
          // Need to wrap the cursor in mark nodes different from the ones in the DOM context
          view.markCursor = view.state.storedMarks || $pos.marks();
          endComposition(view, true);
          view.markCursor = null;
        } else {
          endComposition(view);
          // In firefox, if the cursor is after but outside a marked node,
          // the inserted text won't inherit the marks. So this moves it
          // inside if necessary.
          if (result.gecko && state.selection.empty && $pos.parentOffset && !$pos.textOffset && $pos.nodeBefore.marks.length) {
            var sel = view.root.getSelection();
            for (var node = sel.focusNode, offset = sel.focusOffset; node && node.nodeType == 1 && offset != 0;) {
              var before = offset < 0 ? node.lastChild : node.childNodes[offset - 1];
              if (!before) { break }
              if (before.nodeType == 3) {
                sel.collapse(before, before.nodeValue.length);
                break
              } else {
                node = before;
                offset = -1;
              }
            }
          }
        }
        view.composing = true;
      }
      scheduleComposeEnd(view, timeoutComposition);
    };

    editHandlers.compositionend = function (view, event) {
      if (view.composing) {
        view.composing = false;
        view.compositionEndedAt = event.timeStamp;
        scheduleComposeEnd(view, 20);
      }
    };

    function scheduleComposeEnd(view, delay) {
      clearTimeout(view.composingTimeout);
      if (delay > -1) { view.composingTimeout = setTimeout(function () { return endComposition(view); }, delay); }
    }

    function clearComposition(view) {
      view.composing = false;
      while (view.compositionNodes.length > 0) { view.compositionNodes.pop().markParentsDirty(); }
    }

    function endComposition(view, forceUpdate) {
      view.domObserver.forceFlush();
      clearComposition(view);
      if (forceUpdate || view.docView.dirty) {
        var sel = selectionFromDOM(view);
        if (sel && !sel.eq(view.state.selection)) { view.dispatch(view.state.tr.setSelection(sel)); }
        else { view.updateState(view.state); }
        return true
      }
      return false
    }

    function captureCopy(view, dom) {
      // The extra wrapper is somehow necessary on IE/Edge to prevent the
      // content from being mangled when it is put onto the clipboard
      if (!view.dom.parentNode) { return }
      var wrap = view.dom.parentNode.appendChild(document.createElement("div"));
      wrap.appendChild(dom);
      wrap.style.cssText = "position: fixed; left: -10000px; top: 10px";
      var sel = getSelection(), range = document.createRange();
      range.selectNodeContents(dom);
      // Done because IE will fire a selectionchange moving the selection
      // to its start when removeAllRanges is called and the editor still
      // has focus (which will mess up the editor's selection state).
      view.dom.blur();
      sel.removeAllRanges();
      sel.addRange(range);
      setTimeout(function () {
        if (wrap.parentNode) { wrap.parentNode.removeChild(wrap); }
        view.focus();
      }, 50);
    }

    // This is very crude, but unfortunately both these browsers _pretend_
    // that they have a clipboard API—all the objects and methods are
    // there, they just don't work, and they are hard to test.
    var brokenClipboardAPI = (result.ie && result.ie_version < 15) ||
          (result.ios && result.webkit_version < 604);

    handlers.copy = editHandlers.cut = function (view, e) {
      var sel = view.state.selection, cut = e.type == "cut";
      if (sel.empty) { return }

      // IE and Edge's clipboard interface is completely broken
      var data = brokenClipboardAPI ? null : e.clipboardData;
      var slice = sel.content();
      var ref = serializeForClipboard(view, slice);
      var dom = ref.dom;
      var text = ref.text;
      if (data) {
        e.preventDefault();
        data.clearData();
        data.setData("text/html", dom.innerHTML);
        data.setData("text/plain", text);
      } else {
        captureCopy(view, dom);
      }
      if (cut) { view.dispatch(view.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut")); }
    };

    function sliceSingleNode(slice) {
      return slice.openStart == 0 && slice.openEnd == 0 && slice.content.childCount == 1 ? slice.content.firstChild : null
    }

    function capturePaste(view, e) {
      if (!view.dom.parentNode) { return }
      var plainText = view.shiftKey || view.state.selection.$from.parent.type.spec.code;
      var target = view.dom.parentNode.appendChild(document.createElement(plainText ? "textarea" : "div"));
      if (!plainText) { target.contentEditable = "true"; }
      target.style.cssText = "position: fixed; left: -10000px; top: 10px";
      target.focus();
      setTimeout(function () {
        view.focus();
        if (target.parentNode) { target.parentNode.removeChild(target); }
        if (plainText) { doPaste(view, target.value, null, e); }
        else { doPaste(view, target.textContent, target.innerHTML, e); }
      }, 50);
    }

    function doPaste(view, text, html, e) {
      var slice = parseFromClipboard(view, text, html, view.shiftKey, view.state.selection.$from);
      if (view.someProp("handlePaste", function (f) { return f(view, e, slice || Slice.empty); })) { return true }
      if (!slice) { return false }

      var singleNode = sliceSingleNode(slice);
      var tr = singleNode ? view.state.tr.replaceSelectionWith(singleNode, view.shiftKey) : view.state.tr.replaceSelection(slice);
      view.dispatch(tr.scrollIntoView().setMeta("paste", true).setMeta("uiEvent", "paste"));
      return true
    }

    editHandlers.paste = function (view, e) {
      var data = brokenClipboardAPI ? null : e.clipboardData;
      if (data && doPaste(view, data.getData("text/plain"), data.getData("text/html"), e)) { e.preventDefault(); }
      else { capturePaste(view, e); }
    };

    var Dragging = function Dragging(slice, move) {
      this.slice = slice;
      this.move = move;
    };

    var dragCopyModifier = result.mac ? "altKey" : "ctrlKey";

    handlers.dragstart = function (view, e) {
      var mouseDown = view.mouseDown;
      if (mouseDown) { mouseDown.done(); }
      if (!e.dataTransfer) { return }

      var sel = view.state.selection;
      var pos = sel.empty ? null : view.posAtCoords(eventCoords(e));
      if (pos && pos.pos >= sel.from && pos.pos <= (sel instanceof NodeSelection ? sel.to - 1: sel.to)) ; else if (mouseDown && mouseDown.mightDrag) {
        view.dispatch(view.state.tr.setSelection(NodeSelection.create(view.state.doc, mouseDown.mightDrag.pos)));
      } else if (e.target && e.target.nodeType == 1) {
        var desc = view.docView.nearestDesc(e.target, true);
        if (!desc || !desc.node.type.spec.draggable || desc == view.docView) { return }
        view.dispatch(view.state.tr.setSelection(NodeSelection.create(view.state.doc, desc.posBefore)));
      }
      var slice = view.state.selection.content();
      var ref = serializeForClipboard(view, slice);
      var dom = ref.dom;
      var text = ref.text;
      e.dataTransfer.clearData();
      e.dataTransfer.setData(brokenClipboardAPI ? "Text" : "text/html", dom.innerHTML);
      if (!brokenClipboardAPI) { e.dataTransfer.setData("text/plain", text); }
      view.dragging = new Dragging(slice, !e[dragCopyModifier]);
    };

    handlers.dragend = function (view) {
      var dragging = view.dragging;
      window.setTimeout(function () {
        if (view.dragging == dragging)  { view.dragging = null; }
      }, 50);
    };

    editHandlers.dragover = editHandlers.dragenter = function (_, e) { return e.preventDefault(); };

    editHandlers.drop = function (view, e) {
      var dragging = view.dragging;
      view.dragging = null;

      if (!e.dataTransfer) { return }

      var eventPos = view.posAtCoords(eventCoords(e));
      if (!eventPos) { return }
      var $mouse = view.state.doc.resolve(eventPos.pos);
      if (!$mouse) { return }
      var slice = dragging && dragging.slice ||
          parseFromClipboard(view, e.dataTransfer.getData(brokenClipboardAPI ? "Text" : "text/plain"),
                             brokenClipboardAPI ? null : e.dataTransfer.getData("text/html"), false, $mouse);
      var move = dragging && !e[dragCopyModifier];
      if (view.someProp("handleDrop", function (f) { return f(view, e, slice || Slice.empty, move); })) {
        e.preventDefault();
        return
      }
      if (!slice) { return }

      e.preventDefault();
      var insertPos = slice ? dropPoint(view.state.doc, $mouse.pos, slice) : $mouse.pos;
      if (insertPos == null) { insertPos = $mouse.pos; }

      var tr = view.state.tr;
      if (move) { tr.deleteSelection(); }

      var pos = tr.mapping.map(insertPos);
      var isNode = slice.openStart == 0 && slice.openEnd == 0 && slice.content.childCount == 1;
      var beforeInsert = tr.doc;
      if (isNode)
        { tr.replaceRangeWith(pos, pos, slice.content.firstChild); }
      else
        { tr.replaceRange(pos, pos, slice); }
      if (tr.doc.eq(beforeInsert)) { return }

      var $pos = tr.doc.resolve(pos);
      if (isNode && NodeSelection.isSelectable(slice.content.firstChild) &&
          $pos.nodeAfter && $pos.nodeAfter.sameMarkup(slice.content.firstChild)) {
        tr.setSelection(new NodeSelection($pos));
      } else {
        var end = tr.mapping.map(insertPos);
        tr.mapping.maps[tr.mapping.maps.length - 1].forEach(function (_from, _to, _newFrom, newTo) { return end = newTo; });
        tr.setSelection(selectionBetween(view, $pos, tr.doc.resolve(end)));
      }
      view.focus();
      view.dispatch(tr.setMeta("uiEvent", "drop"));
    };

    handlers.focus = function (view) {
      if (!view.focused) {
        view.domObserver.stop();
        view.dom.classList.add("ProseMirror-focused");
        view.domObserver.start();
        view.focused = true;
        setTimeout(function () {
          if (view.docView && view.hasFocus() && !view.domObserver.currentSelection.eq(view.root.getSelection()))
            { selectionToDOM(view); }
        }, 20);
      }
    };

    handlers.blur = function (view) {
      if (view.focused) {
        view.domObserver.stop();
        view.dom.classList.remove("ProseMirror-focused");
        view.domObserver.start();
        view.domObserver.currentSelection.set({});
        view.focused = false;
      }
    };

    handlers.beforeinput = function (view, event) {
      // We should probably do more with beforeinput events, but support
      // is so spotty that I'm still waiting to see where they are going.

      // Very specific hack to deal with backspace sometimes failing on
      // Chrome Android when after an uneditable node.
      if (result.chrome && result.android && event.inputType == "deleteContentBackward") {
        var domChangeCount = view.domChangeCount;
        setTimeout(function () {
          if (view.domChangeCount != domChangeCount) { return } // Event already had some effect
          // This bug tends to close the virtual keyboard, so we refocus
          view.dom.blur();
          view.focus();
          if (view.someProp("handleKeyDown", function (f) { return f(view, keyEvent(8, "Backspace")); })) { return }
          var ref = view.state.selection;
          var $cursor = ref.$cursor;
          // Crude approximation of backspace behavior when no command handled it
          if ($cursor && $cursor.pos > 0) { view.dispatch(view.state.tr.delete($cursor.pos - 1, $cursor.pos).scrollIntoView()); }
        }, 50);
      }
    };

    // Make sure all handlers get registered
    for (var prop in editHandlers) { handlers[prop] = editHandlers[prop]; }

    function compareObjs(a, b) {
      if (a == b) { return true }
      for (var p in a) { if (a[p] !== b[p]) { return false } }
      for (var p$1 in b) { if (!(p$1 in a)) { return false } }
      return true
    }

    var WidgetType = function WidgetType(toDOM, spec) {
      this.spec = spec || noSpec;
      this.side = this.spec.side || 0;
      this.toDOM = toDOM;
    };

    WidgetType.prototype.map = function map (mapping, span, offset, oldOffset) {
      var ref = mapping.mapResult(span.from + oldOffset, this.side < 0 ? -1 : 1);
        var pos = ref.pos;
        var deleted = ref.deleted;
      return deleted ? null : new Decoration(pos - offset, pos - offset, this)
    };

    WidgetType.prototype.valid = function valid () { return true };

    WidgetType.prototype.eq = function eq (other) {
      return this == other ||
        (other instanceof WidgetType &&
         (this.spec.key && this.spec.key == other.spec.key ||
          this.toDOM == other.toDOM && compareObjs(this.spec, other.spec)))
    };

    var InlineType = function InlineType(attrs, spec) {
      this.spec = spec || noSpec;
      this.attrs = attrs;
    };

    InlineType.prototype.map = function map (mapping, span, offset, oldOffset) {
      var from = mapping.map(span.from + oldOffset, this.spec.inclusiveStart ? -1 : 1) - offset;
      var to = mapping.map(span.to + oldOffset, this.spec.inclusiveEnd ? 1 : -1) - offset;
      return from >= to ? null : new Decoration(from, to, this)
    };

    InlineType.prototype.valid = function valid (_, span) { return span.from < span.to };

    InlineType.prototype.eq = function eq (other) {
      return this == other ||
        (other instanceof InlineType && compareObjs(this.attrs, other.attrs) &&
         compareObjs(this.spec, other.spec))
    };

    InlineType.is = function is (span) { return span.type instanceof InlineType };

    var NodeType$1 = function NodeType(attrs, spec) {
      this.spec = spec || noSpec;
      this.attrs = attrs;
    };

    NodeType$1.prototype.map = function map (mapping, span, offset, oldOffset) {
      var from = mapping.mapResult(span.from + oldOffset, 1);
      if (from.deleted) { return null }
      var to = mapping.mapResult(span.to + oldOffset, -1);
      if (to.deleted || to.pos <= from.pos) { return null }
      return new Decoration(from.pos - offset, to.pos - offset, this)
    };

    NodeType$1.prototype.valid = function valid (node, span) {
      var ref = node.content.findIndex(span.from);
        var index = ref.index;
        var offset = ref.offset;
      return offset == span.from && offset + node.child(index).nodeSize == span.to
    };

    NodeType$1.prototype.eq = function eq (other) {
      return this == other ||
        (other instanceof NodeType$1 && compareObjs(this.attrs, other.attrs) &&
         compareObjs(this.spec, other.spec))
    };

    // ::- Decoration objects can be provided to the view through the
    // [`decorations` prop](#view.EditorProps.decorations). They come in
    // several variants—see the static members of this class for details.
    var Decoration = function Decoration(from, to, type) {
      // :: number
      // The start position of the decoration.
      this.from = from;
      // :: number
      // The end position. Will be the same as `from` for [widget
      // decorations](#view.Decoration^widget).
      this.to = to;
      this.type = type;
    };

    var prototypeAccessors$1$6 = { spec: { configurable: true },inline: { configurable: true } };

    Decoration.prototype.copy = function copy (from, to) {
      return new Decoration(from, to, this.type)
    };

    Decoration.prototype.eq = function eq (other, offset) {
        if ( offset === void 0 ) offset = 0;

      return this.type.eq(other.type) && this.from + offset == other.from && this.to + offset == other.to
    };

    Decoration.prototype.map = function map (mapping, offset, oldOffset) {
      return this.type.map(mapping, this, offset, oldOffset)
    };

    // :: (number, union<(view: EditorView, getPos: () → number) → dom.Node, dom.Node>, ?Object) → Decoration
    // Creates a widget decoration, which is a DOM node that's shown in
    // the document at the given position. It is recommended that you
    // delay rendering the widget by passing a function that will be
    // called when the widget is actually drawn in a view, but you can
    // also directly pass a DOM node. `getPos` can be used to find the
    // widget's current document position.
    //
    // spec::- These options are supported:
    //
    //   side:: ?number
    //   Controls which side of the document position this widget is
    //   associated with. When negative, it is drawn before a cursor
    //   at its position, and content inserted at that position ends
    //   up after the widget. When zero (the default) or positive, the
    //   widget is drawn after the cursor and content inserted there
    //   ends up before the widget.
    //
    //   When there are multiple widgets at a given position, their
    //   `side` values determine the order in which they appear. Those
    //   with lower values appear first. The ordering of widgets with
    //   the same `side` value is unspecified.
    //
    //   When `marks` is null, `side` also determines the marks that
    //   the widget is wrapped in—those of the node before when
    //   negative, those of the node after when positive.
    //
    //   marks:: ?[Mark]
    //   The precise set of marks to draw around the widget.
    //
    //   stopEvent:: ?(event: dom.Event) → bool
    //   Can be used to control which DOM events, when they bubble out
    //   of this widget, the editor view should ignore.
    //
    //   ignoreSelection:: ?bool
    //   When set (defaults to false), selection changes inside the
    //   widget are ignored, and don't cause ProseMirror to try and
    //   re-sync the selection with its selection state.
    //
    //   key:: ?string
    //   When comparing decorations of this type (in order to decide
    //   whether it needs to be redrawn), ProseMirror will by default
    //   compare the widget DOM node by identity. If you pass a key,
    //   that key will be compared instead, which can be useful when
    //   you generate decorations on the fly and don't want to store
    //   and reuse DOM nodes. Make sure that any widgets with the same
    //   key are interchangeable—if widgets differ in, for example,
    //   the behavior of some event handler, they should get
    //   different keys.
    Decoration.widget = function widget (pos, toDOM, spec) {
      return new Decoration(pos, pos, new WidgetType(toDOM, spec))
    };

    // :: (number, number, DecorationAttrs, ?Object) → Decoration
    // Creates an inline decoration, which adds the given attributes to
    // each inline node between `from` and `to`.
    //
    // spec::- These options are recognized:
    //
    //   inclusiveStart:: ?bool
    //   Determines how the left side of the decoration is
    //   [mapped](#transform.Position_Mapping) when content is
    //   inserted directly at that position. By default, the decoration
    //   won't include the new content, but you can set this to `true`
    //   to make it inclusive.
    //
    //   inclusiveEnd:: ?bool
    //   Determines how the right side of the decoration is mapped.
    //   See
    //   [`inclusiveStart`](#view.Decoration^inline^spec.inclusiveStart).
    Decoration.inline = function inline (from, to, attrs, spec) {
      return new Decoration(from, to, new InlineType(attrs, spec))
    };

    // :: (number, number, DecorationAttrs, ?Object) → Decoration
    // Creates a node decoration. `from` and `to` should point precisely
    // before and after a node in the document. That node, and only that
    // node, will receive the given attributes.
    //
    // spec::-
    //
    // Optional information to store with the decoration. It
    // is also used when comparing decorators for equality.
    Decoration.node = function node (from, to, attrs, spec) {
      return new Decoration(from, to, new NodeType$1(attrs, spec))
    };

    // :: Object
    // The spec provided when creating this decoration. Can be useful
    // if you've stored extra information in that object.
    prototypeAccessors$1$6.spec.get = function () { return this.type.spec };

    prototypeAccessors$1$6.inline.get = function () { return this.type instanceof InlineType };

    Object.defineProperties( Decoration.prototype, prototypeAccessors$1$6 );

    // DecorationAttrs:: interface
    // A set of attributes to add to a decorated node. Most properties
    // simply directly correspond to DOM attributes of the same name,
    // which will be set to the property's value. These are exceptions:
    //
    //   class:: ?string
    //   A CSS class name or a space-separated set of class names to be
    //   _added_ to the classes that the node already had.
    //
    //   style:: ?string
    //   A string of CSS to be _added_ to the node's existing `style` property.
    //
    //   nodeName:: ?string
    //   When non-null, the target node is wrapped in a DOM element of
    //   this type (and the other attributes are applied to this element).

    var none = [], noSpec = {};

    // ::- A collection of [decorations](#view.Decoration), organized in
    // such a way that the drawing algorithm can efficiently use and
    // compare them. This is a persistent data structure—it is not
    // modified, updates create a new value.
    var DecorationSet = function DecorationSet(local, children) {
      this.local = local && local.length ? local : none;
      this.children = children && children.length ? children : none;
    };

    // :: (Node, [Decoration]) → DecorationSet
    // Create a set of decorations, using the structure of the given
    // document.
    DecorationSet.create = function create (doc, decorations) {
      return decorations.length ? buildTree(decorations, doc, 0, noSpec) : empty
    };

    // :: (?number, ?number, ?(spec: Object) → bool) → [Decoration]
    // Find all decorations in this set which touch the given range
    // (including decorations that start or end directly at the
    // boundaries) and match the given predicate on their spec. When
    // `start` and `end` are omitted, all decorations in the set are
    // considered. When `predicate` isn't given, all decorations are
    // assumed to match.
    DecorationSet.prototype.find = function find (start, end, predicate) {
      var result = [];
      this.findInner(start == null ? 0 : start, end == null ? 1e9 : end, result, 0, predicate);
      return result
    };

    DecorationSet.prototype.findInner = function findInner (start, end, result, offset, predicate) {
      for (var i = 0; i < this.local.length; i++) {
        var span = this.local[i];
        if (span.from <= end && span.to >= start && (!predicate || predicate(span.spec)))
          { result.push(span.copy(span.from + offset, span.to + offset)); }
      }
      for (var i$1 = 0; i$1 < this.children.length; i$1 += 3) {
        if (this.children[i$1] < end && this.children[i$1 + 1] > start) {
          var childOff = this.children[i$1] + 1;
          this.children[i$1 + 2].findInner(start - childOff, end - childOff, result, offset + childOff, predicate);
        }
      }
    };

    // :: (Mapping, Node, ?Object) → DecorationSet
    // Map the set of decorations in response to a change in the
    // document.
    //
    // options::- An optional set of options.
    //
    //   onRemove:: ?(decorationSpec: Object)
    //   When given, this function will be called for each decoration
    //   that gets dropped as a result of the mapping, passing the
    //   spec of that decoration.
    DecorationSet.prototype.map = function map (mapping, doc, options) {
      if (this == empty || mapping.maps.length == 0) { return this }
      return this.mapInner(mapping, doc, 0, 0, options || noSpec)
    };

    DecorationSet.prototype.mapInner = function mapInner (mapping, node, offset, oldOffset, options) {
      var newLocal;
      for (var i = 0; i < this.local.length; i++) {
        var mapped = this.local[i].map(mapping, offset, oldOffset);
        if (mapped && mapped.type.valid(node, mapped)) { (newLocal || (newLocal = [])).push(mapped); }
        else if (options.onRemove) { options.onRemove(this.local[i].spec); }
      }

      if (this.children.length)
        { return mapChildren(this.children, newLocal, mapping, node, offset, oldOffset, options) }
      else
        { return newLocal ? new DecorationSet(newLocal.sort(byPos)) : empty }
    };

    // :: (Node, [Decoration]) → DecorationSet
    // Add the given array of decorations to the ones in the set,
    // producing a new set. Needs access to the current document to
    // create the appropriate tree structure.
    DecorationSet.prototype.add = function add (doc, decorations) {
      if (!decorations.length) { return this }
      if (this == empty) { return DecorationSet.create(doc, decorations) }
      return this.addInner(doc, decorations, 0)
    };

    DecorationSet.prototype.addInner = function addInner (doc, decorations, offset) {
        var this$1 = this;

      var children, childIndex = 0;
      doc.forEach(function (childNode, childOffset) {
        var baseOffset = childOffset + offset, found;
        if (!(found = takeSpansForNode(decorations, childNode, baseOffset))) { return }

        if (!children) { children = this$1.children.slice(); }
        while (childIndex < children.length && children[childIndex] < childOffset) { childIndex += 3; }
        if (children[childIndex] == childOffset)
          { children[childIndex + 2] = children[childIndex + 2].addInner(childNode, found, baseOffset + 1); }
        else
          { children.splice(childIndex, 0, childOffset, childOffset + childNode.nodeSize, buildTree(found, childNode, baseOffset + 1, noSpec)); }
        childIndex += 3;
      });

      var local = moveSpans(childIndex ? withoutNulls(decorations) : decorations, -offset);
      for (var i = 0; i < local.length; i++) { if (!local[i].type.valid(doc, local[i])) { local.splice(i--, 1); } }

      return new DecorationSet(local.length ? this.local.concat(local).sort(byPos) : this.local,
                               children || this.children)
    };

    // :: ([Decoration]) → DecorationSet
    // Create a new set that contains the decorations in this set, minus
    // the ones in the given array.
    DecorationSet.prototype.remove = function remove (decorations) {
      if (decorations.length == 0 || this == empty) { return this }
      return this.removeInner(decorations, 0)
    };

    DecorationSet.prototype.removeInner = function removeInner (decorations, offset) {
      var children = this.children, local = this.local;
      for (var i = 0; i < children.length; i += 3) {
        var found = (void 0), from = children[i] + offset, to = children[i + 1] + offset;
        for (var j = 0, span = (void 0); j < decorations.length; j++) { if (span = decorations[j]) {
          if (span.from > from && span.to < to) {
            decorations[j] = null
            ;(found || (found = [])).push(span);
          }
        } }
        if (!found) { continue }
        if (children == this.children) { children = this.children.slice(); }
        var removed = children[i + 2].removeInner(found, from + 1);
        if (removed != empty) {
          children[i + 2] = removed;
        } else {
          children.splice(i, 3);
          i -= 3;
        }
      }
      if (local.length) { for (var i$1 = 0, span$1 = (void 0); i$1 < decorations.length; i$1++) { if (span$1 = decorations[i$1]) {
        for (var j$1 = 0; j$1 < local.length; j$1++) { if (local[j$1].eq(span$1, offset)) {
          if (local == this.local) { local = this.local.slice(); }
          local.splice(j$1--, 1);
        } }
      } } }
      if (children == this.children && local == this.local) { return this }
      return local.length || children.length ? new DecorationSet(local, children) : empty
    };

    DecorationSet.prototype.forChild = function forChild (offset, node) {
      if (this == empty) { return this }
      if (node.isLeaf) { return DecorationSet.empty }

      var child, local;
      for (var i = 0; i < this.children.length; i += 3) { if (this.children[i] >= offset) {
        if (this.children[i] == offset) { child = this.children[i + 2]; }
        break
      } }
      var start = offset + 1, end = start + node.content.size;
      for (var i$1 = 0; i$1 < this.local.length; i$1++) {
        var dec = this.local[i$1];
        if (dec.from < end && dec.to > start && (dec.type instanceof InlineType)) {
          var from = Math.max(start, dec.from) - start, to = Math.min(end, dec.to) - start;
          if (from < to) { (local || (local = [])).push(dec.copy(from, to)); }
        }
      }
      if (local) {
        var localSet = new DecorationSet(local.sort(byPos));
        return child ? new DecorationGroup([localSet, child]) : localSet
      }
      return child || empty
    };

    DecorationSet.prototype.eq = function eq (other) {
      if (this == other) { return true }
      if (!(other instanceof DecorationSet) ||
          this.local.length != other.local.length ||
          this.children.length != other.children.length) { return false }
      for (var i = 0; i < this.local.length; i++)
        { if (!this.local[i].eq(other.local[i])) { return false } }
      for (var i$1 = 0; i$1 < this.children.length; i$1 += 3)
        { if (this.children[i$1] != other.children[i$1] ||
            this.children[i$1 + 1] != other.children[i$1 + 1] ||
            !this.children[i$1 + 2].eq(other.children[i$1 + 2])) { return false } }
      return true
    };

    DecorationSet.prototype.locals = function locals (node) {
      return removeOverlap(this.localsInner(node))
    };

    DecorationSet.prototype.localsInner = function localsInner (node) {
      if (this == empty) { return none }
      if (node.inlineContent || !this.local.some(InlineType.is)) { return this.local }
      var result = [];
      for (var i = 0; i < this.local.length; i++) {
        if (!(this.local[i].type instanceof InlineType))
          { result.push(this.local[i]); }
      }
      return result
    };

    var empty = new DecorationSet();

    // :: DecorationSet
    // The empty set of decorations.
    DecorationSet.empty = empty;

    DecorationSet.removeOverlap = removeOverlap;

    // :- An abstraction that allows the code dealing with decorations to
    // treat multiple DecorationSet objects as if it were a single object
    // with (a subset of) the same interface.
    var DecorationGroup = function DecorationGroup(members) {
      this.members = members;
    };

    DecorationGroup.prototype.forChild = function forChild (offset, child) {
      if (child.isLeaf) { return DecorationSet.empty }
      var found = [];
      for (var i = 0; i < this.members.length; i++) {
        var result = this.members[i].forChild(offset, child);
        if (result == empty) { continue }
        if (result instanceof DecorationGroup) { found = found.concat(result.members); }
        else { found.push(result); }
      }
      return DecorationGroup.from(found)
    };

    DecorationGroup.prototype.eq = function eq (other) {
      if (!(other instanceof DecorationGroup) ||
          other.members.length != this.members.length) { return false }
      for (var i = 0; i < this.members.length; i++)
        { if (!this.members[i].eq(other.members[i])) { return false } }
      return true
    };

    DecorationGroup.prototype.locals = function locals (node) {
      var result, sorted = true;
      for (var i = 0; i < this.members.length; i++) {
        var locals = this.members[i].localsInner(node);
        if (!locals.length) { continue }
        if (!result) {
          result = locals;
        } else {
          if (sorted) {
            result = result.slice();
            sorted = false;
          }
          for (var j = 0; j < locals.length; j++) { result.push(locals[j]); }
        }
      }
      return result ? removeOverlap(sorted ? result : result.sort(byPos)) : none
    };

    // : ([DecorationSet]) → union<DecorationSet, DecorationGroup>
    // Create a group for the given array of decoration sets, or return
    // a single set when possible.
    DecorationGroup.from = function from (members) {
      switch (members.length) {
        case 0: return empty
        case 1: return members[0]
        default: return new DecorationGroup(members)
      }
    };

    function mapChildren(oldChildren, newLocal, mapping, node, offset, oldOffset, options) {
      var children = oldChildren.slice();

      // Mark the children that are directly touched by changes, and
      // move those that are after the changes.
      var shift = function (oldStart, oldEnd, newStart, newEnd) {
        for (var i = 0; i < children.length; i += 3) {
          var end = children[i + 1], dSize = (void 0);
          if (end == -1 || oldStart > end + oldOffset) { continue }
          if (oldEnd >= children[i] + oldOffset) {
            children[i + 1] = -1;
          } else if (newStart >= offset && (dSize = (newEnd - newStart) - (oldEnd - oldStart))) {
            children[i] += dSize;
            children[i + 1] += dSize;
          }
        }
      };
      for (var i = 0; i < mapping.maps.length; i++) { mapping.maps[i].forEach(shift); }

      // Find the child nodes that still correspond to a single node,
      // recursively call mapInner on them and update their positions.
      var mustRebuild = false;
      for (var i$1 = 0; i$1 < children.length; i$1 += 3) { if (children[i$1 + 1] == -1) { // Touched nodes
        var from = mapping.map(oldChildren[i$1] + oldOffset), fromLocal = from - offset;
        if (fromLocal < 0 || fromLocal >= node.content.size) {
          mustRebuild = true;
          continue
        }
        // Must read oldChildren because children was tagged with -1
        var to = mapping.map(oldChildren[i$1 + 1] + oldOffset, -1), toLocal = to - offset;
        var ref = node.content.findIndex(fromLocal);
        var index = ref.index;
        var childOffset = ref.offset;
        var childNode = node.maybeChild(index);
        if (childNode && childOffset == fromLocal && childOffset + childNode.nodeSize == toLocal) {
          var mapped = children[i$1 + 2].mapInner(mapping, childNode, from + 1, oldChildren[i$1] + oldOffset + 1, options);
          if (mapped != empty) {
            children[i$1] = fromLocal;
            children[i$1 + 1] = toLocal;
            children[i$1 + 2] = mapped;
          } else {
            children[i$1 + 1] = -2;
            mustRebuild = true;
          }
        } else {
          mustRebuild = true;
        }
      } }

      // Remaining children must be collected and rebuilt into the appropriate structure
      if (mustRebuild) {
        var decorations = mapAndGatherRemainingDecorations(children, oldChildren, newLocal || [], mapping,
                                                           offset, oldOffset, options);
        var built = buildTree(decorations, node, 0, options);
        newLocal = built.local;
        for (var i$2 = 0; i$2 < children.length; i$2 += 3) { if (children[i$2 + 1] < 0) {
          children.splice(i$2, 3);
          i$2 -= 3;
        } }
        for (var i$3 = 0, j = 0; i$3 < built.children.length; i$3 += 3) {
          var from$1 = built.children[i$3];
          while (j < children.length && children[j] < from$1) { j += 3; }
          children.splice(j, 0, built.children[i$3], built.children[i$3 + 1], built.children[i$3 + 2]);
        }
      }

      return new DecorationSet(newLocal && newLocal.sort(byPos), children)
    }

    function moveSpans(spans, offset) {
      if (!offset || !spans.length) { return spans }
      var result = [];
      for (var i = 0; i < spans.length; i++) {
        var span = spans[i];
        result.push(new Decoration(span.from + offset, span.to + offset, span.type));
      }
      return result
    }

    function mapAndGatherRemainingDecorations(children, oldChildren, decorations, mapping, offset, oldOffset, options) {
      // Gather all decorations from the remaining marked children
      function gather(set, oldOffset) {
        for (var i = 0; i < set.local.length; i++) {
          var mapped = set.local[i].map(mapping, offset, oldOffset);
          if (mapped) { decorations.push(mapped); }
          else if (options.onRemove) { options.onRemove(set.local[i].spec); }
        }
        for (var i$1 = 0; i$1 < set.children.length; i$1 += 3)
          { gather(set.children[i$1 + 2], set.children[i$1] + oldOffset + 1); }
      }
      for (var i = 0; i < children.length; i += 3) { if (children[i + 1] == -1)
        { gather(children[i + 2], oldChildren[i] + oldOffset + 1); } }

      return decorations
    }

    function takeSpansForNode(spans, node, offset) {
      if (node.isLeaf) { return null }
      var end = offset + node.nodeSize, found = null;
      for (var i = 0, span = (void 0); i < spans.length; i++) {
        if ((span = spans[i]) && span.from > offset && span.to < end) {
    (found || (found = [])).push(span);
          spans[i] = null;
        }
      }
      return found
    }

    function withoutNulls(array) {
      var result = [];
      for (var i = 0; i < array.length; i++)
        { if (array[i] != null) { result.push(array[i]); } }
      return result
    }

    // : ([Decoration], Node, number) → DecorationSet
    // Build up a tree that corresponds to a set of decorations. `offset`
    // is a base offset that should be subtractet from the `from` and `to`
    // positions in the spans (so that we don't have to allocate new spans
    // for recursive calls).
    function buildTree(spans, node, offset, options) {
      var children = [], hasNulls = false;
      node.forEach(function (childNode, localStart) {
        var found = takeSpansForNode(spans, childNode, localStart + offset);
        if (found) {
          hasNulls = true;
          var subtree = buildTree(found, childNode, offset + localStart + 1, options);
          if (subtree != empty)
            { children.push(localStart, localStart + childNode.nodeSize, subtree); }
        }
      });
      var locals = moveSpans(hasNulls ? withoutNulls(spans) : spans, -offset).sort(byPos);
      for (var i = 0; i < locals.length; i++) { if (!locals[i].type.valid(node, locals[i])) {
        if (options.onRemove) { options.onRemove(locals[i].spec); }
        locals.splice(i--, 1);
      } }
      return locals.length || children.length ? new DecorationSet(locals, children) : empty
    }

    // : (Decoration, Decoration) → number
    // Used to sort decorations so that ones with a low start position
    // come first, and within a set with the same start position, those
    // with an smaller end position come first.
    function byPos(a, b) {
      return a.from - b.from || a.to - b.to
    }

    // : ([Decoration]) → [Decoration]
    // Scan a sorted array of decorations for partially overlapping spans,
    // and split those so that only fully overlapping spans are left (to
    // make subsequent rendering easier). Will return the input array if
    // no partially overlapping spans are found (the common case).
    function removeOverlap(spans) {
      var working = spans;
      for (var i = 0; i < working.length - 1; i++) {
        var span = working[i];
        if (span.from != span.to) { for (var j = i + 1; j < working.length; j++) {
          var next = working[j];
          if (next.from == span.from) {
            if (next.to != span.to) {
              if (working == spans) { working = spans.slice(); }
              // Followed by a partially overlapping larger span. Split that
              // span.
              working[j] = next.copy(next.from, span.to);
              insertAhead(working, j + 1, next.copy(span.to, next.to));
            }
            continue
          } else {
            if (next.from < span.to) {
              if (working == spans) { working = spans.slice(); }
              // The end of this one overlaps with a subsequent span. Split
              // this one.
              working[i] = span.copy(span.from, next.from);
              insertAhead(working, j, span.copy(next.from, span.to));
            }
            break
          }
        } }
      }
      return working
    }

    function insertAhead(array, i, deco) {
      while (i < array.length && byPos(deco, array[i]) > 0) { i++; }
      array.splice(i, 0, deco);
    }

    // : (EditorView) → union<DecorationSet, DecorationGroup>
    // Get the decorations associated with the current props of a view.
    function viewDecorations(view) {
      var found = [];
      view.someProp("decorations", function (f) {
        var result = f(view.state);
        if (result && result != empty) { found.push(result); }
      });
      if (view.cursorWrapper)
        { found.push(DecorationSet.create(view.state.doc, [view.cursorWrapper.deco])); }
      return DecorationGroup.from(found)
    }

    // ::- An editor view manages the DOM structure that represents an
    // editable document. Its state and behavior are determined by its
    // [props](#view.DirectEditorProps).
    var EditorView = function EditorView(place, props) {
      this._props = props;
      // :: EditorState
      // The view's current [state](#state.EditorState).
      this.state = props.state;

      this.dispatch = this.dispatch.bind(this);

      this._root = null;
      this.focused = false;
      // Kludge used to work around a Chrome bug
      this.trackWrites = null;

      // :: dom.Element
      // An editable DOM node containing the document. (You probably
      // should not directly interfere with its content.)
      this.dom = (place && place.mount) || document.createElement("div");
      if (place) {
        if (place.appendChild) { place.appendChild(this.dom); }
        else if (place.apply) { place(this.dom); }
        else if (place.mount) { this.mounted = true; }
      }

      // :: bool
      // Indicates whether the editor is currently [editable](#view.EditorProps.editable).
      this.editable = getEditable(this);
      this.markCursor = null;
      this.cursorWrapper = null;
      updateCursorWrapper(this);
      this.nodeViews = buildNodeViews(this);
      this.docView = docViewDesc(this.state.doc, computeDocDeco(this), viewDecorations(this), this.dom, this);

      this.lastSelectedViewDesc = null;
      // :: ?{slice: Slice, move: bool}
      // When editor content is being dragged, this object contains
      // information about the dragged slice and whether it is being
      // copied or moved. At any other time, it is null.
      this.dragging = null;

      initInput(this);

      this.pluginViews = [];
      this.updatePluginViews();
    };

    var prototypeAccessors$2$1 = { props: { configurable: true },root: { configurable: true } };

    // composing:: boolean
    // Holds `true` when a
    // [composition](https://developer.mozilla.org/en-US/docs/Mozilla/IME_handling_guide)
    // is active.

    // :: DirectEditorProps
    // The view's current [props](#view.EditorProps).
    prototypeAccessors$2$1.props.get = function () {
      if (this._props.state != this.state) {
        var prev = this._props;
        this._props = {};
        for (var name in prev) { this._props[name] = prev[name]; }
        this._props.state = this.state;
      }
      return this._props
    };

    // :: (DirectEditorProps)
    // Update the view's props. Will immediately cause an update to
    // the DOM.
    EditorView.prototype.update = function update (props) {
      if (props.handleDOMEvents != this._props.handleDOMEvents) { ensureListeners(this); }
      this._props = props;
      this.updateStateInner(props.state, true);
    };

    // :: (DirectEditorProps)
    // Update the view by updating existing props object with the object
    // given as argument. Equivalent to `view.update(Object.assign({},
    // view.props, props))`.
    EditorView.prototype.setProps = function setProps (props) {
      var updated = {};
      for (var name in this._props) { updated[name] = this._props[name]; }
      updated.state = this.state;
      for (var name$1 in props) { updated[name$1] = props[name$1]; }
      this.update(updated);
    };

    // :: (EditorState)
    // Update the editor's `state` prop, without touching any of the
    // other props.
    EditorView.prototype.updateState = function updateState (state) {
      this.updateStateInner(state, this.state.plugins != state.plugins);
    };

    EditorView.prototype.updateStateInner = function updateStateInner (state, reconfigured) {
        var this$1 = this;

      var prev = this.state, redraw = false, updateSel = false;
      // When stored marks are added, stop composition, so that they can
      // be displayed.
      if (state.storedMarks && this.composing) {
        clearComposition(this);
        updateSel = true;
      }
      this.state = state;
      if (reconfigured) {
        var nodeViews = buildNodeViews(this);
        if (changedNodeViews(nodeViews, this.nodeViews)) {
          this.nodeViews = nodeViews;
          redraw = true;
        }
        ensureListeners(this);
      }

      this.editable = getEditable(this);
      updateCursorWrapper(this);
      var innerDeco = viewDecorations(this), outerDeco = computeDocDeco(this);

      var scroll = reconfigured ? "reset"
          : state.scrollToSelection > prev.scrollToSelection ? "to selection" : "preserve";
      var updateDoc = redraw || !this.docView.matchesNode(state.doc, outerDeco, innerDeco);
      if (updateDoc || !state.selection.eq(prev.selection)) { updateSel = true; }
      var oldScrollPos = scroll == "preserve" && updateSel && this.dom.style.overflowAnchor == null && storeScrollPos(this);

      if (updateSel) {
        this.domObserver.stop();
        // Work around an issue in Chrome, IE, and Edge where changing
        // the DOM around an active selection puts it into a broken
        // state where the thing the user sees differs from the
        // selection reported by the Selection object (#710, #973,
        // #1011, #1013, #1035).
        var forceSelUpdate = updateDoc && (result.ie || result.chrome) && !this.composing &&
            !prev.selection.empty && !state.selection.empty && selectionContextChanged(prev.selection, state.selection);
        if (updateDoc) {
          // If the node that the selection points into is written to,
          // Chrome sometimes starts misreporting the selection, so this
          // tracks that and forces a selection reset when our update
          // did write to the node.
          var chromeKludge = result.chrome ? (this.trackWrites = this.root.getSelection().focusNode) : null;
          if (redraw || !this.docView.update(state.doc, outerDeco, innerDeco, this)) {
            this.docView.updateOuterDeco([]);
            this.docView.destroy();
            this.docView = docViewDesc(state.doc, outerDeco, innerDeco, this.dom, this);
          }
          if (chromeKludge && !this.trackWrites) { forceSelUpdate = true; }
        }
        // Work around for an issue where an update arriving right between
        // a DOM selection change and the "selectionchange" event for it
        // can cause a spurious DOM selection update, disrupting mouse
        // drag selection.
        if (forceSelUpdate ||
            !(this.mouseDown && this.domObserver.currentSelection.eq(this.root.getSelection()) && anchorInRightPlace(this))) {
          selectionToDOM(this, forceSelUpdate);
        } else {
          syncNodeSelection(this, state.selection);
          this.domObserver.setCurSelection();
        }
        this.domObserver.start();
      }

      this.updatePluginViews(prev);

      if (scroll == "reset") {
        this.dom.scrollTop = 0;
      } else if (scroll == "to selection") {
        var startDOM = this.root.getSelection().focusNode;
        if (this.someProp("handleScrollToSelection", function (f) { return f(this$1); }))
          ; // Handled
        else if (state.selection instanceof NodeSelection)
          { scrollRectIntoView(this, this.docView.domAfterPos(state.selection.from).getBoundingClientRect(), startDOM); }
        else
          { scrollRectIntoView(this, this.coordsAtPos(state.selection.head, 1), startDOM); }
      } else if (oldScrollPos) {
        resetScrollPos(oldScrollPos);
      }
    };

    EditorView.prototype.destroyPluginViews = function destroyPluginViews () {
      var view;
      while (view = this.pluginViews.pop()) { if (view.destroy) { view.destroy(); } }
    };

    EditorView.prototype.updatePluginViews = function updatePluginViews (prevState) {
      if (!prevState || prevState.plugins != this.state.plugins) {
        this.destroyPluginViews();
        for (var i = 0; i < this.state.plugins.length; i++) {
          var plugin = this.state.plugins[i];
          if (plugin.spec.view) { this.pluginViews.push(plugin.spec.view(this)); }
        }
      } else {
        for (var i$1 = 0; i$1 < this.pluginViews.length; i$1++) {
          var pluginView = this.pluginViews[i$1];
          if (pluginView.update) { pluginView.update(this, prevState); }
        }
      }
    };

    // :: (string, ?(prop: *) → *) → *
    // Goes over the values of a prop, first those provided directly,
    // then those from plugins (in order), and calls `f` every time a
    // non-undefined value is found. When `f` returns a truthy value,
    // that is immediately returned. When `f` isn't provided, it is
    // treated as the identity function (the prop value is returned
    // directly).
    EditorView.prototype.someProp = function someProp (propName, f) {
      var prop = this._props && this._props[propName], value;
      if (prop != null && (value = f ? f(prop) : prop)) { return value }
      var plugins = this.state.plugins;
      if (plugins) { for (var i = 0; i < plugins.length; i++) {
        var prop$1 = plugins[i].props[propName];
        if (prop$1 != null && (value = f ? f(prop$1) : prop$1)) { return value }
      } }
    };

    // :: () → bool
    // Query whether the view has focus.
    EditorView.prototype.hasFocus = function hasFocus () {
      return this.root.activeElement == this.dom
    };

    // :: ()
    // Focus the editor.
    EditorView.prototype.focus = function focus () {
      this.domObserver.stop();
      if (this.editable) { focusPreventScroll(this.dom); }
      selectionToDOM(this);
      this.domObserver.start();
    };

    // :: union<dom.Document, dom.DocumentFragment>
    // Get the document root in which the editor exists. This will
    // usually be the top-level `document`, but might be a [shadow
    // DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM)
    // root if the editor is inside one.
    prototypeAccessors$2$1.root.get = function () {
      var cached = this._root;
      if (cached == null) { for (var search = this.dom.parentNode; search; search = search.parentNode) {
        if (search.nodeType == 9 || (search.nodeType == 11 && search.host)) {
          if (!search.getSelection) { Object.getPrototypeOf(search).getSelection = function () { return document.getSelection(); }; }
          return this._root = search
        }
      } }
      return cached || document
    };

    // :: ({left: number, top: number}) → ?{pos: number, inside: number}
    // Given a pair of viewport coordinates, return the document
    // position that corresponds to them. May return null if the given
    // coordinates aren't inside of the editor. When an object is
    // returned, its `pos` property is the position nearest to the
    // coordinates, and its `inside` property holds the position of the
    // inner node that the position falls inside of, or -1 if it is at
    // the top level, not in any node.
    EditorView.prototype.posAtCoords = function posAtCoords$1 (coords) {
      return posAtCoords(this, coords)
    };

    // :: (number, number) → {left: number, right: number, top: number, bottom: number}
    // Returns the viewport rectangle at a given document position.
    // `left` and `right` will be the same number, as this returns a
    // flat cursor-ish rectangle. If the position is between two things
    // that aren't directly adjacent, `side` determines which element is
    // used. When < 0, the element before the position is used,
    // otherwise the element after.
    EditorView.prototype.coordsAtPos = function coordsAtPos$1 (pos, side) {
        if ( side === void 0 ) side = 1;

      return coordsAtPos(this, pos, side)
    };

    // :: (number, number) → {node: dom.Node, offset: number}
    // Find the DOM position that corresponds to the given document
    // position. When `side` is negative, find the position as close as
    // possible to the content before the position. When positive,
    // prefer positions close to the content after the position. When
    // zero, prefer as shallow a position as possible.
    //
    // Note that you should **not** mutate the editor's internal DOM,
    // only inspect it (and even that is usually not necessary).
    EditorView.prototype.domAtPos = function domAtPos (pos, side) {
        if ( side === void 0 ) side = 0;

      return this.docView.domFromPos(pos, side)
    };

    // :: (number) → ?dom.Node
    // Find the DOM node that represents the document node after the
    // given position. May return `null` when the position doesn't point
    // in front of a node or if the node is inside an opaque node view.
    //
    // This is intended to be able to call things like
    // `getBoundingClientRect` on that DOM node. Do **not** mutate the
    // editor DOM directly, or add styling this way, since that will be
    // immediately overriden by the editor as it redraws the node.
    EditorView.prototype.nodeDOM = function nodeDOM (pos) {
      var desc = this.docView.descAt(pos);
      return desc ? desc.nodeDOM : null
    };

    // :: (dom.Node, number, ?number) → number
    // Find the document position that corresponds to a given DOM
    // position. (Whenever possible, it is preferable to inspect the
    // document structure directly, rather than poking around in the
    // DOM, but sometimes—for example when interpreting an event
    // target—you don't have a choice.)
    //
    // The `bias` parameter can be used to influence which side of a DOM
    // node to use when the position is inside a leaf node.
    EditorView.prototype.posAtDOM = function posAtDOM (node, offset, bias) {
        if ( bias === void 0 ) bias = -1;

      var pos = this.docView.posFromDOM(node, offset, bias);
      if (pos == null) { throw new RangeError("DOM position not inside the editor") }
      return pos
    };

    // :: (union<"up", "down", "left", "right", "forward", "backward">, ?EditorState) → bool
    // Find out whether the selection is at the end of a textblock when
    // moving in a given direction. When, for example, given `"left"`,
    // it will return true if moving left from the current cursor
    // position would leave that position's parent textblock. Will apply
    // to the view's current state by default, but it is possible to
    // pass a different state.
    EditorView.prototype.endOfTextblock = function endOfTextblock$1 (dir, state) {
      return endOfTextblock(this, state || this.state, dir)
    };

    // :: ()
    // Removes the editor from the DOM and destroys all [node
    // views](#view.NodeView).
    EditorView.prototype.destroy = function destroy () {
      if (!this.docView) { return }
      destroyInput(this);
      this.destroyPluginViews();
      if (this.mounted) {
        this.docView.update(this.state.doc, [], viewDecorations(this), this);
        this.dom.textContent = "";
      } else if (this.dom.parentNode) {
        this.dom.parentNode.removeChild(this.dom);
      }
      this.docView.destroy();
      this.docView = null;
    };

    // Used for testing.
    EditorView.prototype.dispatchEvent = function dispatchEvent$1 (event) {
      return dispatchEvent(this, event)
    };

    // :: (Transaction)
    // Dispatch a transaction. Will call
    // [`dispatchTransaction`](#view.DirectEditorProps.dispatchTransaction)
    // when given, and otherwise defaults to applying the transaction to
    // the current state and calling
    // [`updateState`](#view.EditorView.updateState) with the result.
    // This method is bound to the view instance, so that it can be
    // easily passed around.
    EditorView.prototype.dispatch = function dispatch (tr) {
      var dispatchTransaction = this._props.dispatchTransaction;
      if (dispatchTransaction) { dispatchTransaction.call(this, tr); }
      else { this.updateState(this.state.apply(tr)); }
    };

    Object.defineProperties( EditorView.prototype, prototypeAccessors$2$1 );

    function computeDocDeco(view) {
      var attrs = Object.create(null);
      attrs.class = "ProseMirror";
      attrs.contenteditable = String(view.editable);

      view.someProp("attributes", function (value) {
        if (typeof value == "function") { value = value(view.state); }
        if (value) { for (var attr in value) {
          if (attr == "class")
            { attrs.class += " " + value[attr]; }
          else if (!attrs[attr] && attr != "contenteditable" && attr != "nodeName")
            { attrs[attr] = String(value[attr]); }
        } }
      });

      return [Decoration.node(0, view.state.doc.content.size, attrs)]
    }

    function updateCursorWrapper(view) {
      if (view.markCursor) {
        var dom = document.createElement("img");
        dom.setAttribute("mark-placeholder", "true");
        view.cursorWrapper = {dom: dom, deco: Decoration.widget(view.state.selection.head, dom, {raw: true, marks: view.markCursor})};
      } else {
        view.cursorWrapper = null;
      }
    }

    function getEditable(view) {
      return !view.someProp("editable", function (value) { return value(view.state) === false; })
    }

    function selectionContextChanged(sel1, sel2) {
      var depth = Math.min(sel1.$anchor.sharedDepth(sel1.head), sel2.$anchor.sharedDepth(sel2.head));
      return sel1.$anchor.start(depth) != sel2.$anchor.start(depth)
    }

    function buildNodeViews(view) {
      var result = {};
      view.someProp("nodeViews", function (obj) {
        for (var prop in obj) { if (!Object.prototype.hasOwnProperty.call(result, prop))
          { result[prop] = obj[prop]; } }
      });
      return result
    }

    function changedNodeViews(a, b) {
      var nA = 0, nB = 0;
      for (var prop in a) {
        if (a[prop] != b[prop]) { return true }
        nA++;
      }
      for (var _ in b) { nB++; }
      return nA != nB
    }
    //# sourceMappingURL=index.es.js.map

    var pDOM = ["p", 0], blockquoteDOM = ["blockquote", 0], hrDOM = ["hr"],
          preDOM = ["pre", ["code", 0]], brDOM = ["br"];

    // :: Object
    // [Specs](#model.NodeSpec) for the nodes defined in this schema.
    var nodes = {
      // :: NodeSpec The top level document node.
      doc: {
        content: "block+"
      },

      // :: NodeSpec A plain paragraph textblock. Represented in the DOM
      // as a `<p>` element.
      paragraph: {
        content: "inline*",
        group: "block",
        parseDOM: [{tag: "p"}],
        toDOM: function toDOM() { return pDOM }
      },

      // :: NodeSpec A blockquote (`<blockquote>`) wrapping one or more blocks.
      blockquote: {
        content: "block+",
        group: "block",
        defining: true,
        parseDOM: [{tag: "blockquote"}],
        toDOM: function toDOM() { return blockquoteDOM }
      },

      // :: NodeSpec A horizontal rule (`<hr>`).
      horizontal_rule: {
        group: "block",
        parseDOM: [{tag: "hr"}],
        toDOM: function toDOM() { return hrDOM }
      },

      // :: NodeSpec A heading textblock, with a `level` attribute that
      // should hold the number 1 to 6. Parsed and serialized as `<h1>` to
      // `<h6>` elements.
      heading: {
        attrs: {level: {default: 1}},
        content: "inline*",
        group: "block",
        defining: true,
        parseDOM: [{tag: "h1", attrs: {level: 1}},
                   {tag: "h2", attrs: {level: 2}},
                   {tag: "h3", attrs: {level: 3}},
                   {tag: "h4", attrs: {level: 4}},
                   {tag: "h5", attrs: {level: 5}},
                   {tag: "h6", attrs: {level: 6}}],
        toDOM: function toDOM(node) { return ["h" + node.attrs.level, 0] }
      },

      // :: NodeSpec A code listing. Disallows marks or non-text inline
      // nodes by default. Represented as a `<pre>` element with a
      // `<code>` element inside of it.
      code_block: {
        content: "text*",
        marks: "",
        group: "block",
        code: true,
        defining: true,
        parseDOM: [{tag: "pre", preserveWhitespace: "full"}],
        toDOM: function toDOM() { return preDOM }
      },

      // :: NodeSpec The text node.
      text: {
        group: "inline"
      },

      // :: NodeSpec An inline image (`<img>`) node. Supports `src`,
      // `alt`, and `href` attributes. The latter two default to the empty
      // string.
      image: {
        inline: true,
        attrs: {
          src: {},
          alt: {default: null},
          title: {default: null}
        },
        group: "inline",
        draggable: true,
        parseDOM: [{tag: "img[src]", getAttrs: function getAttrs(dom) {
          return {
            src: dom.getAttribute("src"),
            title: dom.getAttribute("title"),
            alt: dom.getAttribute("alt")
          }
        }}],
        toDOM: function toDOM(node) { var ref = node.attrs;
        var src = ref.src;
        var alt = ref.alt;
        var title = ref.title; return ["img", {src: src, alt: alt, title: title}] }
      },

      // :: NodeSpec A hard line break, represented in the DOM as `<br>`.
      hard_break: {
        inline: true,
        group: "inline",
        selectable: false,
        parseDOM: [{tag: "br"}],
        toDOM: function toDOM() { return brDOM }
      }
    };

    var emDOM = ["em", 0], strongDOM = ["strong", 0], codeDOM = ["code", 0];

    // :: Object [Specs](#model.MarkSpec) for the marks in the schema.
    var marks = {
      // :: MarkSpec A link. Has `href` and `title` attributes. `title`
      // defaults to the empty string. Rendered and parsed as an `<a>`
      // element.
      link: {
        attrs: {
          href: {},
          title: {default: null}
        },
        inclusive: false,
        parseDOM: [{tag: "a[href]", getAttrs: function getAttrs(dom) {
          return {href: dom.getAttribute("href"), title: dom.getAttribute("title")}
        }}],
        toDOM: function toDOM(node) { var ref = node.attrs;
        var href = ref.href;
        var title = ref.title; return ["a", {href: href, title: title}, 0] }
      },

      // :: MarkSpec An emphasis mark. Rendered as an `<em>` element.
      // Has parse rules that also match `<i>` and `font-style: italic`.
      em: {
        parseDOM: [{tag: "i"}, {tag: "em"}, {style: "font-style=italic"}],
        toDOM: function toDOM() { return emDOM }
      },

      // :: MarkSpec A strong mark. Rendered as `<strong>`, parse rules
      // also match `<b>` and `font-weight: bold`.
      strong: {
        parseDOM: [{tag: "strong"},
                   // This works around a Google Docs misbehavior where
                   // pasted content will be inexplicably wrapped in `<b>`
                   // tags with a font-weight normal.
                   {tag: "b", getAttrs: function (node) { return node.style.fontWeight != "normal" && null; }},
                   {style: "font-weight", getAttrs: function (value) { return /^(bold(er)?|[5-9]\d{2,})$/.test(value) && null; }}],
        toDOM: function toDOM() { return strongDOM }
      },

      // :: MarkSpec Code font mark. Represented as a `<code>` element.
      code: {
        parseDOM: [{tag: "code"}],
        toDOM: function toDOM() { return codeDOM }
      }
    };

    // :: Schema
    // This schema roughly corresponds to the document schema used by
    // [CommonMark](http://commonmark.org/), minus the list elements,
    // which are defined in the [`prosemirror-schema-list`](#schema-list)
    // module.
    //
    // To reuse elements from this schema, extend or read from its
    // `spec.nodes` and `spec.marks` [properties](#model.Schema.spec).
    var schema = new Schema({nodes: nodes, marks: marks});
    //# sourceMappingURL=index.es.js.map

    var olDOM = ["ol", 0], ulDOM = ["ul", 0], liDOM = ["li", 0];

    // :: NodeSpec
    // An ordered list [node spec](#model.NodeSpec). Has a single
    // attribute, `order`, which determines the number at which the list
    // starts counting, and defaults to 1. Represented as an `<ol>`
    // element.
    var orderedList = {
      attrs: {order: {default: 1}},
      parseDOM: [{tag: "ol", getAttrs: function getAttrs(dom) {
        return {order: dom.hasAttribute("start") ? +dom.getAttribute("start") : 1}
      }}],
      toDOM: function toDOM(node) {
        return node.attrs.order == 1 ? olDOM : ["ol", {start: node.attrs.order}, 0]
      }
    };

    // :: NodeSpec
    // A bullet list node spec, represented in the DOM as `<ul>`.
    var bulletList = {
      parseDOM: [{tag: "ul"}],
      toDOM: function toDOM() { return ulDOM }
    };

    // :: NodeSpec
    // A list item (`<li>`) spec.
    var listItem = {
      parseDOM: [{tag: "li"}],
      toDOM: function toDOM() { return liDOM },
      defining: true
    };

    function add(obj, props) {
      var copy = {};
      for (var prop in obj) { copy[prop] = obj[prop]; }
      for (var prop$1 in props) { copy[prop$1] = props[prop$1]; }
      return copy
    }

    // :: (OrderedMap<NodeSpec>, string, ?string) → OrderedMap<NodeSpec>
    // Convenience function for adding list-related node types to a map
    // specifying the nodes for a schema. Adds
    // [`orderedList`](#schema-list.orderedList) as `"ordered_list"`,
    // [`bulletList`](#schema-list.bulletList) as `"bullet_list"`, and
    // [`listItem`](#schema-list.listItem) as `"list_item"`.
    //
    // `itemContent` determines the content expression for the list items.
    // If you want the commands defined in this module to apply to your
    // list structure, it should have a shape like `"paragraph block*"` or
    // `"paragraph (ordered_list | bullet_list)*"`. `listGroup` can be
    // given to assign a group name to the list node types, for example
    // `"block"`.
    function addListNodes(nodes, itemContent, listGroup) {
      return nodes.append({
        ordered_list: add(orderedList, {content: "list_item+", group: listGroup}),
        bullet_list: add(bulletList, {content: "list_item+", group: listGroup}),
        list_item: add(listItem, {content: itemContent})
      })
    }

    // :: (NodeType, ?Object) → (state: EditorState, dispatch: ?(tr: Transaction)) → bool
    // Returns a command function that wraps the selection in a list with
    // the given type an attributes. If `dispatch` is null, only return a
    // value to indicate whether this is possible, but don't actually
    // perform the change.
    function wrapInList(listType, attrs) {
      return function(state, dispatch) {
        var ref = state.selection;
        var $from = ref.$from;
        var $to = ref.$to;
        var range = $from.blockRange($to), doJoin = false, outerRange = range;
        if (!range) { return false }
        // This is at the top of an existing list item
        if (range.depth >= 2 && $from.node(range.depth - 1).type.compatibleContent(listType) && range.startIndex == 0) {
          // Don't do anything if this is the top of the list
          if ($from.index(range.depth - 1) == 0) { return false }
          var $insert = state.doc.resolve(range.start - 2);
          outerRange = new NodeRange($insert, $insert, range.depth);
          if (range.endIndex < range.parent.childCount)
            { range = new NodeRange($from, state.doc.resolve($to.end(range.depth)), range.depth); }
          doJoin = true;
        }
        var wrap = findWrapping(outerRange, listType, attrs, range);
        if (!wrap) { return false }
        if (dispatch) { dispatch(doWrapInList(state.tr, range, wrap, doJoin, listType).scrollIntoView()); }
        return true
      }
    }

    function doWrapInList(tr, range, wrappers, joinBefore, listType) {
      var content = Fragment.empty;
      for (var i = wrappers.length - 1; i >= 0; i--)
        { content = Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content)); }

      tr.step(new ReplaceAroundStep(range.start - (joinBefore ? 2 : 0), range.end, range.start, range.end,
                                    new Slice(content, 0, 0), wrappers.length, true));

      var found = 0;
      for (var i$1 = 0; i$1 < wrappers.length; i$1++) { if (wrappers[i$1].type == listType) { found = i$1 + 1; } }
      var splitDepth = wrappers.length - found;

      var splitPos = range.start + wrappers.length - (joinBefore ? 2 : 0), parent = range.parent;
      for (var i$2 = range.startIndex, e = range.endIndex, first = true; i$2 < e; i$2++, first = false) {
        if (!first && canSplit(tr.doc, splitPos, splitDepth)) {
          tr.split(splitPos, splitDepth);
          splitPos += 2 * splitDepth;
        }
        splitPos += parent.child(i$2).nodeSize;
      }
      return tr
    }

    // :: (NodeType) → (state: EditorState, dispatch: ?(tr: Transaction)) → bool
    // Build a command that splits a non-empty textblock at the top level
    // of a list item by also splitting that list item.
    function splitListItem(itemType) {
      return function(state, dispatch) {
        var ref = state.selection;
        var $from = ref.$from;
        var $to = ref.$to;
        var node = ref.node;
        if ((node && node.isBlock) || $from.depth < 2 || !$from.sameParent($to)) { return false }
        var grandParent = $from.node(-1);
        if (grandParent.type != itemType) { return false }
        if ($from.parent.content.size == 0 && $from.node(-1).childCount == $from.indexAfter(-1)) {
          // In an empty block. If this is a nested list, the wrapping
          // list item should be split. Otherwise, bail out and let next
          // command handle lifting.
          if ($from.depth == 2 || $from.node(-3).type != itemType ||
              $from.index(-2) != $from.node(-2).childCount - 1) { return false }
          if (dispatch) {
            var wrap = Fragment.empty, keepItem = $from.index(-1) > 0;
            // Build a fragment containing empty versions of the structure
            // from the outer list item to the parent node of the cursor
            for (var d = $from.depth - (keepItem ? 1 : 2); d >= $from.depth - 3; d--)
              { wrap = Fragment.from($from.node(d).copy(wrap)); }
            // Add a second list item with an empty default start node
            wrap = wrap.append(Fragment.from(itemType.createAndFill()));
            var tr$1 = state.tr.replace($from.before(keepItem ? null : -1), $from.after(-3), new Slice(wrap, keepItem ? 3 : 2, 2));
            tr$1.setSelection(state.selection.constructor.near(tr$1.doc.resolve($from.pos + (keepItem ? 3 : 2))));
            dispatch(tr$1.scrollIntoView());
          }
          return true
        }
        var nextType = $to.pos == $from.end() ? grandParent.contentMatchAt(0).defaultType : null;
        var tr = state.tr.delete($from.pos, $to.pos);
        var types = nextType && [null, {type: nextType}];
        if (!canSplit(tr.doc, $from.pos, 2, types)) { return false }
        if (dispatch) { dispatch(tr.split($from.pos, 2, types).scrollIntoView()); }
        return true
      }
    }

    // :: (NodeType) → (state: EditorState, dispatch: ?(tr: Transaction)) → bool
    // Create a command to lift the list item around the selection up into
    // a wrapping list.
    function liftListItem(itemType) {
      return function(state, dispatch) {
        var ref = state.selection;
        var $from = ref.$from;
        var $to = ref.$to;
        var range = $from.blockRange($to, function (node) { return node.childCount && node.firstChild.type == itemType; });
        if (!range) { return false }
        if (!dispatch) { return true }
        if ($from.node(range.depth - 1).type == itemType) // Inside a parent list
          { return liftToOuterList(state, dispatch, itemType, range) }
        else // Outer list node
          { return liftOutOfList(state, dispatch, range) }
      }
    }

    function liftToOuterList(state, dispatch, itemType, range) {
      var tr = state.tr, end = range.end, endOfList = range.$to.end(range.depth);
      if (end < endOfList) {
        // There are siblings after the lifted items, which must become
        // children of the last item
        tr.step(new ReplaceAroundStep(end - 1, endOfList, end, endOfList,
                                      new Slice(Fragment.from(itemType.create(null, range.parent.copy())), 1, 0), 1, true));
        range = new NodeRange(tr.doc.resolve(range.$from.pos), tr.doc.resolve(endOfList), range.depth);
      }
      dispatch(tr.lift(range, liftTarget(range)).scrollIntoView());
      return true
    }

    function liftOutOfList(state, dispatch, range) {
      var tr = state.tr, list = range.parent;
      // Merge the list items into a single big item
      for (var pos = range.end, i = range.endIndex - 1, e = range.startIndex; i > e; i--) {
        pos -= list.child(i).nodeSize;
        tr.delete(pos - 1, pos + 1);
      }
      var $start = tr.doc.resolve(range.start), item = $start.nodeAfter;
      var atStart = range.startIndex == 0, atEnd = range.endIndex == list.childCount;
      var parent = $start.node(-1), indexBefore = $start.index(-1);
      if (!parent.canReplace(indexBefore + (atStart ? 0 : 1), indexBefore + 1,
                             item.content.append(atEnd ? Fragment.empty : Fragment.from(list))))
        { return false }
      var start = $start.pos, end = start + item.nodeSize;
      // Strip off the surrounding list. At the sides where we're not at
      // the end of the list, the existing list is closed. At sides where
      // this is the end, it is overwritten to its end.
      tr.step(new ReplaceAroundStep(start - (atStart ? 1 : 0), end + (atEnd ? 1 : 0), start + 1, end - 1,
                                    new Slice((atStart ? Fragment.empty : Fragment.from(list.copy(Fragment.empty)))
                                              .append(atEnd ? Fragment.empty : Fragment.from(list.copy(Fragment.empty))),
                                              atStart ? 0 : 1, atEnd ? 0 : 1), atStart ? 0 : 1));
      dispatch(tr.scrollIntoView());
      return true
    }

    // :: (NodeType) → (state: EditorState, dispatch: ?(tr: Transaction)) → bool
    // Create a command to sink the list item around the selection down
    // into an inner list.
    function sinkListItem(itemType) {
      return function(state, dispatch) {
        var ref = state.selection;
        var $from = ref.$from;
        var $to = ref.$to;
        var range = $from.blockRange($to, function (node) { return node.childCount && node.firstChild.type == itemType; });
        if (!range) { return false }
        var startIndex = range.startIndex;
        if (startIndex == 0) { return false }
        var parent = range.parent, nodeBefore = parent.child(startIndex - 1);
        if (nodeBefore.type != itemType) { return false }

        if (dispatch) {
          var nestedBefore = nodeBefore.lastChild && nodeBefore.lastChild.type == parent.type;
          var inner = Fragment.from(nestedBefore ? itemType.create() : null);
          var slice = new Slice(Fragment.from(itemType.create(null, Fragment.from(parent.type.create(null, inner)))),
                                nestedBefore ? 3 : 1, 0);
          var before = range.start, after = range.end;
          dispatch(state.tr.step(new ReplaceAroundStep(before - (nestedBefore ? 3 : 1), after,
                                                       before, after, slice, 1, true))
                   .scrollIntoView());
        }
        return true
      }
    }
    //# sourceMappingURL=index.es.js.map

    var base = {
      8: "Backspace",
      9: "Tab",
      10: "Enter",
      12: "NumLock",
      13: "Enter",
      16: "Shift",
      17: "Control",
      18: "Alt",
      20: "CapsLock",
      27: "Escape",
      32: " ",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      44: "PrintScreen",
      45: "Insert",
      46: "Delete",
      59: ";",
      61: "=",
      91: "Meta",
      92: "Meta",
      106: "*",
      107: "+",
      108: ",",
      109: "-",
      110: ".",
      111: "/",
      144: "NumLock",
      145: "ScrollLock",
      160: "Shift",
      161: "Shift",
      162: "Control",
      163: "Control",
      164: "Alt",
      165: "Alt",
      173: "-",
      186: ";",
      187: "=",
      188: ",",
      189: "-",
      190: ".",
      191: "/",
      192: "`",
      219: "[",
      220: "\\",
      221: "]",
      222: "'",
      229: "q"
    };

    var shift = {
      48: ")",
      49: "!",
      50: "@",
      51: "#",
      52: "$",
      53: "%",
      54: "^",
      55: "&",
      56: "*",
      57: "(",
      59: ":",
      61: "+",
      173: "_",
      186: ":",
      187: "+",
      188: "<",
      189: "_",
      190: ">",
      191: "?",
      192: "~",
      219: "{",
      220: "|",
      221: "}",
      222: "\"",
      229: "Q"
    };

    var chrome$1 = typeof navigator != "undefined" && /Chrome\/(\d+)/.exec(navigator.userAgent);
    var safari = typeof navigator != "undefined" && /Apple Computer/.test(navigator.vendor);
    var gecko = typeof navigator != "undefined" && /Gecko\/\d+/.test(navigator.userAgent);
    var mac = typeof navigator != "undefined" && /Mac/.test(navigator.platform);
    var ie$1 = typeof navigator != "undefined" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
    var brokenModifierNames = chrome$1 && (mac || +chrome$1[1] < 57) || gecko && mac;

    // Fill in the digit keys
    for (var i = 0; i < 10; i++) base[48 + i] = base[96 + i] = String(i);

    // The function keys
    for (var i = 1; i <= 24; i++) base[i + 111] = "F" + i;

    // And the alphabetic keys
    for (var i = 65; i <= 90; i++) {
      base[i] = String.fromCharCode(i + 32);
      shift[i] = String.fromCharCode(i);
    }

    // For each code that doesn't have a shift-equivalent, copy the base name
    for (var code in base) if (!shift.hasOwnProperty(code)) shift[code] = base[code];

    function keyName(event) {
      // Don't trust event.key in Chrome when there are modifiers until
      // they fix https://bugs.chromium.org/p/chromium/issues/detail?id=633838
      var ignoreKey = brokenModifierNames && (event.ctrlKey || event.altKey || event.metaKey) ||
        (safari || ie$1) && event.shiftKey && event.key && event.key.length == 1;
      var name = (!ignoreKey && event.key) ||
        (event.shiftKey ? shift : base)[event.keyCode] ||
        event.key || "Unidentified";
      // Edge sometimes produces wrong names (Issue #3)
      if (name == "Esc") name = "Escape";
      if (name == "Del") name = "Delete";
      // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/8860571/
      if (name == "Left") name = "ArrowLeft";
      if (name == "Up") name = "ArrowUp";
      if (name == "Right") name = "ArrowRight";
      if (name == "Down") name = "ArrowDown";
      return name
    }

    // declare global: navigator

    var mac$1 = typeof navigator != "undefined" ? /Mac/.test(navigator.platform) : false;

    function normalizeKeyName(name) {
      var parts = name.split(/-(?!$)/), result = parts[parts.length - 1];
      if (result == "Space") { result = " "; }
      var alt, ctrl, shift, meta;
      for (var i = 0; i < parts.length - 1; i++) {
        var mod = parts[i];
        if (/^(cmd|meta|m)$/i.test(mod)) { meta = true; }
        else if (/^a(lt)?$/i.test(mod)) { alt = true; }
        else if (/^(c|ctrl|control)$/i.test(mod)) { ctrl = true; }
        else if (/^s(hift)?$/i.test(mod)) { shift = true; }
        else if (/^mod$/i.test(mod)) { if (mac$1) { meta = true; } else { ctrl = true; } }
        else { throw new Error("Unrecognized modifier name: " + mod) }
      }
      if (alt) { result = "Alt-" + result; }
      if (ctrl) { result = "Ctrl-" + result; }
      if (meta) { result = "Meta-" + result; }
      if (shift) { result = "Shift-" + result; }
      return result
    }

    function normalize(map) {
      var copy = Object.create(null);
      for (var prop in map) { copy[normalizeKeyName(prop)] = map[prop]; }
      return copy
    }

    function modifiers(name, event, shift) {
      if (event.altKey) { name = "Alt-" + name; }
      if (event.ctrlKey) { name = "Ctrl-" + name; }
      if (event.metaKey) { name = "Meta-" + name; }
      if (shift !== false && event.shiftKey) { name = "Shift-" + name; }
      return name
    }

    // :: (Object) → Plugin
    // Create a keymap plugin for the given set of bindings.
    //
    // Bindings should map key names to [command](#commands)-style
    // functions, which will be called with `(EditorState, dispatch,
    // EditorView)` arguments, and should return true when they've handled
    // the key. Note that the view argument isn't part of the command
    // protocol, but can be used as an escape hatch if a binding needs to
    // directly interact with the UI.
    //
    // Key names may be strings like `"Shift-Ctrl-Enter"`—a key
    // identifier prefixed with zero or more modifiers. Key identifiers
    // are based on the strings that can appear in
    // [`KeyEvent.key`](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key).
    // Use lowercase letters to refer to letter keys (or uppercase letters
    // if you want shift to be held). You may use `"Space"` as an alias
    // for the `" "` name.
    //
    // Modifiers can be given in any order. `Shift-` (or `s-`), `Alt-` (or
    // `a-`), `Ctrl-` (or `c-` or `Control-`) and `Cmd-` (or `m-` or
    // `Meta-`) are recognized. For characters that are created by holding
    // shift, the `Shift-` prefix is implied, and should not be added
    // explicitly.
    //
    // You can use `Mod-` as a shorthand for `Cmd-` on Mac and `Ctrl-` on
    // other platforms.
    //
    // You can add multiple keymap plugins to an editor. The order in
    // which they appear determines their precedence (the ones early in
    // the array get to dispatch first).
    function keymap(bindings) {
      return new Plugin({props: {handleKeyDown: keydownHandler(bindings)}})
    }

    // :: (Object) → (view: EditorView, event: dom.Event) → bool
    // Given a set of bindings (using the same format as
    // [`keymap`](#keymap.keymap), return a [keydown
    // handler](#view.EditorProps.handleKeyDown) that handles them.
    function keydownHandler(bindings) {
      var map = normalize(bindings);
      return function(view, event) {
        var name = keyName(event), isChar = name.length == 1 && name != " ", baseName;
        var direct = map[modifiers(name, event, !isChar)];
        if (direct && direct(view.state, view.dispatch, view)) { return true }
        if (isChar && (event.shiftKey || event.altKey || event.metaKey || name.charCodeAt(0) > 127) &&
            (baseName = base[event.keyCode]) && baseName != name) {
          // Try falling back to the keyCode when there's a modifier
          // active or the character produced isn't ASCII, and our table
          // produces a different name from the the keyCode. See #668,
          // #1060
          var fromCode = map[modifiers(baseName, event, true)];
          if (fromCode && fromCode(view.state, view.dispatch, view)) { return true }
        } else if (isChar && event.shiftKey) {
          // Otherwise, if shift is active, also try the binding with the
          // Shift- prefix enabled. See #997
          var withShift = map[modifiers(name, event, true)];
          if (withShift && withShift(view.state, view.dispatch, view)) { return true }
        }
        return false
      }
    }
    //# sourceMappingURL=index.es.js.map

    var GOOD_LEAF_SIZE = 200;

    // :: class<T> A rope sequence is a persistent sequence data structure
    // that supports appending, prepending, and slicing without doing a
    // full copy. It is represented as a mostly-balanced tree.
    var RopeSequence = function RopeSequence () {};

    RopeSequence.prototype.append = function append (other) {
      if (!other.length) { return this }
      other = RopeSequence.from(other);

      return (!this.length && other) ||
        (other.length < GOOD_LEAF_SIZE && this.leafAppend(other)) ||
        (this.length < GOOD_LEAF_SIZE && other.leafPrepend(this)) ||
        this.appendInner(other)
    };

    // :: (union<[T], RopeSequence<T>>) → RopeSequence<T>
    // Prepend an array or other rope to this one, returning a new rope.
    RopeSequence.prototype.prepend = function prepend (other) {
      if (!other.length) { return this }
      return RopeSequence.from(other).append(this)
    };

    RopeSequence.prototype.appendInner = function appendInner (other) {
      return new Append(this, other)
    };

    // :: (?number, ?number) → RopeSequence<T>
    // Create a rope repesenting a sub-sequence of this rope.
    RopeSequence.prototype.slice = function slice (from, to) {
        if ( from === void 0 ) from = 0;
        if ( to === void 0 ) to = this.length;

      if (from >= to) { return RopeSequence.empty }
      return this.sliceInner(Math.max(0, from), Math.min(this.length, to))
    };

    // :: (number) → T
    // Retrieve the element at the given position from this rope.
    RopeSequence.prototype.get = function get (i) {
      if (i < 0 || i >= this.length) { return undefined }
      return this.getInner(i)
    };

    // :: ((element: T, index: number) → ?bool, ?number, ?number)
    // Call the given function for each element between the given
    // indices. This tends to be more efficient than looping over the
    // indices and calling `get`, because it doesn't have to descend the
    // tree for every element.
    RopeSequence.prototype.forEach = function forEach (f, from, to) {
        if ( from === void 0 ) from = 0;
        if ( to === void 0 ) to = this.length;

      if (from <= to)
        { this.forEachInner(f, from, to, 0); }
      else
        { this.forEachInvertedInner(f, from, to, 0); }
    };

    // :: ((element: T, index: number) → U, ?number, ?number) → [U]
    // Map the given functions over the elements of the rope, producing
    // a flat array.
    RopeSequence.prototype.map = function map (f, from, to) {
        if ( from === void 0 ) from = 0;
        if ( to === void 0 ) to = this.length;

      var result = [];
      this.forEach(function (elt, i) { return result.push(f(elt, i)); }, from, to);
      return result
    };

    // :: (?union<[T], RopeSequence<T>>) → RopeSequence<T>
    // Create a rope representing the given array, or return the rope
    // itself if a rope was given.
    RopeSequence.from = function from (values) {
      if (values instanceof RopeSequence) { return values }
      return values && values.length ? new Leaf(values) : RopeSequence.empty
    };

    var Leaf = /*@__PURE__*/(function (RopeSequence) {
      function Leaf(values) {
        RopeSequence.call(this);
        this.values = values;
      }

      if ( RopeSequence ) Leaf.__proto__ = RopeSequence;
      Leaf.prototype = Object.create( RopeSequence && RopeSequence.prototype );
      Leaf.prototype.constructor = Leaf;

      var prototypeAccessors = { length: { configurable: true },depth: { configurable: true } };

      Leaf.prototype.flatten = function flatten () {
        return this.values
      };

      Leaf.prototype.sliceInner = function sliceInner (from, to) {
        if (from == 0 && to == this.length) { return this }
        return new Leaf(this.values.slice(from, to))
      };

      Leaf.prototype.getInner = function getInner (i) {
        return this.values[i]
      };

      Leaf.prototype.forEachInner = function forEachInner (f, from, to, start) {
        for (var i = from; i < to; i++)
          { if (f(this.values[i], start + i) === false) { return false } }
      };

      Leaf.prototype.forEachInvertedInner = function forEachInvertedInner (f, from, to, start) {
        for (var i = from - 1; i >= to; i--)
          { if (f(this.values[i], start + i) === false) { return false } }
      };

      Leaf.prototype.leafAppend = function leafAppend (other) {
        if (this.length + other.length <= GOOD_LEAF_SIZE)
          { return new Leaf(this.values.concat(other.flatten())) }
      };

      Leaf.prototype.leafPrepend = function leafPrepend (other) {
        if (this.length + other.length <= GOOD_LEAF_SIZE)
          { return new Leaf(other.flatten().concat(this.values)) }
      };

      prototypeAccessors.length.get = function () { return this.values.length };

      prototypeAccessors.depth.get = function () { return 0 };

      Object.defineProperties( Leaf.prototype, prototypeAccessors );

      return Leaf;
    }(RopeSequence));

    // :: RopeSequence
    // The empty rope sequence.
    RopeSequence.empty = new Leaf([]);

    var Append = /*@__PURE__*/(function (RopeSequence) {
      function Append(left, right) {
        RopeSequence.call(this);
        this.left = left;
        this.right = right;
        this.length = left.length + right.length;
        this.depth = Math.max(left.depth, right.depth) + 1;
      }

      if ( RopeSequence ) Append.__proto__ = RopeSequence;
      Append.prototype = Object.create( RopeSequence && RopeSequence.prototype );
      Append.prototype.constructor = Append;

      Append.prototype.flatten = function flatten () {
        return this.left.flatten().concat(this.right.flatten())
      };

      Append.prototype.getInner = function getInner (i) {
        return i < this.left.length ? this.left.get(i) : this.right.get(i - this.left.length)
      };

      Append.prototype.forEachInner = function forEachInner (f, from, to, start) {
        var leftLen = this.left.length;
        if (from < leftLen &&
            this.left.forEachInner(f, from, Math.min(to, leftLen), start) === false)
          { return false }
        if (to > leftLen &&
            this.right.forEachInner(f, Math.max(from - leftLen, 0), Math.min(this.length, to) - leftLen, start + leftLen) === false)
          { return false }
      };

      Append.prototype.forEachInvertedInner = function forEachInvertedInner (f, from, to, start) {
        var leftLen = this.left.length;
        if (from > leftLen &&
            this.right.forEachInvertedInner(f, from - leftLen, Math.max(to, leftLen) - leftLen, start + leftLen) === false)
          { return false }
        if (to < leftLen &&
            this.left.forEachInvertedInner(f, Math.min(from, leftLen), to, start) === false)
          { return false }
      };

      Append.prototype.sliceInner = function sliceInner (from, to) {
        if (from == 0 && to == this.length) { return this }
        var leftLen = this.left.length;
        if (to <= leftLen) { return this.left.slice(from, to) }
        if (from >= leftLen) { return this.right.slice(from - leftLen, to - leftLen) }
        return this.left.slice(from, leftLen).append(this.right.slice(0, to - leftLen))
      };

      Append.prototype.leafAppend = function leafAppend (other) {
        var inner = this.right.leafAppend(other);
        if (inner) { return new Append(this.left, inner) }
      };

      Append.prototype.leafPrepend = function leafPrepend (other) {
        var inner = this.left.leafPrepend(other);
        if (inner) { return new Append(inner, this.right) }
      };

      Append.prototype.appendInner = function appendInner (other) {
        if (this.left.depth >= Math.max(this.right.depth, other.depth) + 1)
          { return new Append(this.left, new Append(this.right, other)) }
        return new Append(this, other)
      };

      return Append;
    }(RopeSequence));

    var ropeSequence = RopeSequence;

    // ProseMirror's history isn't simply a way to roll back to a previous
    // state, because ProseMirror supports applying changes without adding
    // them to the history (for example during collaboration).
    //
    // To this end, each 'Branch' (one for the undo history and one for
    // the redo history) keeps an array of 'Items', which can optionally
    // hold a step (an actual undoable change), and always hold a position
    // map (which is needed to move changes below them to apply to the
    // current document).
    //
    // An item that has both a step and a selection bookmark is the start
    // of an 'event' — a group of changes that will be undone or redone at
    // once. (It stores only the bookmark, since that way we don't have to
    // provide a document until the selection is actually applied, which
    // is useful when compressing.)

    // Used to schedule history compression
    var max_empty_items = 500;

    var Branch = function Branch(items, eventCount) {
      this.items = items;
      this.eventCount = eventCount;
    };

    // : (EditorState, bool) → ?{transform: Transform, selection: ?SelectionBookmark, remaining: Branch}
    // Pop the latest event off the branch's history and apply it
    // to a document transform.
    Branch.prototype.popEvent = function popEvent (state, preserveItems) {
        var this$1 = this;

      if (this.eventCount == 0) { return null }

      var end = this.items.length;
      for (;; end--) {
        var next = this.items.get(end - 1);
        if (next.selection) { --end; break }
      }

      var remap, mapFrom;
      if (preserveItems) {
        remap = this.remapping(end, this.items.length);
        mapFrom = remap.maps.length;
      }
      var transform = state.tr;
      var selection, remaining;
      var addAfter = [], addBefore = [];

      this.items.forEach(function (item, i) {
        if (!item.step) {
          if (!remap) {
            remap = this$1.remapping(end, i + 1);
            mapFrom = remap.maps.length;
          }
          mapFrom--;
          addBefore.push(item);
          return
        }

        if (remap) {
          addBefore.push(new Item(item.map));
          var step = item.step.map(remap.slice(mapFrom)), map;

          if (step && transform.maybeStep(step).doc) {
            map = transform.mapping.maps[transform.mapping.maps.length - 1];
            addAfter.push(new Item(map, null, null, addAfter.length + addBefore.length));
          }
          mapFrom--;
          if (map) { remap.appendMap(map, mapFrom); }
        } else {
          transform.maybeStep(item.step);
        }

        if (item.selection) {
          selection = remap ? item.selection.map(remap.slice(mapFrom)) : item.selection;
          remaining = new Branch(this$1.items.slice(0, end).append(addBefore.reverse().concat(addAfter)), this$1.eventCount - 1);
          return false
        }
      }, this.items.length, 0);

      return {remaining: remaining, transform: transform, selection: selection}
    };

    // : (Transform, ?SelectionBookmark, Object) → Branch
    // Create a new branch with the given transform added.
    Branch.prototype.addTransform = function addTransform (transform, selection, histOptions, preserveItems) {
      var newItems = [], eventCount = this.eventCount;
      var oldItems = this.items, lastItem = !preserveItems && oldItems.length ? oldItems.get(oldItems.length - 1) : null;

      for (var i = 0; i < transform.steps.length; i++) {
        var step = transform.steps[i].invert(transform.docs[i]);
        var item = new Item(transform.mapping.maps[i], step, selection), merged = (void 0);
        if (merged = lastItem && lastItem.merge(item)) {
          item = merged;
          if (i) { newItems.pop(); }
          else { oldItems = oldItems.slice(0, oldItems.length - 1); }
        }
        newItems.push(item);
        if (selection) {
          eventCount++;
          selection = null;
        }
        if (!preserveItems) { lastItem = item; }
      }
      var overflow = eventCount - histOptions.depth;
      if (overflow > DEPTH_OVERFLOW) {
        oldItems = cutOffEvents(oldItems, overflow);
        eventCount -= overflow;
      }
      return new Branch(oldItems.append(newItems), eventCount)
    };

    Branch.prototype.remapping = function remapping (from, to) {
      var maps = new Mapping;
      this.items.forEach(function (item, i) {
        var mirrorPos = item.mirrorOffset != null && i - item.mirrorOffset >= from
            ? maps.maps.length - item.mirrorOffset : null;
        maps.appendMap(item.map, mirrorPos);
      }, from, to);
      return maps
    };

    Branch.prototype.addMaps = function addMaps (array) {
      if (this.eventCount == 0) { return this }
      return new Branch(this.items.append(array.map(function (map) { return new Item(map); })), this.eventCount)
    };

    // : (Transform, number)
    // When the collab module receives remote changes, the history has
    // to know about those, so that it can adjust the steps that were
    // rebased on top of the remote changes, and include the position
    // maps for the remote changes in its array of items.
    Branch.prototype.rebased = function rebased (rebasedTransform, rebasedCount) {
      if (!this.eventCount) { return this }

      var rebasedItems = [], start = Math.max(0, this.items.length - rebasedCount);

      var mapping = rebasedTransform.mapping;
      var newUntil = rebasedTransform.steps.length;
      var eventCount = this.eventCount;
      this.items.forEach(function (item) { if (item.selection) { eventCount--; } }, start);

      var iRebased = rebasedCount;
      this.items.forEach(function (item) {
        var pos = mapping.getMirror(--iRebased);
        if (pos == null) { return }
        newUntil = Math.min(newUntil, pos);
        var map = mapping.maps[pos];
        if (item.step) {
          var step = rebasedTransform.steps[pos].invert(rebasedTransform.docs[pos]);
          var selection = item.selection && item.selection.map(mapping.slice(iRebased + 1, pos));
          if (selection) { eventCount++; }
          rebasedItems.push(new Item(map, step, selection));
        } else {
          rebasedItems.push(new Item(map));
        }
      }, start);

      var newMaps = [];
      for (var i = rebasedCount; i < newUntil; i++)
        { newMaps.push(new Item(mapping.maps[i])); }
      var items = this.items.slice(0, start).append(newMaps).append(rebasedItems);
      var branch = new Branch(items, eventCount);

      if (branch.emptyItemCount() > max_empty_items)
        { branch = branch.compress(this.items.length - rebasedItems.length); }
      return branch
    };

    Branch.prototype.emptyItemCount = function emptyItemCount () {
      var count = 0;
      this.items.forEach(function (item) { if (!item.step) { count++; } });
      return count
    };

    // Compressing a branch means rewriting it to push the air (map-only
    // items) out. During collaboration, these naturally accumulate
    // because each remote change adds one. The `upto` argument is used
    // to ensure that only the items below a given level are compressed,
    // because `rebased` relies on a clean, untouched set of items in
    // order to associate old items with rebased steps.
    Branch.prototype.compress = function compress (upto) {
        if ( upto === void 0 ) upto = this.items.length;

      var remap = this.remapping(0, upto), mapFrom = remap.maps.length;
      var items = [], events = 0;
      this.items.forEach(function (item, i) {
        if (i >= upto) {
          items.push(item);
          if (item.selection) { events++; }
        } else if (item.step) {
          var step = item.step.map(remap.slice(mapFrom)), map = step && step.getMap();
          mapFrom--;
          if (map) { remap.appendMap(map, mapFrom); }
          if (step) {
            var selection = item.selection && item.selection.map(remap.slice(mapFrom));
            if (selection) { events++; }
            var newItem = new Item(map.invert(), step, selection), merged, last = items.length - 1;
            if (merged = items.length && items[last].merge(newItem))
              { items[last] = merged; }
            else
              { items.push(newItem); }
          }
        } else if (item.map) {
          mapFrom--;
        }
      }, this.items.length, 0);
      return new Branch(ropeSequence.from(items.reverse()), events)
    };

    Branch.empty = new Branch(ropeSequence.empty, 0);

    function cutOffEvents(items, n) {
      var cutPoint;
      items.forEach(function (item, i) {
        if (item.selection && (n-- == 0)) {
          cutPoint = i;
          return false
        }
      });
      return items.slice(cutPoint)
    }

    var Item = function Item(map, step, selection, mirrorOffset) {
      // The (forward) step map for this item.
      this.map = map;
      // The inverted step
      this.step = step;
      // If this is non-null, this item is the start of a group, and
      // this selection is the starting selection for the group (the one
      // that was active before the first step was applied)
      this.selection = selection;
      // If this item is the inverse of a previous mapping on the stack,
      // this points at the inverse's offset
      this.mirrorOffset = mirrorOffset;
    };

    Item.prototype.merge = function merge (other) {
      if (this.step && other.step && !other.selection) {
        var step = other.step.merge(this.step);
        if (step) { return new Item(step.getMap().invert(), step, this.selection) }
      }
    };

    // The value of the state field that tracks undo/redo history for that
    // state. Will be stored in the plugin state when the history plugin
    // is active.
    var HistoryState = function HistoryState(done, undone, prevRanges, prevTime) {
      this.done = done;
      this.undone = undone;
      this.prevRanges = prevRanges;
      this.prevTime = prevTime;
    };

    var DEPTH_OVERFLOW = 20;

    // : (HistoryState, EditorState, Transaction, Object)
    // Record a transformation in undo history.
    function applyTransaction(history, state, tr, options) {
      var historyTr = tr.getMeta(historyKey), rebased;
      if (historyTr) { return historyTr.historyState }

      if (tr.getMeta(closeHistoryKey)) { history = new HistoryState(history.done, history.undone, null, 0); }

      var appended = tr.getMeta("appendedTransaction");

      if (tr.steps.length == 0) {
        return history
      } else if (appended && appended.getMeta(historyKey)) {
        if (appended.getMeta(historyKey).redo)
          { return new HistoryState(history.done.addTransform(tr, null, options, mustPreserveItems(state)),
                                  history.undone, rangesFor(tr.mapping.maps[tr.steps.length - 1]), history.prevTime) }
        else
          { return new HistoryState(history.done, history.undone.addTransform(tr, null, options, mustPreserveItems(state)),
                                  null, history.prevTime) }
      } else if (tr.getMeta("addToHistory") !== false && !(appended && appended.getMeta("addToHistory") === false)) {
        // Group transforms that occur in quick succession into one event.
        var newGroup = history.prevTime == 0 || !appended && (history.prevTime < (tr.time || 0) - options.newGroupDelay ||
                                                              !isAdjacentTo(tr, history.prevRanges));
        var prevRanges = appended ? mapRanges(history.prevRanges, tr.mapping) : rangesFor(tr.mapping.maps[tr.steps.length - 1]);
        return new HistoryState(history.done.addTransform(tr, newGroup ? state.selection.getBookmark() : null,
                                                          options, mustPreserveItems(state)),
                                Branch.empty, prevRanges, tr.time)
      } else if (rebased = tr.getMeta("rebased")) {
        // Used by the collab module to tell the history that some of its
        // content has been rebased.
        return new HistoryState(history.done.rebased(tr, rebased),
                                history.undone.rebased(tr, rebased),
                                mapRanges(history.prevRanges, tr.mapping), history.prevTime)
      } else {
        return new HistoryState(history.done.addMaps(tr.mapping.maps),
                                history.undone.addMaps(tr.mapping.maps),
                                mapRanges(history.prevRanges, tr.mapping), history.prevTime)
      }
    }

    function isAdjacentTo(transform, prevRanges) {
      if (!prevRanges) { return false }
      if (!transform.docChanged) { return true }
      var adjacent = false;
      transform.mapping.maps[0].forEach(function (start, end) {
        for (var i = 0; i < prevRanges.length; i += 2)
          { if (start <= prevRanges[i + 1] && end >= prevRanges[i])
            { adjacent = true; } }
      });
      return adjacent
    }

    function rangesFor(map) {
      var result = [];
      map.forEach(function (_from, _to, from, to) { return result.push(from, to); });
      return result
    }

    function mapRanges(ranges, mapping) {
      if (!ranges) { return null }
      var result = [];
      for (var i = 0; i < ranges.length; i += 2) {
        var from = mapping.map(ranges[i], 1), to = mapping.map(ranges[i + 1], -1);
        if (from <= to) { result.push(from, to); }
      }
      return result
    }

    // : (HistoryState, EditorState, (tr: Transaction), bool)
    // Apply the latest event from one branch to the document and shift the event
    // onto the other branch.
    function histTransaction(history, state, dispatch, redo) {
      var preserveItems = mustPreserveItems(state), histOptions = historyKey.get(state).spec.config;
      var pop = (redo ? history.undone : history.done).popEvent(state, preserveItems);
      if (!pop) { return }

      var selection = pop.selection.resolve(pop.transform.doc);
      var added = (redo ? history.done : history.undone).addTransform(pop.transform, state.selection.getBookmark(),
                                                                      histOptions, preserveItems);

      var newHist = new HistoryState(redo ? added : pop.remaining, redo ? pop.remaining : added, null, 0);
      dispatch(pop.transform.setSelection(selection).setMeta(historyKey, {redo: redo, historyState: newHist}).scrollIntoView());
    }

    var cachedPreserveItems = false, cachedPreserveItemsPlugins = null;
    // Check whether any plugin in the given state has a
    // `historyPreserveItems` property in its spec, in which case we must
    // preserve steps exactly as they came in, so that they can be
    // rebased.
    function mustPreserveItems(state) {
      var plugins = state.plugins;
      if (cachedPreserveItemsPlugins != plugins) {
        cachedPreserveItems = false;
        cachedPreserveItemsPlugins = plugins;
        for (var i = 0; i < plugins.length; i++) { if (plugins[i].spec.historyPreserveItems) {
          cachedPreserveItems = true;
          break
        } }
      }
      return cachedPreserveItems
    }

    var historyKey = new PluginKey("history");
    var closeHistoryKey = new PluginKey("closeHistory");

    // :: (?Object) → Plugin
    // Returns a plugin that enables the undo history for an editor. The
    // plugin will track undo and redo stacks, which can be used with the
    // [`undo`](#history.undo) and [`redo`](#history.redo) commands.
    //
    // You can set an `"addToHistory"` [metadata
    // property](#state.Transaction.setMeta) of `false` on a transaction
    // to prevent it from being rolled back by undo.
    //
    //   config::-
    //   Supports the following configuration options:
    //
    //     depth:: ?number
    //     The amount of history events that are collected before the
    //     oldest events are discarded. Defaults to 100.
    //
    //     newGroupDelay:: ?number
    //     The delay between changes after which a new group should be
    //     started. Defaults to 500 (milliseconds). Note that when changes
    //     aren't adjacent, a new group is always started.
    function history(config) {
      config = {depth: config && config.depth || 100,
                newGroupDelay: config && config.newGroupDelay || 500};
      return new Plugin({
        key: historyKey,

        state: {
          init: function init() {
            return new HistoryState(Branch.empty, Branch.empty, null, 0)
          },
          apply: function apply(tr, hist, state) {
            return applyTransaction(hist, state, tr, config)
          }
        },

        config: config
      })
    }

    // :: (EditorState, ?(tr: Transaction)) → bool
    // A command function that undoes the last change, if any.
    function undo(state, dispatch) {
      var hist = historyKey.getState(state);
      if (!hist || hist.done.eventCount == 0) { return false }
      if (dispatch) { histTransaction(hist, state, dispatch, false); }
      return true
    }

    // :: (EditorState, ?(tr: Transaction)) → bool
    // A command function that redoes the last undone change, if any.
    function redo(state, dispatch) {
      var hist = historyKey.getState(state);
      if (!hist || hist.undone.eventCount == 0) { return false }
      if (dispatch) { histTransaction(hist, state, dispatch, true); }
      return true
    }
    //# sourceMappingURL=index.es.js.map

    // :: (EditorState, ?(tr: Transaction)) → bool
    // Delete the selection, if there is one.
    function deleteSelection(state, dispatch) {
      if (state.selection.empty) { return false }
      if (dispatch) { dispatch(state.tr.deleteSelection().scrollIntoView()); }
      return true
    }

    // :: (EditorState, ?(tr: Transaction), ?EditorView) → bool
    // If the selection is empty and at the start of a textblock, try to
    // reduce the distance between that block and the one before it—if
    // there's a block directly before it that can be joined, join them.
    // If not, try to move the selected block closer to the next one in
    // the document structure by lifting it out of its parent or moving it
    // into a parent of the previous block. Will use the view for accurate
    // (bidi-aware) start-of-textblock detection if given.
    function joinBackward(state, dispatch, view) {
      var ref = state.selection;
      var $cursor = ref.$cursor;
      if (!$cursor || (view ? !view.endOfTextblock("backward", state)
                            : $cursor.parentOffset > 0))
        { return false }

      var $cut = findCutBefore($cursor);

      // If there is no node before this, try to lift
      if (!$cut) {
        var range = $cursor.blockRange(), target = range && liftTarget(range);
        if (target == null) { return false }
        if (dispatch) { dispatch(state.tr.lift(range, target).scrollIntoView()); }
        return true
      }

      var before = $cut.nodeBefore;
      // Apply the joining algorithm
      if (!before.type.spec.isolating && deleteBarrier(state, $cut, dispatch))
        { return true }

      // If the node below has no content and the node above is
      // selectable, delete the node below and select the one above.
      if ($cursor.parent.content.size == 0 &&
          (textblockAt(before, "end") || NodeSelection.isSelectable(before))) {
        if (dispatch) {
          var tr = state.tr.deleteRange($cursor.before(), $cursor.after());
          tr.setSelection(textblockAt(before, "end") ? Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos, -1)), -1)
                          : NodeSelection.create(tr.doc, $cut.pos - before.nodeSize));
          dispatch(tr.scrollIntoView());
        }
        return true
      }

      // If the node before is an atom, delete it
      if (before.isAtom && $cut.depth == $cursor.depth - 1) {
        if (dispatch) { dispatch(state.tr.delete($cut.pos - before.nodeSize, $cut.pos).scrollIntoView()); }
        return true
      }

      return false
    }

    function textblockAt(node, side) {
      for (; node; node = (side == "start" ? node.firstChild : node.lastChild))
        { if (node.isTextblock) { return true } }
      return false
    }

    // :: (EditorState, ?(tr: Transaction), ?EditorView) → bool
    // When the selection is empty and at the start of a textblock, select
    // the node before that textblock, if possible. This is intended to be
    // bound to keys like backspace, after
    // [`joinBackward`](#commands.joinBackward) or other deleting
    // commands, as a fall-back behavior when the schema doesn't allow
    // deletion at the selected point.
    function selectNodeBackward(state, dispatch, view) {
      var ref = state.selection;
      var $head = ref.$head;
      var empty = ref.empty;
      var $cut = $head;
      if (!empty) { return false }

      if ($head.parent.isTextblock) {
        if (view ? !view.endOfTextblock("backward", state) : $head.parentOffset > 0) { return false }
        $cut = findCutBefore($head);
      }
      var node = $cut && $cut.nodeBefore;
      if (!node || !NodeSelection.isSelectable(node)) { return false }
      if (dispatch)
        { dispatch(state.tr.setSelection(NodeSelection.create(state.doc, $cut.pos - node.nodeSize)).scrollIntoView()); }
      return true
    }

    function findCutBefore($pos) {
      if (!$pos.parent.type.spec.isolating) { for (var i = $pos.depth - 1; i >= 0; i--) {
        if ($pos.index(i) > 0) { return $pos.doc.resolve($pos.before(i + 1)) }
        if ($pos.node(i).type.spec.isolating) { break }
      } }
      return null
    }

    // :: (EditorState, ?(tr: Transaction), ?EditorView) → bool
    // If the selection is empty and the cursor is at the end of a
    // textblock, try to reduce or remove the boundary between that block
    // and the one after it, either by joining them or by moving the other
    // block closer to this one in the tree structure. Will use the view
    // for accurate start-of-textblock detection if given.
    function joinForward(state, dispatch, view) {
      var ref = state.selection;
      var $cursor = ref.$cursor;
      if (!$cursor || (view ? !view.endOfTextblock("forward", state)
                            : $cursor.parentOffset < $cursor.parent.content.size))
        { return false }

      var $cut = findCutAfter($cursor);

      // If there is no node after this, there's nothing to do
      if (!$cut) { return false }

      var after = $cut.nodeAfter;
      // Try the joining algorithm
      if (deleteBarrier(state, $cut, dispatch)) { return true }

      // If the node above has no content and the node below is
      // selectable, delete the node above and select the one below.
      if ($cursor.parent.content.size == 0 &&
          (textblockAt(after, "start") || NodeSelection.isSelectable(after))) {
        if (dispatch) {
          var tr = state.tr.deleteRange($cursor.before(), $cursor.after());
          tr.setSelection(textblockAt(after, "start") ? Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos)), 1)
                          : NodeSelection.create(tr.doc, tr.mapping.map($cut.pos)));
          dispatch(tr.scrollIntoView());
        }
        return true
      }

      // If the next node is an atom, delete it
      if (after.isAtom && $cut.depth == $cursor.depth - 1) {
        if (dispatch) { dispatch(state.tr.delete($cut.pos, $cut.pos + after.nodeSize).scrollIntoView()); }
        return true
      }

      return false
    }

    // :: (EditorState, ?(tr: Transaction), ?EditorView) → bool
    // When the selection is empty and at the end of a textblock, select
    // the node coming after that textblock, if possible. This is intended
    // to be bound to keys like delete, after
    // [`joinForward`](#commands.joinForward) and similar deleting
    // commands, to provide a fall-back behavior when the schema doesn't
    // allow deletion at the selected point.
    function selectNodeForward(state, dispatch, view) {
      var ref = state.selection;
      var $head = ref.$head;
      var empty = ref.empty;
      var $cut = $head;
      if (!empty) { return false }
      if ($head.parent.isTextblock) {
        if (view ? !view.endOfTextblock("forward", state) : $head.parentOffset < $head.parent.content.size)
          { return false }
        $cut = findCutAfter($head);
      }
      var node = $cut && $cut.nodeAfter;
      if (!node || !NodeSelection.isSelectable(node)) { return false }
      if (dispatch)
        { dispatch(state.tr.setSelection(NodeSelection.create(state.doc, $cut.pos)).scrollIntoView()); }
      return true
    }

    function findCutAfter($pos) {
      if (!$pos.parent.type.spec.isolating) { for (var i = $pos.depth - 1; i >= 0; i--) {
        var parent = $pos.node(i);
        if ($pos.index(i) + 1 < parent.childCount) { return $pos.doc.resolve($pos.after(i + 1)) }
        if (parent.type.spec.isolating) { break }
      } }
      return null
    }

    // :: (EditorState, ?(tr: Transaction)) → bool
    // Join the selected block or, if there is a text selection, the
    // closest ancestor block of the selection that can be joined, with
    // the sibling above it.
    function joinUp(state, dispatch) {
      var sel = state.selection, nodeSel = sel instanceof NodeSelection, point;
      if (nodeSel) {
        if (sel.node.isTextblock || !canJoin(state.doc, sel.from)) { return false }
        point = sel.from;
      } else {
        point = joinPoint(state.doc, sel.from, -1);
        if (point == null) { return false }
      }
      if (dispatch) {
        var tr = state.tr.join(point);
        if (nodeSel) { tr.setSelection(NodeSelection.create(tr.doc, point - state.doc.resolve(point).nodeBefore.nodeSize)); }
        dispatch(tr.scrollIntoView());
      }
      return true
    }

    // :: (EditorState, ?(tr: Transaction)) → bool
    // Join the selected block, or the closest ancestor of the selection
    // that can be joined, with the sibling after it.
    function joinDown(state, dispatch) {
      var sel = state.selection, point;
      if (sel instanceof NodeSelection) {
        if (sel.node.isTextblock || !canJoin(state.doc, sel.to)) { return false }
        point = sel.to;
      } else {
        point = joinPoint(state.doc, sel.to, 1);
        if (point == null) { return false }
      }
      if (dispatch)
        { dispatch(state.tr.join(point).scrollIntoView()); }
      return true
    }

    // :: (EditorState, ?(tr: Transaction)) → bool
    // Lift the selected block, or the closest ancestor block of the
    // selection that can be lifted, out of its parent node.
    function lift(state, dispatch) {
      var ref = state.selection;
      var $from = ref.$from;
      var $to = ref.$to;
      var range = $from.blockRange($to), target = range && liftTarget(range);
      if (target == null) { return false }
      if (dispatch) { dispatch(state.tr.lift(range, target).scrollIntoView()); }
      return true
    }

    // :: (EditorState, ?(tr: Transaction)) → bool
    // If the selection is in a node whose type has a truthy
    // [`code`](#model.NodeSpec.code) property in its spec, replace the
    // selection with a newline character.
    function newlineInCode(state, dispatch) {
      var ref = state.selection;
      var $head = ref.$head;
      var $anchor = ref.$anchor;
      if (!$head.parent.type.spec.code || !$head.sameParent($anchor)) { return false }
      if (dispatch) { dispatch(state.tr.insertText("\n").scrollIntoView()); }
      return true
    }

    function defaultBlockAt(match) {
      for (var i = 0; i < match.edgeCount; i++) {
        var ref = match.edge(i);
        var type = ref.type;
        if (type.isTextblock && !type.hasRequiredAttrs()) { return type }
      }
      return null
    }

    // :: (EditorState, ?(tr: Transaction)) → bool
    // When the selection is in a node with a truthy
    // [`code`](#model.NodeSpec.code) property in its spec, create a
    // default block after the code block, and move the cursor there.
    function exitCode(state, dispatch) {
      var ref = state.selection;
      var $head = ref.$head;
      var $anchor = ref.$anchor;
      if (!$head.parent.type.spec.code || !$head.sameParent($anchor)) { return false }
      var above = $head.node(-1), after = $head.indexAfter(-1), type = defaultBlockAt(above.contentMatchAt(after));
      if (!above.canReplaceWith(after, after, type)) { return false }
      if (dispatch) {
        var pos = $head.after(), tr = state.tr.replaceWith(pos, pos, type.createAndFill());
        tr.setSelection(Selection.near(tr.doc.resolve(pos), 1));
        dispatch(tr.scrollIntoView());
      }
      return true
    }

    // :: (EditorState, ?(tr: Transaction)) → bool
    // If a block node is selected, create an empty paragraph before (if
    // it is its parent's first child) or after it.
    function createParagraphNear(state, dispatch) {
      var sel = state.selection;
      var $from = sel.$from;
      var $to = sel.$to;
      if (!(sel instanceof NodeSelection) || $from.parent.inlineContent) { return false }
      var type = defaultBlockAt($to.parent.contentMatchAt($to.indexAfter()));
      if (!type || !type.isTextblock) { return false }
      if (dispatch) {
        var side = (!$from.parentOffset && $to.index() < $to.parent.childCount ? $from : $to).pos;
        var tr = state.tr.insert(side, type.createAndFill());
        tr.setSelection(TextSelection.create(tr.doc, side + 1));
        dispatch(tr.scrollIntoView());
      }
      return true
    }

    // :: (EditorState, ?(tr: Transaction)) → bool
    // If the cursor is in an empty textblock that can be lifted, lift the
    // block.
    function liftEmptyBlock(state, dispatch) {
      var ref = state.selection;
      var $cursor = ref.$cursor;
      if (!$cursor || $cursor.parent.content.size) { return false }
      if ($cursor.depth > 1 && $cursor.after() != $cursor.end(-1)) {
        var before = $cursor.before();
        if (canSplit(state.doc, before)) {
          if (dispatch) { dispatch(state.tr.split(before).scrollIntoView()); }
          return true
        }
      }
      var range = $cursor.blockRange(), target = range && liftTarget(range);
      if (target == null) { return false }
      if (dispatch) { dispatch(state.tr.lift(range, target).scrollIntoView()); }
      return true
    }

    // :: (EditorState, ?(tr: Transaction)) → bool
    // Split the parent block of the selection. If the selection is a text
    // selection, also delete its content.
    function splitBlock(state, dispatch) {
      var ref = state.selection;
      var $from = ref.$from;
      var $to = ref.$to;
      if (state.selection instanceof NodeSelection && state.selection.node.isBlock) {
        if (!$from.parentOffset || !canSplit(state.doc, $from.pos)) { return false }
        if (dispatch) { dispatch(state.tr.split($from.pos).scrollIntoView()); }
        return true
      }

      if (!$from.parent.isBlock) { return false }

      if (dispatch) {
        var atEnd = $to.parentOffset == $to.parent.content.size;
        var tr = state.tr;
        if (state.selection instanceof TextSelection || state.selection instanceof AllSelection) { tr.deleteSelection(); }
        var deflt = $from.depth == 0 ? null : defaultBlockAt($from.node(-1).contentMatchAt($from.indexAfter(-1)));
        var types = atEnd && deflt ? [{type: deflt}] : null;
        var can = canSplit(tr.doc, tr.mapping.map($from.pos), 1, types);
        if (!types && !can && canSplit(tr.doc, tr.mapping.map($from.pos), 1, deflt && [{type: deflt}])) {
          types = [{type: deflt}];
          can = true;
        }
        if (can) {
          tr.split(tr.mapping.map($from.pos), 1, types);
          if (!atEnd && !$from.parentOffset && $from.parent.type != deflt &&
              $from.node(-1).canReplace($from.index(-1), $from.indexAfter(-1), Fragment.from([deflt.create(), $from.parent])))
            { tr.setNodeMarkup(tr.mapping.map($from.before()), deflt); }
        }
        dispatch(tr.scrollIntoView());
      }
      return true
    }

    // :: (EditorState, ?(tr: Transaction)) → bool
    // Move the selection to the node wrapping the current selection, if
    // any. (Will not select the document node.)
    function selectParentNode(state, dispatch) {
      var ref = state.selection;
      var $from = ref.$from;
      var to = ref.to;
      var pos;
      var same = $from.sharedDepth(to);
      if (same == 0) { return false }
      pos = $from.before(same);
      if (dispatch) { dispatch(state.tr.setSelection(NodeSelection.create(state.doc, pos))); }
      return true
    }

    // :: (EditorState, ?(tr: Transaction)) → bool
    // Select the whole document.
    function selectAll(state, dispatch) {
      if (dispatch) { dispatch(state.tr.setSelection(new AllSelection(state.doc))); }
      return true
    }

    function joinMaybeClear(state, $pos, dispatch) {
      var before = $pos.nodeBefore, after = $pos.nodeAfter, index = $pos.index();
      if (!before || !after || !before.type.compatibleContent(after.type)) { return false }
      if (!before.content.size && $pos.parent.canReplace(index - 1, index)) {
        if (dispatch) { dispatch(state.tr.delete($pos.pos - before.nodeSize, $pos.pos).scrollIntoView()); }
        return true
      }
      if (!$pos.parent.canReplace(index, index + 1) || !(after.isTextblock || canJoin(state.doc, $pos.pos)))
        { return false }
      if (dispatch)
        { dispatch(state.tr
                 .clearIncompatible($pos.pos, before.type, before.contentMatchAt(before.childCount))
                 .join($pos.pos)
                 .scrollIntoView()); }
      return true
    }

    function deleteBarrier(state, $cut, dispatch) {
      var before = $cut.nodeBefore, after = $cut.nodeAfter, conn, match;
      if (before.type.spec.isolating || after.type.spec.isolating) { return false }
      if (joinMaybeClear(state, $cut, dispatch)) { return true }

      var canDelAfter = $cut.parent.canReplace($cut.index(), $cut.index() + 1);
      if (canDelAfter &&
          (conn = (match = before.contentMatchAt(before.childCount)).findWrapping(after.type)) &&
          match.matchType(conn[0] || after.type).validEnd) {
        if (dispatch) {
          var end = $cut.pos + after.nodeSize, wrap = Fragment.empty;
          for (var i = conn.length - 1; i >= 0; i--)
            { wrap = Fragment.from(conn[i].create(null, wrap)); }
          wrap = Fragment.from(before.copy(wrap));
          var tr = state.tr.step(new ReplaceAroundStep($cut.pos - 1, end, $cut.pos, end, new Slice(wrap, 1, 0), conn.length, true));
          var joinAt = end + 2 * conn.length;
          if (canJoin(tr.doc, joinAt)) { tr.join(joinAt); }
          dispatch(tr.scrollIntoView());
        }
        return true
      }

      var selAfter = Selection.findFrom($cut, 1);
      var range = selAfter && selAfter.$from.blockRange(selAfter.$to), target = range && liftTarget(range);
      if (target != null && target >= $cut.depth) {
        if (dispatch) { dispatch(state.tr.lift(range, target).scrollIntoView()); }
        return true
      }

      if (canDelAfter && after.isTextblock && textblockAt(before, "end")) {
        var at = before, wrap$1 = [];
        for (;;) {
          wrap$1.push(at);
          if (at.isTextblock) { break }
          at = at.lastChild;
        }
        if (at.canReplace(at.childCount, at.childCount, after.content)) {
          if (dispatch) {
            var end$1 = Fragment.empty;
            for (var i$1 = wrap$1.length - 1; i$1 >= 0; i$1--) { end$1 = Fragment.from(wrap$1[i$1].copy(end$1)); }
            var tr$1 = state.tr.step(new ReplaceAroundStep($cut.pos - wrap$1.length, $cut.pos + after.nodeSize,
                                                         $cut.pos + 1, $cut.pos + after.nodeSize - 1,
                                                         new Slice(end$1, wrap$1.length, 0), 0, true));
            dispatch(tr$1.scrollIntoView());
          }
          return true
        }
      }

      return false
    }

    // Parameterized commands

    // :: (NodeType, ?Object) → (state: EditorState, dispatch: ?(tr: Transaction)) → bool
    // Wrap the selection in a node of the given type with the given
    // attributes.
    function wrapIn(nodeType, attrs) {
      return function(state, dispatch) {
        var ref = state.selection;
        var $from = ref.$from;
        var $to = ref.$to;
        var range = $from.blockRange($to), wrapping = range && findWrapping(range, nodeType, attrs);
        if (!wrapping) { return false }
        if (dispatch) { dispatch(state.tr.wrap(range, wrapping).scrollIntoView()); }
        return true
      }
    }

    // :: (NodeType, ?Object) → (state: EditorState, dispatch: ?(tr: Transaction)) → bool
    // Returns a command that tries to set the selected textblocks to the
    // given node type with the given attributes.
    function setBlockType(nodeType, attrs) {
      return function(state, dispatch) {
        var ref = state.selection;
        var from = ref.from;
        var to = ref.to;
        var applicable = false;
        state.doc.nodesBetween(from, to, function (node, pos) {
          if (applicable) { return false }
          if (!node.isTextblock || node.hasMarkup(nodeType, attrs)) { return }
          if (node.type == nodeType) {
            applicable = true;
          } else {
            var $pos = state.doc.resolve(pos), index = $pos.index();
            applicable = $pos.parent.canReplaceWith(index, index + 1, nodeType);
          }
        });
        if (!applicable) { return false }
        if (dispatch) { dispatch(state.tr.setBlockType(from, to, nodeType, attrs).scrollIntoView()); }
        return true
      }
    }

    function markApplies(doc, ranges, type) {
      var loop = function ( i ) {
        var ref = ranges[i];
        var $from = ref.$from;
        var $to = ref.$to;
        var can = $from.depth == 0 ? doc.type.allowsMarkType(type) : false;
        doc.nodesBetween($from.pos, $to.pos, function (node) {
          if (can) { return false }
          can = node.inlineContent && node.type.allowsMarkType(type);
        });
        if (can) { return { v: true } }
      };

      for (var i = 0; i < ranges.length; i++) {
        var returned = loop( i );

        if ( returned ) return returned.v;
      }
      return false
    }

    // :: (MarkType, ?Object) → (state: EditorState, dispatch: ?(tr: Transaction)) → bool
    // Create a command function that toggles the given mark with the
    // given attributes. Will return `false` when the current selection
    // doesn't support that mark. This will remove the mark if any marks
    // of that type exist in the selection, or add it otherwise. If the
    // selection is empty, this applies to the [stored
    // marks](#state.EditorState.storedMarks) instead of a range of the
    // document.
    function toggleMark(markType, attrs) {
      return function(state, dispatch) {
        var ref = state.selection;
        var empty = ref.empty;
        var $cursor = ref.$cursor;
        var ranges = ref.ranges;
        if ((empty && !$cursor) || !markApplies(state.doc, ranges, markType)) { return false }
        if (dispatch) {
          if ($cursor) {
            if (markType.isInSet(state.storedMarks || $cursor.marks()))
              { dispatch(state.tr.removeStoredMark(markType)); }
            else
              { dispatch(state.tr.addStoredMark(markType.create(attrs))); }
          } else {
            var has = false, tr = state.tr;
            for (var i = 0; !has && i < ranges.length; i++) {
              var ref$1 = ranges[i];
              var $from = ref$1.$from;
              var $to = ref$1.$to;
              has = state.doc.rangeHasMark($from.pos, $to.pos, markType);
            }
            for (var i$1 = 0; i$1 < ranges.length; i$1++) {
              var ref$2 = ranges[i$1];
              var $from$1 = ref$2.$from;
              var $to$1 = ref$2.$to;
              if (has) {
                tr.removeMark($from$1.pos, $to$1.pos, markType);
              } else {
                var from = $from$1.pos, to = $to$1.pos, start = $from$1.nodeAfter, end = $to$1.nodeBefore;
                var spaceStart = start && start.isText ? /^\s*/.exec(start.text)[0].length : 0;
                var spaceEnd = end && end.isText ? /\s*$/.exec(end.text)[0].length : 0;
                if (from + spaceStart < to) { from += spaceStart; to -= spaceEnd; }
                tr.addMark(from, to, markType.create(attrs));
              }
            }
            dispatch(tr.scrollIntoView());
          }
        }
        return true
      }
    }

    // :: (...[(EditorState, ?(tr: Transaction), ?EditorView) → bool]) → (EditorState, ?(tr: Transaction), ?EditorView) → bool
    // Combine a number of command functions into a single function (which
    // calls them one by one until one returns true).
    function chainCommands() {
      var commands = [], len = arguments.length;
      while ( len-- ) commands[ len ] = arguments[ len ];

      return function(state, dispatch, view) {
        for (var i = 0; i < commands.length; i++)
          { if (commands[i](state, dispatch, view)) { return true } }
        return false
      }
    }

    var backspace = chainCommands(deleteSelection, joinBackward, selectNodeBackward);
    var del = chainCommands(deleteSelection, joinForward, selectNodeForward);

    // :: Object
    // A basic keymap containing bindings not specific to any schema.
    // Binds the following keys (when multiple commands are listed, they
    // are chained with [`chainCommands`](#commands.chainCommands)):
    //
    // * **Enter** to `newlineInCode`, `createParagraphNear`, `liftEmptyBlock`, `splitBlock`
    // * **Mod-Enter** to `exitCode`
    // * **Backspace** and **Mod-Backspace** to `deleteSelection`, `joinBackward`, `selectNodeBackward`
    // * **Delete** and **Mod-Delete** to `deleteSelection`, `joinForward`, `selectNodeForward`
    // * **Mod-Delete** to `deleteSelection`, `joinForward`, `selectNodeForward`
    // * **Mod-a** to `selectAll`
    var pcBaseKeymap = {
      "Enter": chainCommands(newlineInCode, createParagraphNear, liftEmptyBlock, splitBlock),
      "Mod-Enter": exitCode,
      "Backspace": backspace,
      "Mod-Backspace": backspace,
      "Delete": del,
      "Mod-Delete": del,
      "Mod-a": selectAll
    };

    // :: Object
    // A copy of `pcBaseKeymap` that also binds **Ctrl-h** like Backspace,
    // **Ctrl-d** like Delete, **Alt-Backspace** like Ctrl-Backspace, and
    // **Ctrl-Alt-Backspace**, **Alt-Delete**, and **Alt-d** like
    // Ctrl-Delete.
    var macBaseKeymap = {
      "Ctrl-h": pcBaseKeymap["Backspace"],
      "Alt-Backspace": pcBaseKeymap["Mod-Backspace"],
      "Ctrl-d": pcBaseKeymap["Delete"],
      "Ctrl-Alt-Backspace": pcBaseKeymap["Mod-Delete"],
      "Alt-Delete": pcBaseKeymap["Mod-Delete"],
      "Alt-d": pcBaseKeymap["Mod-Delete"]
    };
    for (var key in pcBaseKeymap) { macBaseKeymap[key] = pcBaseKeymap[key]; }

    // declare global: os, navigator
    var mac$2 = typeof navigator != "undefined" ? /Mac/.test(navigator.platform)
              : typeof os != "undefined" ? os.platform() == "darwin" : false;

    // :: Object
    // Depending on the detected platform, this will hold
    // [`pcBasekeymap`](#commands.pcBaseKeymap) or
    // [`macBaseKeymap`](#commands.macBaseKeymap).
    var baseKeymap = mac$2 ? macBaseKeymap : pcBaseKeymap;
    //# sourceMappingURL=index.es.js.map

    // :: (options: ?Object) → Plugin
    // Create a plugin that, when added to a ProseMirror instance,
    // causes a decoration to show up at the drop position when something
    // is dragged over the editor.
    //
    //   options::- These options are supported:
    //
    //     color:: ?string
    //     The color of the cursor. Defaults to `black`.
    //
    //     width:: ?number
    //     The precise width of the cursor in pixels. Defaults to 1.
    //
    //     class:: ?string
    //     A CSS class name to add to the cursor element.
    function dropCursor(options) {
      if ( options === void 0 ) options = {};

      return new Plugin({
        view: function view(editorView) { return new DropCursorView(editorView, options) }
      })
    }

    var DropCursorView = function DropCursorView(editorView, options) {
      var this$1 = this;

      this.editorView = editorView;
      this.width = options.width || 1;
      this.color = options.color || "black";
      this.class = options.class;
      this.cursorPos = null;
      this.element = null;
      this.timeout = null;

      this.handlers = ["dragover", "dragend", "drop", "dragleave"].map(function (name) {
        var handler = function (e) { return this$1[name](e); };
        editorView.dom.addEventListener(name, handler);
        return {name: name, handler: handler}
      });
    };

    DropCursorView.prototype.destroy = function destroy () {
        var this$1 = this;

      this.handlers.forEach(function (ref) {
          var name = ref.name;
          var handler = ref.handler;

          return this$1.editorView.dom.removeEventListener(name, handler);
        });
    };

    DropCursorView.prototype.update = function update (editorView, prevState) {
      if (this.cursorPos != null && prevState.doc != editorView.state.doc) { this.updateOverlay(); }
    };

    DropCursorView.prototype.setCursor = function setCursor (pos) {
      if (pos == this.cursorPos) { return }
      this.cursorPos = pos;
      if (pos == null) {
        this.element.parentNode.removeChild(this.element);
        this.element = null;
      } else {
        this.updateOverlay();
      }
    };

    DropCursorView.prototype.updateOverlay = function updateOverlay () {
      var $pos = this.editorView.state.doc.resolve(this.cursorPos), rect;
      if (!$pos.parent.inlineContent) {
        var before = $pos.nodeBefore, after = $pos.nodeAfter;
        if (before || after) {
          var nodeRect = this.editorView.nodeDOM(this.cursorPos - (before ?before.nodeSize : 0)).getBoundingClientRect();
          var top = before ? nodeRect.bottom : nodeRect.top;
          if (before && after)
            { top = (top + this.editorView.nodeDOM(this.cursorPos).getBoundingClientRect().top) / 2; }
          rect = {left: nodeRect.left, right: nodeRect.right, top: top - this.width / 2, bottom: top + this.width / 2};
        }
      }
      if (!rect) {
        var coords = this.editorView.coordsAtPos(this.cursorPos);
        rect = {left: coords.left - this.width / 2, right: coords.left + this.width / 2, top: coords.top, bottom: coords.bottom};
      }

      var parent = this.editorView.dom.offsetParent;
      if (!this.element) {
        this.element = parent.appendChild(document.createElement("div"));
        if (this.class) { this.element.className = this.class; }
        this.element.style.cssText = "position: absolute; z-index: 50; pointer-events: none; background-color: " + this.color;
      }
      var parentLeft, parentTop;
      if (!parent || parent == document.body && getComputedStyle(parent).position == "static") {
        parentLeft = -pageXOffset;
        parentTop = -pageYOffset;
      } else {
        var rect$1 = parent.getBoundingClientRect();
        parentLeft = rect$1.left - parent.scrollLeft;
        parentTop = rect$1.top - parent.scrollTop;
      }
      this.element.style.left = (rect.left - parentLeft) + "px";
      this.element.style.top = (rect.top - parentTop) + "px";
      this.element.style.width = (rect.right - rect.left) + "px";
      this.element.style.height = (rect.bottom - rect.top) + "px";
    };

    DropCursorView.prototype.scheduleRemoval = function scheduleRemoval (timeout) {
        var this$1 = this;

      clearTimeout(this.timeout);
      this.timeout = setTimeout(function () { return this$1.setCursor(null); }, timeout);
    };

    DropCursorView.prototype.dragover = function dragover (event) {
      if (!this.editorView.editable) { return }
      var pos = this.editorView.posAtCoords({left: event.clientX, top: event.clientY});
      if (pos) {
        var target = pos.pos;
        if (this.editorView.dragging && this.editorView.dragging.slice) {
          target = dropPoint(this.editorView.state.doc, target, this.editorView.dragging.slice);
          if (target == null) { target = pos.pos; }
        }
        this.setCursor(target);
        this.scheduleRemoval(5000);
      }
    };

    DropCursorView.prototype.dragend = function dragend () {
      this.scheduleRemoval(20);
    };

    DropCursorView.prototype.drop = function drop () {
      this.scheduleRemoval(20);
    };

    DropCursorView.prototype.dragleave = function dragleave (event) {
      if (event.target == this.editorView.dom || !this.editorView.dom.contains(event.relatedTarget))
        { this.setCursor(null); }
    };
    //# sourceMappingURL=index.es.js.map

    // ::- Gap cursor selections are represented using this class. Its
    // `$anchor` and `$head` properties both point at the cursor position.
    var GapCursor = /*@__PURE__*/(function (Selection) {
      function GapCursor($pos) {
        Selection.call(this, $pos, $pos);
      }

      if ( Selection ) GapCursor.__proto__ = Selection;
      GapCursor.prototype = Object.create( Selection && Selection.prototype );
      GapCursor.prototype.constructor = GapCursor;

      GapCursor.prototype.map = function map (doc, mapping) {
        var $pos = doc.resolve(mapping.map(this.head));
        return GapCursor.valid($pos) ? new GapCursor($pos) : Selection.near($pos)
      };

      GapCursor.prototype.content = function content () { return Slice.empty };

      GapCursor.prototype.eq = function eq (other) {
        return other instanceof GapCursor && other.head == this.head
      };

      GapCursor.prototype.toJSON = function toJSON () {
        return {type: "gapcursor", pos: this.head}
      };

      GapCursor.fromJSON = function fromJSON (doc, json) {
        if (typeof json.pos != "number") { throw new RangeError("Invalid input for GapCursor.fromJSON") }
        return new GapCursor(doc.resolve(json.pos))
      };

      GapCursor.prototype.getBookmark = function getBookmark () { return new GapBookmark(this.anchor) };

      GapCursor.valid = function valid ($pos) {
        var parent = $pos.parent;
        if (parent.isTextblock || !closedBefore($pos) || !closedAfter($pos)) { return false }
        var override = parent.type.spec.allowGapCursor;
        if (override != null) { return override }
        var deflt = parent.contentMatchAt($pos.index()).defaultType;
        return deflt && deflt.isTextblock
      };

      GapCursor.findFrom = function findFrom ($pos, dir, mustMove) {
        search: for (;;) {
          if (!mustMove && GapCursor.valid($pos)) { return $pos }
          var pos = $pos.pos, next = null;
          // Scan up from this position
          for (var d = $pos.depth;; d--) {
            var parent = $pos.node(d);
            if (dir > 0 ? $pos.indexAfter(d) < parent.childCount : $pos.index(d) > 0) {
              next = parent.child(dir > 0 ? $pos.indexAfter(d) : $pos.index(d) - 1);
              break
            } else if (d == 0) {
              return null
            }
            pos += dir;
            var $cur = $pos.doc.resolve(pos);
            if (GapCursor.valid($cur)) { return $cur }
          }

          // And then down into the next node
          for (;;) {
            var inside = dir > 0 ? next.firstChild : next.lastChild;
            if (!inside) {
              if (next.isAtom && !next.isText && !NodeSelection.isSelectable(next)) {
                $pos = $pos.doc.resolve(pos + next.nodeSize * dir);
                mustMove = false;
                continue search
              }
              break
            }
            next = inside;
            pos += dir;
            var $cur$1 = $pos.doc.resolve(pos);
            if (GapCursor.valid($cur$1)) { return $cur$1 }
          }

          return null
        }
      };

      return GapCursor;
    }(Selection));

    GapCursor.prototype.visible = false;

    Selection.jsonID("gapcursor", GapCursor);

    var GapBookmark = function GapBookmark(pos) {
      this.pos = pos;
    };
    GapBookmark.prototype.map = function map (mapping) {
      return new GapBookmark(mapping.map(this.pos))
    };
    GapBookmark.prototype.resolve = function resolve (doc) {
      var $pos = doc.resolve(this.pos);
      return GapCursor.valid($pos) ? new GapCursor($pos) : Selection.near($pos)
    };

    function closedBefore($pos) {
      for (var d = $pos.depth; d >= 0; d--) {
        var index = $pos.index(d);
        // At the start of this parent, look at next one
        if (index == 0) { continue }
        // See if the node before (or its first ancestor) is closed
        for (var before = $pos.node(d).child(index - 1);; before = before.lastChild) {
          if ((before.childCount == 0 && !before.inlineContent) || before.isAtom || before.type.spec.isolating) { return true }
          if (before.inlineContent) { return false }
        }
      }
      // Hit start of document
      return true
    }

    function closedAfter($pos) {
      for (var d = $pos.depth; d >= 0; d--) {
        var index = $pos.indexAfter(d), parent = $pos.node(d);
        if (index == parent.childCount) { continue }
        for (var after = parent.child(index);; after = after.firstChild) {
          if ((after.childCount == 0 && !after.inlineContent) || after.isAtom || after.type.spec.isolating) { return true }
          if (after.inlineContent) { return false }
        }
      }
      return true
    }

    // :: () → Plugin
    // Create a gap cursor plugin. When enabled, this will capture clicks
    // near and arrow-key-motion past places that don't have a normally
    // selectable position nearby, and create a gap cursor selection for
    // them. The cursor is drawn as an element with class
    // `ProseMirror-gapcursor`. You can either include
    // `style/gapcursor.css` from the package's directory or add your own
    // styles to make it visible.
    var gapCursor = function() {
      return new Plugin({
        props: {
          decorations: drawGapCursor,

          createSelectionBetween: function createSelectionBetween(_view, $anchor, $head) {
            if ($anchor.pos == $head.pos && GapCursor.valid($head)) { return new GapCursor($head) }
          },

          handleClick: handleClick,
          handleKeyDown: handleKeyDown
        }
      })
    };

    var handleKeyDown = keydownHandler({
      "ArrowLeft": arrow("horiz", -1),
      "ArrowRight": arrow("horiz", 1),
      "ArrowUp": arrow("vert", -1),
      "ArrowDown": arrow("vert", 1)
    });

    function arrow(axis, dir) {
      var dirStr = axis == "vert" ? (dir > 0 ? "down" : "up") : (dir > 0 ? "right" : "left");
      return function(state, dispatch, view) {
        var sel = state.selection;
        var $start = dir > 0 ? sel.$to : sel.$from, mustMove = sel.empty;
        if (sel instanceof TextSelection) {
          if (!view.endOfTextblock(dirStr) || $start.depth == 0) { return false }
          mustMove = false;
          $start = state.doc.resolve(dir > 0 ? $start.after() : $start.before());
        }
        var $found = GapCursor.findFrom($start, dir, mustMove);
        if (!$found) { return false }
        if (dispatch) { dispatch(state.tr.setSelection(new GapCursor($found))); }
        return true
      }
    }

    function handleClick(view, pos, event) {
      if (!view.editable) { return false }
      var $pos = view.state.doc.resolve(pos);
      if (!GapCursor.valid($pos)) { return false }
      var ref = view.posAtCoords({left: event.clientX, top: event.clientY});
      var inside = ref.inside;
      if (inside > -1 && NodeSelection.isSelectable(view.state.doc.nodeAt(inside))) { return false }
      view.dispatch(view.state.tr.setSelection(new GapCursor($pos)));
      return true
    }

    function drawGapCursor(state) {
      if (!(state.selection instanceof GapCursor)) { return null }
      var node = document.createElement("div");
      node.className = "ProseMirror-gapcursor";
      return DecorationSet.create(state.doc, [Decoration.widget(state.selection.head, node, {key: "gapcursor"})])
    }
    //# sourceMappingURL=index.es.js.map

    function crelt() {
      var elt = arguments[0];
      if (typeof elt == "string") elt = document.createElement(elt);
      var i = 1, next = arguments[1];
      if (next && typeof next == "object" && next.nodeType == null && !Array.isArray(next)) {
        for (var name in next) if (Object.prototype.hasOwnProperty.call(next, name)) {
          var value = next[name];
          if (typeof value == "string") elt.setAttribute(name, value);
          else if (value != null) elt[name] = value;
        }
        i++;
      }
      for (; i < arguments.length; i++) add$1(elt, arguments[i]);
      return elt
    }

    function add$1(elt, child) {
      if (typeof child == "string") {
        elt.appendChild(document.createTextNode(child));
      } else if (child == null) ; else if (child.nodeType != null) {
        elt.appendChild(child);
      } else if (Array.isArray(child)) {
        for (var i = 0; i < child.length; i++) add$1(elt, child[i]);
      } else {
        throw new RangeError("Unsupported child node: " + child)
      }
    }

    var SVG = "http://www.w3.org/2000/svg";
    var XLINK = "http://www.w3.org/1999/xlink";

    var prefix = "ProseMirror-icon";

    function hashPath(path) {
      var hash = 0;
      for (var i = 0; i < path.length; i++)
        { hash = (((hash << 5) - hash) + path.charCodeAt(i)) | 0; }
      return hash
    }

    function getIcon(icon) {
      var node = document.createElement("div");
      node.className = prefix;
      if (icon.path) {
        var name = "pm-icon-" + hashPath(icon.path).toString(16);
        if (!document.getElementById(name)) { buildSVG(name, icon); }
        var svg = node.appendChild(document.createElementNS(SVG, "svg"));
        svg.style.width = (icon.width / icon.height) + "em";
        var use = svg.appendChild(document.createElementNS(SVG, "use"));
        use.setAttributeNS(XLINK, "href", /([^#]*)/.exec(document.location)[1] + "#" + name);
      } else if (icon.dom) {
        node.appendChild(icon.dom.cloneNode(true));
      } else {
        node.appendChild(document.createElement("span")).textContent = icon.text || '';
        if (icon.css) { node.firstChild.style.cssText = icon.css; }
      }
      return node
    }

    function buildSVG(name, data) {
      var collection = document.getElementById(prefix + "-collection");
      if (!collection) {
        collection = document.createElementNS(SVG, "svg");
        collection.id = prefix + "-collection";
        collection.style.display = "none";
        document.body.insertBefore(collection, document.body.firstChild);
      }
      var sym = document.createElementNS(SVG, "symbol");
      sym.id = name;
      sym.setAttribute("viewBox", "0 0 " + data.width + " " + data.height);
      var path = sym.appendChild(document.createElementNS(SVG, "path"));
      path.setAttribute("d", data.path);
      collection.appendChild(sym);
    }

    var prefix$1 = "ProseMirror-menu";

    // ::- An icon or label that, when clicked, executes a command.
    var MenuItem = function MenuItem(spec) {
      // :: MenuItemSpec
      // The spec used to create the menu item.
      this.spec = spec;
    };

    // :: (EditorView) → {dom: dom.Node, update: (EditorState) → bool}
    // Renders the icon according to its [display
    // spec](#menu.MenuItemSpec.display), and adds an event handler which
    // executes the command when the representation is clicked.
    MenuItem.prototype.render = function render (view) {
      var spec = this.spec;
      var dom = spec.render ? spec.render(view)
          : spec.icon ? getIcon(spec.icon)
          : spec.label ? crelt("div", null, translate(view, spec.label))
          : null;
      if (!dom) { throw new RangeError("MenuItem without icon or label property") }
      if (spec.title) {
        var title = (typeof spec.title === "function" ? spec.title(view.state) : spec.title);
        dom.setAttribute("title", translate(view, title));
      }
      if (spec.class) { dom.classList.add(spec.class); }
      if (spec.css) { dom.style.cssText += spec.css; }

      dom.addEventListener("mousedown", function (e) {
        e.preventDefault();
        if (!dom.classList.contains(prefix$1 + "-disabled"))
          { spec.run(view.state, view.dispatch, view, e); }
      });

      function update(state) {
        if (spec.select) {
          var selected = spec.select(state);
          dom.style.display = selected ? "" : "none";
          if (!selected) { return false }
        }
        var enabled = true;
        if (spec.enable) {
          enabled = spec.enable(state) || false;
          setClass(dom, prefix$1 + "-disabled", !enabled);
        }
        if (spec.active) {
          var active = enabled && spec.active(state) || false;
          setClass(dom, prefix$1 + "-active", active);
        }
        return true
      }

      return {dom: dom, update: update}
    };

    function translate(view, text) {
      return view._props.translate ? view._props.translate(text) : text
    }

    // MenuItemSpec:: interface
    // The configuration object passed to the `MenuItem` constructor.
    //
    //   run:: (EditorState, (Transaction), EditorView, dom.Event)
    //   The function to execute when the menu item is activated.
    //
    //   select:: ?(EditorState) → bool
    //   Optional function that is used to determine whether the item is
    //   appropriate at the moment. Deselected items will be hidden.
    //
    //   enable:: ?(EditorState) → bool
    //   Function that is used to determine if the item is enabled. If
    //   given and returning false, the item will be given a disabled
    //   styling.
    //
    //   active:: ?(EditorState) → bool
    //   A predicate function to determine whether the item is 'active' (for
    //   example, the item for toggling the strong mark might be active then
    //   the cursor is in strong text).
    //
    //   render:: ?(EditorView) → dom.Node
    //   A function that renders the item. You must provide either this,
    //   [`icon`](#menu.MenuItemSpec.icon), or [`label`](#MenuItemSpec.label).
    //
    //   icon:: ?Object
    //   Describes an icon to show for this item. The object may specify
    //   an SVG icon, in which case its `path` property should be an [SVG
    //   path
    //   spec](https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/d),
    //   and `width` and `height` should provide the viewbox in which that
    //   path exists. Alternatively, it may have a `text` property
    //   specifying a string of text that makes up the icon, with an
    //   optional `css` property giving additional CSS styling for the
    //   text. _Or_ it may contain `dom` property containing a DOM node.
    //
    //   label:: ?string
    //   Makes the item show up as a text label. Mostly useful for items
    //   wrapped in a [drop-down](#menu.Dropdown) or similar menu. The object
    //   should have a `label` property providing the text to display.
    //
    //   title:: ?union<string, (EditorState) → string>
    //   Defines DOM title (mouseover) text for the item.
    //
    //   class:: ?string
    //   Optionally adds a CSS class to the item's DOM representation.
    //
    //   css:: ?string
    //   Optionally adds a string of inline CSS to the item's DOM
    //   representation.

    var lastMenuEvent = {time: 0, node: null};
    function markMenuEvent(e) {
      lastMenuEvent.time = Date.now();
      lastMenuEvent.node = e.target;
    }
    function isMenuEvent(wrapper) {
      return Date.now() - 100 < lastMenuEvent.time &&
        lastMenuEvent.node && wrapper.contains(lastMenuEvent.node)
    }

    // ::- A drop-down menu, displayed as a label with a downwards-pointing
    // triangle to the right of it.
    var Dropdown = function Dropdown(content, options) {
      this.options = options || {};
      this.content = Array.isArray(content) ? content : [content];
    };

    // :: (EditorView) → {dom: dom.Node, update: (EditorState)}
    // Render the dropdown menu and sub-items.
    Dropdown.prototype.render = function render (view) {
        var this$1 = this;

      var content = renderDropdownItems(this.content, view);

      var label = crelt("div", {class: prefix$1 + "-dropdown " + (this.options.class || ""),
                               style: this.options.css},
                       translate(view, this.options.label));
      if (this.options.title) { label.setAttribute("title", translate(view, this.options.title)); }
      var wrap = crelt("div", {class: prefix$1 + "-dropdown-wrap"}, label);
      var open = null, listeningOnClose = null;
      var close = function () {
        if (open && open.close()) {
          open = null;
          window.removeEventListener("mousedown", listeningOnClose);
        }
      };
      label.addEventListener("mousedown", function (e) {
        e.preventDefault();
        markMenuEvent(e);
        if (open) {
          close();
        } else {
          open = this$1.expand(wrap, content.dom);
          window.addEventListener("mousedown", listeningOnClose = function () {
            if (!isMenuEvent(wrap)) { close(); }
          });
        }
      });

      function update(state) {
        var inner = content.update(state);
        wrap.style.display = inner ? "" : "none";
        return inner
      }

      return {dom: wrap, update: update}
    };

    Dropdown.prototype.expand = function expand (dom, items) {
      var menuDOM = crelt("div", {class: prefix$1 + "-dropdown-menu " + (this.options.class || "")}, items);

      var done = false;
      function close() {
        if (done) { return }
        done = true;
        dom.removeChild(menuDOM);
        return true
      }
      dom.appendChild(menuDOM);
      return {close: close, node: menuDOM}
    };

    function renderDropdownItems(items, view) {
      var rendered = [], updates = [];
      for (var i = 0; i < items.length; i++) {
        var ref = items[i].render(view);
        var dom = ref.dom;
        var update = ref.update;
        rendered.push(crelt("div", {class: prefix$1 + "-dropdown-item"}, dom));
        updates.push(update);
      }
      return {dom: rendered, update: combineUpdates(updates, rendered)}
    }

    function combineUpdates(updates, nodes) {
      return function (state) {
        var something = false;
        for (var i = 0; i < updates.length; i++) {
          var up = updates[i](state);
          nodes[i].style.display = up ? "" : "none";
          if (up) { something = true; }
        }
        return something
      }
    }

    // ::- Represents a submenu wrapping a group of elements that start
    // hidden and expand to the right when hovered over or tapped.
    var DropdownSubmenu = function DropdownSubmenu(content, options) {
      this.options = options || {};
      this.content = Array.isArray(content) ? content : [content];
    };

    // :: (EditorView) → {dom: dom.Node, update: (EditorState) → bool}
    // Renders the submenu.
    DropdownSubmenu.prototype.render = function render (view) {
      var items = renderDropdownItems(this.content, view);

      var label = crelt("div", {class: prefix$1 + "-submenu-label"}, translate(view, this.options.label));
      var wrap = crelt("div", {class: prefix$1 + "-submenu-wrap"}, label,
                     crelt("div", {class: prefix$1 + "-submenu"}, items.dom));
      var listeningOnClose = null;
      label.addEventListener("mousedown", function (e) {
        e.preventDefault();
        markMenuEvent(e);
        setClass(wrap, prefix$1 + "-submenu-wrap-active");
        if (!listeningOnClose)
          { window.addEventListener("mousedown", listeningOnClose = function () {
            if (!isMenuEvent(wrap)) {
              wrap.classList.remove(prefix$1 + "-submenu-wrap-active");
              window.removeEventListener("mousedown", listeningOnClose);
              listeningOnClose = null;
            }
          }); }
      });

      function update(state) {
        var inner = items.update(state);
        wrap.style.display = inner ? "" : "none";
        return inner
      }
      return {dom: wrap, update: update}
    };

    // :: (EditorView, [union<MenuElement, [MenuElement]>]) → {dom: ?dom.DocumentFragment, update: (EditorState) → bool}
    // Render the given, possibly nested, array of menu elements into a
    // document fragment, placing separators between them (and ensuring no
    // superfluous separators appear when some of the groups turn out to
    // be empty).
    function renderGrouped(view, content) {
      var result = document.createDocumentFragment();
      var updates = [], separators = [];
      for (var i = 0; i < content.length; i++) {
        var items = content[i], localUpdates = [], localNodes = [];
        for (var j = 0; j < items.length; j++) {
          var ref = items[j].render(view);
          var dom = ref.dom;
          var update$1 = ref.update;
          var span = crelt("span", {class: prefix$1 + "item"}, dom);
          result.appendChild(span);
          localNodes.push(span);
          localUpdates.push(update$1);
        }
        if (localUpdates.length) {
          updates.push(combineUpdates(localUpdates, localNodes));
          if (i < content.length - 1)
            { separators.push(result.appendChild(separator())); }
        }
      }

      function update(state) {
        var something = false, needSep = false;
        for (var i = 0; i < updates.length; i++) {
          var hasContent = updates[i](state);
          if (i) { separators[i - 1].style.display = needSep && hasContent ? "" : "none"; }
          needSep = hasContent;
          if (hasContent) { something = true; }
        }
        return something
      }
      return {dom: result, update: update}
    }

    function separator() {
      return crelt("span", {class: prefix$1 + "separator"})
    }

    // :: Object
    // A set of basic editor-related icons. Contains the properties
    // `join`, `lift`, `selectParentNode`, `undo`, `redo`, `strong`, `em`,
    // `code`, `link`, `bulletList`, `orderedList`, and `blockquote`, each
    // holding an object that can be used as the `icon` option to
    // `MenuItem`.
    var icons = {
      join: {
        width: 800, height: 900,
        path: "M0 75h800v125h-800z M0 825h800v-125h-800z M250 400h100v-100h100v100h100v100h-100v100h-100v-100h-100z"
      },
      lift: {
        width: 1024, height: 1024,
        path: "M219 310v329q0 7-5 12t-12 5q-8 0-13-5l-164-164q-5-5-5-13t5-13l164-164q5-5 13-5 7 0 12 5t5 12zM1024 749v109q0 7-5 12t-12 5h-987q-7 0-12-5t-5-12v-109q0-7 5-12t12-5h987q7 0 12 5t5 12zM1024 530v109q0 7-5 12t-12 5h-621q-7 0-12-5t-5-12v-109q0-7 5-12t12-5h621q7 0 12 5t5 12zM1024 310v109q0 7-5 12t-12 5h-621q-7 0-12-5t-5-12v-109q0-7 5-12t12-5h621q7 0 12 5t5 12zM1024 91v109q0 7-5 12t-12 5h-987q-7 0-12-5t-5-12v-109q0-7 5-12t12-5h987q7 0 12 5t5 12z"
      },
      selectParentNode: {text: "\u2b1a", css: "font-weight: bold"},
      undo: {
        width: 1024, height: 1024,
        path: "M761 1024c113-206 132-520-313-509v253l-384-384 384-384v248c534-13 594 472 313 775z"
      },
      redo: {
        width: 1024, height: 1024,
        path: "M576 248v-248l384 384-384 384v-253c-446-10-427 303-313 509-280-303-221-789 313-775z"
      },
      strong: {
        width: 805, height: 1024,
        path: "M317 869q42 18 80 18 214 0 214-191 0-65-23-102-15-25-35-42t-38-26-46-14-48-6-54-1q-41 0-57 5 0 30-0 90t-0 90q0 4-0 38t-0 55 2 47 6 38zM309 442q24 4 62 4 46 0 81-7t62-25 42-51 14-81q0-40-16-70t-45-46-61-24-70-8q-28 0-74 7 0 28 2 86t2 86q0 15-0 45t-0 45q0 26 0 39zM0 950l1-53q8-2 48-9t60-15q4-6 7-15t4-19 3-18 1-21 0-19v-37q0-561-12-585-2-4-12-8t-25-6-28-4-27-2-17-1l-2-47q56-1 194-6t213-5q13 0 39 0t38 0q40 0 78 7t73 24 61 40 42 59 16 78q0 29-9 54t-22 41-36 32-41 25-48 22q88 20 146 76t58 141q0 57-20 102t-53 74-78 48-93 27-100 8q-25 0-75-1t-75-1q-60 0-175 6t-132 6z"
      },
      em: {
        width: 585, height: 1024,
        path: "M0 949l9-48q3-1 46-12t63-21q16-20 23-57 0-4 35-165t65-310 29-169v-14q-13-7-31-10t-39-4-33-3l10-58q18 1 68 3t85 4 68 1q27 0 56-1t69-4 56-3q-2 22-10 50-17 5-58 16t-62 19q-4 10-8 24t-5 22-4 26-3 24q-15 84-50 239t-44 203q-1 5-7 33t-11 51-9 47-3 32l0 10q9 2 105 17-1 25-9 56-6 0-18 0t-18 0q-16 0-49-5t-49-5q-78-1-117-1-29 0-81 5t-69 6z"
      },
      code: {
        width: 896, height: 1024,
        path: "M608 192l-96 96 224 224-224 224 96 96 288-320-288-320zM288 192l-288 320 288 320 96-96-224-224 224-224-96-96z"
      },
      link: {
        width: 951, height: 1024,
        path: "M832 694q0-22-16-38l-118-118q-16-16-38-16-24 0-41 18 1 1 10 10t12 12 8 10 7 14 2 15q0 22-16 38t-38 16q-8 0-15-2t-14-7-10-8-12-12-10-10q-18 17-18 41 0 22 16 38l117 118q15 15 38 15 22 0 38-14l84-83q16-16 16-38zM430 292q0-22-16-38l-117-118q-16-16-38-16-22 0-38 15l-84 83q-16 16-16 38 0 22 16 38l118 118q15 15 38 15 24 0 41-17-1-1-10-10t-12-12-8-10-7-14-2-15q0-22 16-38t38-16q8 0 15 2t14 7 10 8 12 12 10 10q18-17 18-41zM941 694q0 68-48 116l-84 83q-47 47-116 47-69 0-116-48l-117-118q-47-47-47-116 0-70 50-119l-50-50q-49 50-118 50-68 0-116-48l-118-118q-48-48-48-116t48-116l84-83q47-47 116-47 69 0 116 48l117 118q47 47 47 116 0 70-50 119l50 50q49-50 118-50 68 0 116 48l118 118q48 48 48 116z"
      },
      bulletList: {
        width: 768, height: 896,
        path: "M0 512h128v-128h-128v128zM0 256h128v-128h-128v128zM0 768h128v-128h-128v128zM256 512h512v-128h-512v128zM256 256h512v-128h-512v128zM256 768h512v-128h-512v128z"
      },
      orderedList: {
        width: 768, height: 896,
        path: "M320 512h448v-128h-448v128zM320 768h448v-128h-448v128zM320 128v128h448v-128h-448zM79 384h78v-256h-36l-85 23v50l43-2v185zM189 590c0-36-12-78-96-78-33 0-64 6-83 16l1 66c21-10 42-15 67-15s32 11 32 28c0 26-30 58-110 112v50h192v-67l-91 2c49-30 87-66 87-113l1-1z"
      },
      blockquote: {
        width: 640, height: 896,
        path: "M0 448v256h256v-256h-128c0 0 0-128 128-128v-128c0 0-256 0-256 256zM640 320v-128c0 0-256 0-256 256v256h256v-256h-128c0 0 0-128 128-128z"
      }
    };

    // :: MenuItem
    // Menu item for the `joinUp` command.
    var joinUpItem = new MenuItem({
      title: "Join with above block",
      run: joinUp,
      select: function (state) { return joinUp(state); },
      icon: icons.join
    });

    // :: MenuItem
    // Menu item for the `lift` command.
    var liftItem = new MenuItem({
      title: "Lift out of enclosing block",
      run: lift,
      select: function (state) { return lift(state); },
      icon: icons.lift
    });

    // :: MenuItem
    // Menu item for the `selectParentNode` command.
    var selectParentNodeItem = new MenuItem({
      title: "Select parent node",
      run: selectParentNode,
      select: function (state) { return selectParentNode(state); },
      icon: icons.selectParentNode
    });

    // :: MenuItem
    // Menu item for the `undo` command.
    var undoItem = new MenuItem({
      title: "Undo last change",
      run: undo,
      enable: function (state) { return undo(state); },
      icon: icons.undo
    });

    // :: MenuItem
    // Menu item for the `redo` command.
    var redoItem = new MenuItem({
      title: "Redo last undone change",
      run: redo,
      enable: function (state) { return redo(state); },
      icon: icons.redo
    });

    // :: (NodeType, Object) → MenuItem
    // Build a menu item for wrapping the selection in a given node type.
    // Adds `run` and `select` properties to the ones present in
    // `options`. `options.attrs` may be an object or a function.
    function wrapItem(nodeType, options) {
      var passedOptions = {
        run: function run(state, dispatch) {
          // FIXME if (options.attrs instanceof Function) options.attrs(state, attrs => wrapIn(nodeType, attrs)(state))
          return wrapIn(nodeType, options.attrs)(state, dispatch)
        },
        select: function select(state) {
          return wrapIn(nodeType, options.attrs instanceof Function ? null : options.attrs)(state)
        }
      };
      for (var prop in options) { passedOptions[prop] = options[prop]; }
      return new MenuItem(passedOptions)
    }

    // :: (NodeType, Object) → MenuItem
    // Build a menu item for changing the type of the textblock around the
    // selection to the given type. Provides `run`, `active`, and `select`
    // properties. Others must be given in `options`. `options.attrs` may
    // be an object to provide the attributes for the textblock node.
    function blockTypeItem(nodeType, options) {
      var command = setBlockType(nodeType, options.attrs);
      var passedOptions = {
        run: command,
        enable: function enable(state) { return command(state) },
        active: function active(state) {
          var ref = state.selection;
          var $from = ref.$from;
          var to = ref.to;
          var node = ref.node;
          if (node) { return node.hasMarkup(nodeType, options.attrs) }
          return to <= $from.end() && $from.parent.hasMarkup(nodeType, options.attrs)
        }
      };
      for (var prop in options) { passedOptions[prop] = options[prop]; }
      return new MenuItem(passedOptions)
    }

    // Work around classList.toggle being broken in IE11
    function setClass(dom, cls, on) {
      if (on) { dom.classList.add(cls); }
      else { dom.classList.remove(cls); }
    }

    var prefix$2 = "ProseMirror-menubar";

    function isIOS() {
      if (typeof navigator == "undefined") { return false }
      var agent = navigator.userAgent;
      return !/Edge\/\d/.test(agent) && /AppleWebKit/.test(agent) && /Mobile\/\w+/.test(agent)
    }

    // :: (Object) → Plugin
    // A plugin that will place a menu bar above the editor. Note that
    // this involves wrapping the editor in an additional `<div>`.
    //
    //   options::-
    //   Supports the following options:
    //
    //     content:: [[MenuElement]]
    //     Provides the content of the menu, as a nested array to be
    //     passed to `renderGrouped`.
    //
    //     floating:: ?bool
    //     Determines whether the menu floats, i.e. whether it sticks to
    //     the top of the viewport when the editor is partially scrolled
    //     out of view.
    function menuBar(options) {
      return new Plugin({
        view: function view(editorView) { return new MenuBarView(editorView, options) }
      })
    }

    var MenuBarView = function MenuBarView(editorView, options) {
      var this$1 = this;

      this.editorView = editorView;
      this.options = options;

      this.wrapper = crelt("div", {class: prefix$2 + "-wrapper"});
      this.menu = this.wrapper.appendChild(crelt("div", {class: prefix$2}));
      this.menu.className = prefix$2;
      this.spacer = null;

      editorView.dom.parentNode.replaceChild(this.wrapper, editorView.dom);
      this.wrapper.appendChild(editorView.dom);

      this.maxHeight = 0;
      this.widthForMaxHeight = 0;
      this.floating = false;

      var ref = renderGrouped(this.editorView, this.options.content);
      var dom = ref.dom;
      var update = ref.update;
      this.contentUpdate = update;
      this.menu.appendChild(dom);
      this.update();

      if (options.floating && !isIOS()) {
        this.updateFloat();
        var potentialScrollers = getAllWrapping(this.wrapper);
        this.scrollFunc = function (e) {
          var root = this$1.editorView.root;
          if (!(root.body || root).contains(this$1.wrapper)) {
              potentialScrollers.forEach(function (el) { return el.removeEventListener("scroll", this$1.scrollFunc); });
          } else {
              this$1.updateFloat(e.target.getBoundingClientRect && e.target);
          }
        };
        potentialScrollers.forEach(function (el) { return el.addEventListener('scroll', this$1.scrollFunc); });
      }
    };

    MenuBarView.prototype.update = function update () {
      this.contentUpdate(this.editorView.state);

      if (this.floating) {
        this.updateScrollCursor();
      } else {
        if (this.menu.offsetWidth != this.widthForMaxHeight) {
          this.widthForMaxHeight = this.menu.offsetWidth;
          this.maxHeight = 0;
        }
        if (this.menu.offsetHeight > this.maxHeight) {
          this.maxHeight = this.menu.offsetHeight;
          this.menu.style.minHeight = this.maxHeight + "px";
        }
      }
    };

    MenuBarView.prototype.updateScrollCursor = function updateScrollCursor () {
      var selection = this.editorView.root.getSelection();
      if (!selection.focusNode) { return }
      var rects = selection.getRangeAt(0).getClientRects();
      var selRect = rects[selectionIsInverted(selection) ? 0 : rects.length - 1];
      if (!selRect) { return }
      var menuRect = this.menu.getBoundingClientRect();
      if (selRect.top < menuRect.bottom && selRect.bottom > menuRect.top) {
        var scrollable = findWrappingScrollable(this.wrapper);
        if (scrollable) { scrollable.scrollTop -= (menuRect.bottom - selRect.top); }
      }
    };

    MenuBarView.prototype.updateFloat = function updateFloat (scrollAncestor) {
      var parent = this.wrapper, editorRect = parent.getBoundingClientRect(),
          top = scrollAncestor ? Math.max(0, scrollAncestor.getBoundingClientRect().top) : 0;

      if (this.floating) {
        if (editorRect.top >= top || editorRect.bottom < this.menu.offsetHeight + 10) {
          this.floating = false;
          this.menu.style.position = this.menu.style.left = this.menu.style.top = this.menu.style.width = "";
          this.menu.style.display = "";
          this.spacer.parentNode.removeChild(this.spacer);
          this.spacer = null;
        } else {
          var border = (parent.offsetWidth - parent.clientWidth) / 2;
          this.menu.style.left = (editorRect.left + border) + "px";
          this.menu.style.display = (editorRect.top > window.innerHeight ? "none" : "");
          if (scrollAncestor) { this.menu.style.top = top + "px"; }
        }
      } else {
        if (editorRect.top < top && editorRect.bottom >= this.menu.offsetHeight + 10) {
          this.floating = true;
          var menuRect = this.menu.getBoundingClientRect();
          this.menu.style.left = menuRect.left + "px";
          this.menu.style.width = menuRect.width + "px";
          if (scrollAncestor) { this.menu.style.top = top + "px"; }
          this.menu.style.position = "fixed";
          this.spacer = crelt("div", {class: prefix$2 + "-spacer", style: ("height: " + (menuRect.height) + "px")});
          parent.insertBefore(this.spacer, this.menu);
        }
      }
    };

    MenuBarView.prototype.destroy = function destroy () {
      if (this.wrapper.parentNode)
        { this.wrapper.parentNode.replaceChild(this.editorView.dom, this.wrapper); }
    };

    // Not precise, but close enough
    function selectionIsInverted(selection) {
      if (selection.anchorNode == selection.focusNode) { return selection.anchorOffset > selection.focusOffset }
      return selection.anchorNode.compareDocumentPosition(selection.focusNode) == Node.DOCUMENT_POSITION_FOLLOWING
    }

    function findWrappingScrollable(node) {
      for (var cur = node.parentNode; cur; cur = cur.parentNode)
        { if (cur.scrollHeight > cur.clientHeight) { return cur } }
    }

    function getAllWrapping(node) {
        var res = [window];
        for (var cur = node.parentNode; cur; cur = cur.parentNode)
            { res.push(cur); }
        return res
    }
    //# sourceMappingURL=index.es.js.map

    // ::- Input rules are regular expressions describing a piece of text
    // that, when typed, causes something to happen. This might be
    // changing two dashes into an emdash, wrapping a paragraph starting
    // with `"> "` into a blockquote, or something entirely different.
    var InputRule = function InputRule(match, handler) {
      this.match = match;
      this.handler = typeof handler == "string" ? stringHandler(handler) : handler;
    };

    function stringHandler(string) {
      return function(state, match, start, end) {
        var insert = string;
        if (match[1]) {
          var offset = match[0].lastIndexOf(match[1]);
          insert += match[0].slice(offset + match[1].length);
          start += offset;
          var cutOff = start - end;
          if (cutOff > 0) {
            insert = match[0].slice(offset - cutOff, offset) + insert;
            start = end;
          }
        }
        return state.tr.insertText(insert, start, end)
      }
    }

    var MAX_MATCH = 500;

    // :: (config: {rules: [InputRule]}) → Plugin
    // Create an input rules plugin. When enabled, it will cause text
    // input that matches any of the given rules to trigger the rule's
    // action.
    function inputRules(ref) {
      var rules = ref.rules;

      var plugin = new Plugin({
        state: {
          init: function init() { return null },
          apply: function apply(tr, prev) {
            var stored = tr.getMeta(this);
            if (stored) { return stored }
            return tr.selectionSet || tr.docChanged ? null : prev
          }
        },

        props: {
          handleTextInput: function handleTextInput(view, from, to, text) {
            return run$1(view, from, to, text, rules, plugin)
          },
          handleDOMEvents: {
            compositionend: function (view) {
              setTimeout(function () {
                var ref = view.state.selection;
                var $cursor = ref.$cursor;
                if ($cursor) { run$1(view, $cursor.pos, $cursor.pos, "", rules, plugin); }
              });
            }
          }
        },

        isInputRules: true
      });
      return plugin
    }

    function run$1(view, from, to, text, rules, plugin) {
      if (view.composing) { return false }
      var state = view.state, $from = state.doc.resolve(from);
      if ($from.parent.type.spec.code) { return false }
      var textBefore = $from.parent.textBetween(Math.max(0, $from.parentOffset - MAX_MATCH), $from.parentOffset,
                                                null, "\ufffc") + text;
      for (var i = 0; i < rules.length; i++) {
        var match = rules[i].match.exec(textBefore);
        var tr = match && rules[i].handler(state, match, from - (match[0].length - text.length), to);
        if (!tr) { continue }
        view.dispatch(tr.setMeta(plugin, {transform: tr, from: from, to: to, text: text}));
        return true
      }
      return false
    }

    // :: (EditorState, ?(Transaction)) → bool
    // This is a command that will undo an input rule, if applying such a
    // rule was the last thing that the user did.
    function undoInputRule(state, dispatch) {
      var plugins = state.plugins;
      for (var i = 0; i < plugins.length; i++) {
        var plugin = plugins[i], undoable = (void 0);
        if (plugin.spec.isInputRules && (undoable = plugin.getState(state))) {
          if (dispatch) {
            var tr = state.tr, toUndo = undoable.transform;
            for (var j = toUndo.steps.length - 1; j >= 0; j--)
              { tr.step(toUndo.steps[j].invert(toUndo.docs[j])); }
            if (undoable.text) {
              var marks = tr.doc.resolve(undoable.from).marks();
              tr.replaceWith(undoable.from, undoable.to, state.schema.text(undoable.text, marks));
            } else {
              tr.delete(undoable.from, undoable.to);
            }
            dispatch(tr);
          }
          return true
        }
      }
      return false
    }

    // :: InputRule Converts double dashes to an emdash.
    var emDash = new InputRule(/--$/, "—");
    // :: InputRule Converts three dots to an ellipsis character.
    var ellipsis = new InputRule(/\.\.\.$/, "…");
    // :: InputRule “Smart” opening double quotes.
    var openDoubleQuote = new InputRule(/(?:^|[\s\{\[\(\<'"\u2018\u201C])(")$/, "“");
    // :: InputRule “Smart” closing double quotes.
    var closeDoubleQuote = new InputRule(/"$/, "”");
    // :: InputRule “Smart” opening single quotes.
    var openSingleQuote = new InputRule(/(?:^|[\s\{\[\(\<'"\u2018\u201C])(')$/, "‘");
    // :: InputRule “Smart” closing single quotes.
    var closeSingleQuote = new InputRule(/'$/, "’");

    // :: [InputRule] Smart-quote related input rules.
    var smartQuotes = [openDoubleQuote, closeDoubleQuote, openSingleQuote, closeSingleQuote];

    // :: (RegExp, NodeType, ?union<Object, ([string]) → ?Object>, ?([string], Node) → bool) → InputRule
    // Build an input rule for automatically wrapping a textblock when a
    // given string is typed. The `regexp` argument is
    // directly passed through to the `InputRule` constructor. You'll
    // probably want the regexp to start with `^`, so that the pattern can
    // only occur at the start of a textblock.
    //
    // `nodeType` is the type of node to wrap in. If it needs attributes,
    // you can either pass them directly, or pass a function that will
    // compute them from the regular expression match.
    //
    // By default, if there's a node with the same type above the newly
    // wrapped node, the rule will try to [join](#transform.Transform.join) those
    // two nodes. You can pass a join predicate, which takes a regular
    // expression match and the node before the wrapped node, and can
    // return a boolean to indicate whether a join should happen.
    function wrappingInputRule(regexp, nodeType, getAttrs, joinPredicate) {
      return new InputRule(regexp, function (state, match, start, end) {
        var attrs = getAttrs instanceof Function ? getAttrs(match) : getAttrs;
        var tr = state.tr.delete(start, end);
        var $start = tr.doc.resolve(start), range = $start.blockRange(), wrapping = range && findWrapping(range, nodeType, attrs);
        if (!wrapping) { return null }
        tr.wrap(range, wrapping);
        var before = tr.doc.resolve(start - 1).nodeBefore;
        if (before && before.type == nodeType && canJoin(tr.doc, start - 1) &&
            (!joinPredicate || joinPredicate(match, before)))
          { tr.join(start - 1); }
        return tr
      })
    }

    // :: (RegExp, NodeType, ?union<Object, ([string]) → ?Object>) → InputRule
    // Build an input rule that changes the type of a textblock when the
    // matched text is typed into it. You'll usually want to start your
    // regexp with `^` to that it is only matched at the start of a
    // textblock. The optional `getAttrs` parameter can be used to compute
    // the new node's attributes, and works the same as in the
    // `wrappingInputRule` function.
    function textblockTypeInputRule(regexp, nodeType, getAttrs) {
      return new InputRule(regexp, function (state, match, start, end) {
        var $start = state.doc.resolve(start);
        var attrs = getAttrs instanceof Function ? getAttrs(match) : getAttrs;
        if (!$start.node(-1).canReplaceWith($start.index(-1), $start.indexAfter(-1), nodeType)) { return null }
        return state.tr
          .delete(start, end)
          .setBlockType(start, start, nodeType, attrs)
      })
    }
    //# sourceMappingURL=index.es.js.map

    var prefix$3 = "ProseMirror-prompt";

    function openPrompt(options) {
      var wrapper = document.body.appendChild(document.createElement("div"));
      wrapper.className = prefix$3;

      var mouseOutside = function (e) { if (!wrapper.contains(e.target)) { close(); } };
      setTimeout(function () { return window.addEventListener("mousedown", mouseOutside); }, 50);
      var close = function () {
        window.removeEventListener("mousedown", mouseOutside);
        if (wrapper.parentNode) { wrapper.parentNode.removeChild(wrapper); }
      };

      var domFields = [];
      for (var name in options.fields) { domFields.push(options.fields[name].render()); }

      var submitButton = document.createElement("button");
      submitButton.type = "submit";
      submitButton.className = prefix$3 + "-submit";
      submitButton.textContent = "OK";
      var cancelButton = document.createElement("button");
      cancelButton.type = "button";
      cancelButton.className = prefix$3 + "-cancel";
      cancelButton.textContent = "Cancel";
      cancelButton.addEventListener("click", close);

      var form = wrapper.appendChild(document.createElement("form"));
      if (options.title) { form.appendChild(document.createElement("h5")).textContent = options.title; }
      domFields.forEach(function (field) {
        form.appendChild(document.createElement("div")).appendChild(field);
      });
      var buttons = form.appendChild(document.createElement("div"));
      buttons.className = prefix$3 + "-buttons";
      buttons.appendChild(submitButton);
      buttons.appendChild(document.createTextNode(" "));
      buttons.appendChild(cancelButton);

      var box = wrapper.getBoundingClientRect();
      wrapper.style.top = ((window.innerHeight - box.height) / 2) + "px";
      wrapper.style.left = ((window.innerWidth - box.width) / 2) + "px";

      var submit = function () {
        var params = getValues(options.fields, domFields);
        if (params) {
          close();
          options.callback(params);
        }
      };

      form.addEventListener("submit", function (e) {
        e.preventDefault();
        submit();
      });

      form.addEventListener("keydown", function (e) {
        if (e.keyCode == 27) {
          e.preventDefault();
          close();
        } else if (e.keyCode == 13 && !(e.ctrlKey || e.metaKey || e.shiftKey)) {
          e.preventDefault();
          submit();
        } else if (e.keyCode == 9) {
          window.setTimeout(function () {
            if (!wrapper.contains(document.activeElement)) { close(); }
          }, 500);
        }
      });

      var input = form.elements[0];
      if (input) { input.focus(); }
    }

    function getValues(fields, domFields) {
      var result = Object.create(null), i = 0;
      for (var name in fields) {
        var field = fields[name], dom = domFields[i++];
        var value = field.read(dom), bad = field.validate(value);
        if (bad) {
          reportInvalid(dom, bad);
          return null
        }
        result[name] = field.clean(value);
      }
      return result
    }

    function reportInvalid(dom, message) {
      // FIXME this is awful and needs a lot more work
      var parent = dom.parentNode;
      var msg = parent.appendChild(document.createElement("div"));
      msg.style.left = (dom.offsetLeft + dom.offsetWidth + 2) + "px";
      msg.style.top = (dom.offsetTop - 5) + "px";
      msg.className = "ProseMirror-invalid";
      msg.textContent = message;
      setTimeout(function () { return parent.removeChild(msg); }, 1500);
    }

    // ::- The type of field that `FieldPrompt` expects to be passed to it.
    var Field = function Field(options) { this.options = options; };

    // render:: (state: EditorState, props: Object) → dom.Node
    // Render the field to the DOM. Should be implemented by all subclasses.

    // :: (dom.Node) → any
    // Read the field's value from its DOM node.
    Field.prototype.read = function read (dom) { return dom.value };

    // :: (any) → ?string
    // A field-type-specific validation function.
    Field.prototype.validateType = function validateType (_value) {};

    Field.prototype.validate = function validate (value) {
      if (!value && this.options.required)
        { return "Required field" }
      return this.validateType(value) || (this.options.validate && this.options.validate(value))
    };

    Field.prototype.clean = function clean (value) {
      return this.options.clean ? this.options.clean(value) : value
    };

    // ::- A field class for single-line text fields.
    var TextField = /*@__PURE__*/(function (Field) {
      function TextField () {
        Field.apply(this, arguments);
      }

      if ( Field ) TextField.__proto__ = Field;
      TextField.prototype = Object.create( Field && Field.prototype );
      TextField.prototype.constructor = TextField;

      TextField.prototype.render = function render () {
        var input = document.createElement("input");
        input.type = "text";
        input.placeholder = this.options.label;
        input.value = this.options.value || "";
        input.autocomplete = "off";
        return input
      };

      return TextField;
    }(Field));

    // Helpers to create specific types of items

    function canInsert(state, nodeType) {
      var $from = state.selection.$from;
      for (var d = $from.depth; d >= 0; d--) {
        var index = $from.index(d);
        if ($from.node(d).canReplaceWith(index, index, nodeType)) { return true }
      }
      return false
    }

    function insertImageItem(nodeType) {
      return new MenuItem({
        title: "Insert image",
        label: "Image",
        enable: function enable(state) { return canInsert(state, nodeType) },
        run: function run(state, _, view) {
          var ref = state.selection;
          var from = ref.from;
          var to = ref.to;
          var attrs = null;
          if (state.selection instanceof NodeSelection && state.selection.node.type == nodeType)
            { attrs = state.selection.node.attrs; }
          openPrompt({
            title: "Insert image",
            fields: {
              src: new TextField({label: "Location", required: true, value: attrs && attrs.src}),
              title: new TextField({label: "Title", value: attrs && attrs.title}),
              alt: new TextField({label: "Description",
                                  value: attrs ? attrs.alt : state.doc.textBetween(from, to, " ")})
            },
            callback: function callback(attrs) {
              view.dispatch(view.state.tr.replaceSelectionWith(nodeType.createAndFill(attrs)));
              view.focus();
            }
          });
        }
      })
    }

    function cmdItem(cmd, options) {
      var passedOptions = {
        label: options.title,
        run: cmd
      };
      for (var prop in options) { passedOptions[prop] = options[prop]; }
      if ((!options.enable || options.enable === true) && !options.select)
        { passedOptions[options.enable ? "enable" : "select"] = function (state) { return cmd(state); }; }

      return new MenuItem(passedOptions)
    }

    function markActive(state, type) {
      var ref = state.selection;
      var from = ref.from;
      var $from = ref.$from;
      var to = ref.to;
      var empty = ref.empty;
      if (empty) { return type.isInSet(state.storedMarks || $from.marks()) }
      else { return state.doc.rangeHasMark(from, to, type) }
    }

    function markItem(markType, options) {
      var passedOptions = {
        active: function active(state) { return markActive(state, markType) },
        enable: true
      };
      for (var prop in options) { passedOptions[prop] = options[prop]; }
      return cmdItem(toggleMark(markType), passedOptions)
    }

    function linkItem(markType) {
      return new MenuItem({
        title: "Add or remove link",
        icon: icons.link,
        active: function active(state) { return markActive(state, markType) },
        enable: function enable(state) { return !state.selection.empty },
        run: function run(state, dispatch, view) {
          if (markActive(state, markType)) {
            toggleMark(markType)(state, dispatch);
            return true
          }
          openPrompt({
            title: "Create a link",
            fields: {
              href: new TextField({
                label: "Link target",
                required: true
              }),
              title: new TextField({label: "Title"})
            },
            callback: function callback(attrs) {
              toggleMark(markType, attrs)(view.state, view.dispatch);
              view.focus();
            }
          });
        }
      })
    }

    function wrapListItem(nodeType, options) {
      return cmdItem(wrapInList(nodeType, options.attrs), options)
    }

    // :: (Schema) → Object
    // Given a schema, look for default mark and node types in it and
    // return an object with relevant menu items relating to those marks:
    //
    // **`toggleStrong`**`: MenuItem`
    //   : A menu item to toggle the [strong mark](#schema-basic.StrongMark).
    //
    // **`toggleEm`**`: MenuItem`
    //   : A menu item to toggle the [emphasis mark](#schema-basic.EmMark).
    //
    // **`toggleCode`**`: MenuItem`
    //   : A menu item to toggle the [code font mark](#schema-basic.CodeMark).
    //
    // **`toggleLink`**`: MenuItem`
    //   : A menu item to toggle the [link mark](#schema-basic.LinkMark).
    //
    // **`insertImage`**`: MenuItem`
    //   : A menu item to insert an [image](#schema-basic.Image).
    //
    // **`wrapBulletList`**`: MenuItem`
    //   : A menu item to wrap the selection in a [bullet list](#schema-list.BulletList).
    //
    // **`wrapOrderedList`**`: MenuItem`
    //   : A menu item to wrap the selection in an [ordered list](#schema-list.OrderedList).
    //
    // **`wrapBlockQuote`**`: MenuItem`
    //   : A menu item to wrap the selection in a [block quote](#schema-basic.BlockQuote).
    //
    // **`makeParagraph`**`: MenuItem`
    //   : A menu item to set the current textblock to be a normal
    //     [paragraph](#schema-basic.Paragraph).
    //
    // **`makeCodeBlock`**`: MenuItem`
    //   : A menu item to set the current textblock to be a
    //     [code block](#schema-basic.CodeBlock).
    //
    // **`makeHead[N]`**`: MenuItem`
    //   : Where _N_ is 1 to 6. Menu items to set the current textblock to
    //     be a [heading](#schema-basic.Heading) of level _N_.
    //
    // **`insertHorizontalRule`**`: MenuItem`
    //   : A menu item to insert a horizontal rule.
    //
    // The return value also contains some prefabricated menu elements and
    // menus, that you can use instead of composing your own menu from
    // scratch:
    //
    // **`insertMenu`**`: Dropdown`
    //   : A dropdown containing the `insertImage` and
    //     `insertHorizontalRule` items.
    //
    // **`typeMenu`**`: Dropdown`
    //   : A dropdown containing the items for making the current
    //     textblock a paragraph, code block, or heading.
    //
    // **`fullMenu`**`: [[MenuElement]]`
    //   : An array of arrays of menu elements for use as the full menu
    //     for, for example the [menu bar](https://github.com/prosemirror/prosemirror-menu#user-content-menubar).
    function buildMenuItems(schema) {
      var r = {}, type;
      if (type = schema.marks.strong)
        { r.toggleStrong = markItem(type, {title: "Toggle strong style", icon: icons.strong}); }
      if (type = schema.marks.em)
        { r.toggleEm = markItem(type, {title: "Toggle emphasis", icon: icons.em}); }
      if (type = schema.marks.code)
        { r.toggleCode = markItem(type, {title: "Toggle code font", icon: icons.code}); }
      if (type = schema.marks.link)
        { r.toggleLink = linkItem(type); }

      if (type = schema.nodes.image)
        { r.insertImage = insertImageItem(type); }
      if (type = schema.nodes.bullet_list)
        { r.wrapBulletList = wrapListItem(type, {
          title: "Wrap in bullet list",
          icon: icons.bulletList
        }); }
      if (type = schema.nodes.ordered_list)
        { r.wrapOrderedList = wrapListItem(type, {
          title: "Wrap in ordered list",
          icon: icons.orderedList
        }); }
      if (type = schema.nodes.blockquote)
        { r.wrapBlockQuote = wrapItem(type, {
          title: "Wrap in block quote",
          icon: icons.blockquote
        }); }
      if (type = schema.nodes.paragraph)
        { r.makeParagraph = blockTypeItem(type, {
          title: "Change to paragraph",
          label: "Plain"
        }); }
      if (type = schema.nodes.code_block)
        { r.makeCodeBlock = blockTypeItem(type, {
          title: "Change to code block",
          label: "Code"
        }); }
      if (type = schema.nodes.heading)
        { for (var i = 1; i <= 10; i++)
          { r["makeHead" + i] = blockTypeItem(type, {
            title: "Change to heading " + i,
            label: "Level " + i,
            attrs: {level: i}
          }); } }
      if (type = schema.nodes.horizontal_rule) {
        var hr = type;
        r.insertHorizontalRule = new MenuItem({
          title: "Insert horizontal rule",
          label: "Horizontal rule",
          enable: function enable(state) { return canInsert(state, hr) },
          run: function run(state, dispatch) { dispatch(state.tr.replaceSelectionWith(hr.create())); }
        });
      }

      var cut = function (arr) { return arr.filter(function (x) { return x; }); };
      r.insertMenu = new Dropdown(cut([r.insertImage, r.insertHorizontalRule]), {label: "Insert"});
      r.typeMenu = new Dropdown(cut([r.makeParagraph, r.makeCodeBlock, r.makeHead1 && new DropdownSubmenu(cut([
        r.makeHead1, r.makeHead2, r.makeHead3, r.makeHead4, r.makeHead5, r.makeHead6
      ]), {label: "Heading"})]), {label: "Type..."});

      r.inlineMenu = [cut([r.toggleStrong, r.toggleEm, r.toggleCode, r.toggleLink])];
      r.blockMenu = [cut([r.wrapBulletList, r.wrapOrderedList, r.wrapBlockQuote, joinUpItem,
                          liftItem, selectParentNodeItem])];
      r.fullMenu = r.inlineMenu.concat([[r.insertMenu, r.typeMenu]], [[undoItem, redoItem]], r.blockMenu);

      return r
    }

    var mac$3 = typeof navigator != "undefined" ? /Mac/.test(navigator.platform) : false;

    // :: (Schema, ?Object) → Object
    // Inspect the given schema looking for marks and nodes from the
    // basic schema, and if found, add key bindings related to them.
    // This will add:
    //
    // * **Mod-b** for toggling [strong](#schema-basic.StrongMark)
    // * **Mod-i** for toggling [emphasis](#schema-basic.EmMark)
    // * **Mod-`** for toggling [code font](#schema-basic.CodeMark)
    // * **Ctrl-Shift-0** for making the current textblock a paragraph
    // * **Ctrl-Shift-1** to **Ctrl-Shift-Digit6** for making the current
    //   textblock a heading of the corresponding level
    // * **Ctrl-Shift-Backslash** to make the current textblock a code block
    // * **Ctrl-Shift-8** to wrap the selection in an ordered list
    // * **Ctrl-Shift-9** to wrap the selection in a bullet list
    // * **Ctrl->** to wrap the selection in a block quote
    // * **Enter** to split a non-empty textblock in a list item while at
    //   the same time splitting the list item
    // * **Mod-Enter** to insert a hard break
    // * **Mod-_** to insert a horizontal rule
    // * **Backspace** to undo an input rule
    // * **Alt-ArrowUp** to `joinUp`
    // * **Alt-ArrowDown** to `joinDown`
    // * **Mod-BracketLeft** to `lift`
    // * **Escape** to `selectParentNode`
    //
    // You can suppress or map these bindings by passing a `mapKeys`
    // argument, which maps key names (say `"Mod-B"` to either `false`, to
    // remove the binding, or a new key name string.
    function buildKeymap(schema, mapKeys) {
      var keys = {}, type;
      function bind(key, cmd) {
        if (mapKeys) {
          var mapped = mapKeys[key];
          if (mapped === false) { return }
          if (mapped) { key = mapped; }
        }
        keys[key] = cmd;
      }


      bind("Mod-z", undo);
      bind("Shift-Mod-z", redo);
      bind("Backspace", undoInputRule);
      if (!mac$3) { bind("Mod-y", redo); }

      bind("Alt-ArrowUp", joinUp);
      bind("Alt-ArrowDown", joinDown);
      bind("Mod-BracketLeft", lift);
      bind("Escape", selectParentNode);

      if (type = schema.marks.strong) {
        bind("Mod-b", toggleMark(type));
        bind("Mod-B", toggleMark(type));
      }
      if (type = schema.marks.em) {
        bind("Mod-i", toggleMark(type));
        bind("Mod-I", toggleMark(type));
      }
      if (type = schema.marks.code)
        { bind("Mod-`", toggleMark(type)); }

      if (type = schema.nodes.bullet_list)
        { bind("Shift-Ctrl-8", wrapInList(type)); }
      if (type = schema.nodes.ordered_list)
        { bind("Shift-Ctrl-9", wrapInList(type)); }
      if (type = schema.nodes.blockquote)
        { bind("Ctrl->", wrapIn(type)); }
      if (type = schema.nodes.hard_break) {
        var br = type, cmd = chainCommands(exitCode, function (state, dispatch) {
          dispatch(state.tr.replaceSelectionWith(br.create()).scrollIntoView());
          return true
        });
        bind("Mod-Enter", cmd);
        bind("Shift-Enter", cmd);
        if (mac$3) { bind("Ctrl-Enter", cmd); }
      }
      if (type = schema.nodes.list_item) {
        bind("Enter", splitListItem(type));
        bind("Mod-[", liftListItem(type));
        bind("Mod-]", sinkListItem(type));
      }
      if (type = schema.nodes.paragraph)
        { bind("Shift-Ctrl-0", setBlockType(type)); }
      if (type = schema.nodes.code_block)
        { bind("Shift-Ctrl-\\", setBlockType(type)); }
      if (type = schema.nodes.heading)
        { for (var i = 1; i <= 6; i++) { bind("Shift-Ctrl-" + i, setBlockType(type, {level: i})); } }
      if (type = schema.nodes.horizontal_rule) {
        var hr = type;
        bind("Mod-_", function (state, dispatch) {
          dispatch(state.tr.replaceSelectionWith(hr.create()).scrollIntoView());
          return true
        });
      }

      return keys
    }

    // : (NodeType) → InputRule
    // Given a blockquote node type, returns an input rule that turns `"> "`
    // at the start of a textblock into a blockquote.
    function blockQuoteRule(nodeType) {
      return wrappingInputRule(/^\s*>\s$/, nodeType)
    }

    // : (NodeType) → InputRule
    // Given a list node type, returns an input rule that turns a number
    // followed by a dot at the start of a textblock into an ordered list.
    function orderedListRule(nodeType) {
      return wrappingInputRule(/^(\d+)\.\s$/, nodeType, function (match) { return ({order: +match[1]}); },
                               function (match, node) { return node.childCount + node.attrs.order == +match[1]; })
    }

    // : (NodeType) → InputRule
    // Given a list node type, returns an input rule that turns a bullet
    // (dash, plush, or asterisk) at the start of a textblock into a
    // bullet list.
    function bulletListRule(nodeType) {
      return wrappingInputRule(/^\s*([-+*])\s$/, nodeType)
    }

    // : (NodeType) → InputRule
    // Given a code block node type, returns an input rule that turns a
    // textblock starting with three backticks into a code block.
    function codeBlockRule(nodeType) {
      return textblockTypeInputRule(/^```$/, nodeType)
    }

    // : (NodeType, number) → InputRule
    // Given a node type and a maximum level, creates an input rule that
    // turns up to that number of `#` characters followed by a space at
    // the start of a textblock into a heading whose level corresponds to
    // the number of `#` signs.
    function headingRule(nodeType, maxLevel) {
      return textblockTypeInputRule(new RegExp("^(#{1," + maxLevel + "})\\s$"),
                                    nodeType, function (match) { return ({level: match[1].length}); })
    }

    // : (Schema) → Plugin
    // A set of input rules for creating the basic block quotes, lists,
    // code blocks, and heading.
    function buildInputRules(schema) {
      var rules = smartQuotes.concat(ellipsis, emDash), type;
      if (type = schema.nodes.blockquote) { rules.push(blockQuoteRule(type)); }
      if (type = schema.nodes.ordered_list) { rules.push(orderedListRule(type)); }
      if (type = schema.nodes.bullet_list) { rules.push(bulletListRule(type)); }
      if (type = schema.nodes.code_block) { rules.push(codeBlockRule(type)); }
      if (type = schema.nodes.heading) { rules.push(headingRule(type, 6)); }
      return inputRules({rules: rules})
    }

    // !! This module exports helper functions for deriving a set of basic
    // menu items, input rules, or key bindings from a schema. These
    // values need to know about the schema for two reasons—they need
    // access to specific instances of node and mark types, and they need
    // to know which of the node and mark types that they know about are
    // actually present in the schema.
    //
    // The `exampleSetup` plugin ties these together into a plugin that
    // will automatically enable this basic functionality in an editor.

    // :: (Object) → [Plugin]
    // A convenience plugin that bundles together a simple menu with basic
    // key bindings, input rules, and styling for the example schema.
    // Probably only useful for quickly setting up a passable
    // editor—you'll need more control over your settings in most
    // real-world situations.
    //
    //   options::- The following options are recognized:
    //
    //     schema:: Schema
    //     The schema to generate key bindings and menu items for.
    //
    //     mapKeys:: ?Object
    //     Can be used to [adjust](#example-setup.buildKeymap) the key bindings created.
    //
    //     menuBar:: ?bool
    //     Set to false to disable the menu bar.
    //
    //     history:: ?bool
    //     Set to false to disable the history plugin.
    //
    //     floatingMenu:: ?bool
    //     Set to false to make the menu bar non-floating.
    //
    //     menuContent:: [[MenuItem]]
    //     Can be used to override the menu content.
    function exampleSetup(options) {
      var plugins = [
        buildInputRules(options.schema),
        keymap(buildKeymap(options.schema, options.mapKeys)),
        keymap(baseKeymap),
        dropCursor(),
        gapCursor()
      ];
      if (options.menuBar !== false)
        { plugins.push(menuBar({floating: options.floatingMenu !== false,
                              content: options.menuContent || buildMenuItems(options.schema).fullMenu})); }
      if (options.history !== false)
        { plugins.push(history()); }

      return plugins.concat(new Plugin({
        props: {
          attributes: {class: "ProseMirror-example-setup-style"}
        }
      }))
    }
    //# sourceMappingURL=index.es.js.map

    /* src\components\ProEditor.svelte generated by Svelte v3.32.3 */
    const file$2 = "src\\components\\ProEditor.svelte";

    function create_fragment$2(ctx) {
    	let div4;
    	let div0;
    	let t0;
    	let div1;
    	let p;
    	let t2;
    	let div3;
    	let div2;
    	let button0;
    	let i0;
    	let t3;
    	let button1;
    	let i1;
    	let t4;
    	let button2;
    	let i2;
    	let t5;
    	let button3;
    	let i3;
    	let t6;
    	let button4;
    	let i4;
    	let t7;
    	let button5;
    	let i5;

    	const block = {
    		c: function create() {
    			div4 = element("div");
    			div0 = element("div");
    			t0 = space();
    			div1 = element("div");
    			p = element("p");
    			p.textContent = "123";
    			t2 = space();
    			div3 = element("div");
    			div2 = element("div");
    			button0 = element("button");
    			i0 = element("i");
    			t3 = space();
    			button1 = element("button");
    			i1 = element("i");
    			t4 = space();
    			button2 = element("button");
    			i2 = element("i");
    			t5 = space();
    			button3 = element("button");
    			i3 = element("i");
    			t6 = space();
    			button4 = element("button");
    			i4 = element("i");
    			t7 = space();
    			button5 = element("button");
    			i5 = element("i");
    			add_location(div0, file$2, 19, 4, 733);
    			add_location(p, file$2, 21, 8, 800);
    			add_location(div1, file$2, 20, 4, 765);
    			attr_dev(i0, "class", "ri-hashtag");
    			add_location(i0, file$2, 26, 17, 1025);
    			attr_dev(button0, "class", "rounded-sm hover:bg-gray-200 p-1 focus:outline-none");
    			add_location(button0, file$2, 25, 12, 939);
    			attr_dev(i1, "class", "ri-list-check");
    			add_location(i1, file$2, 29, 17, 1172);
    			attr_dev(button1, "class", "rounded-sm hover:bg-gray-200 p-1 focus:outline-none");
    			add_location(button1, file$2, 28, 12, 1086);
    			attr_dev(i2, "class", "ri-list-ordered");
    			add_location(i2, file$2, 32, 17, 1303);
    			attr_dev(button2, "class", "rounded-sm hover:bg-gray-200 p-1");
    			add_location(button2, file$2, 31, 12, 1236);
    			attr_dev(i3, "class", "ri-bold");
    			add_location(i3, file$2, 35, 17, 1436);
    			attr_dev(button3, "class", "rounded-sm hover:bg-gray-200 p-1");
    			add_location(button3, file$2, 34, 12, 1369);
    			attr_dev(i4, "class", "ri-underline");
    			add_location(i4, file$2, 38, 17, 1561);
    			attr_dev(button4, "class", "rounded-sm hover:bg-gray-200 p-1");
    			add_location(button4, file$2, 37, 12, 1494);
    			attr_dev(i5, "class", "ri-image-2-line");
    			add_location(i5, file$2, 41, 17, 1691);
    			attr_dev(button5, "class", "rounded-sm hover:bg-gray-200 p-1");
    			add_location(button5, file$2, 40, 12, 1624);
    			attr_dev(div2, "id", "toolbar-container");
    			attr_dev(div2, "class", "space-x-1");
    			add_location(div2, file$2, 24, 8, 879);
    			attr_dev(div3, "class", " flex justify-between  mt-4");
    			add_location(div3, file$2, 23, 4, 828);
    			attr_dev(div4, "class", "border-gray-200 border-solid border-4 rounded-lg mt-2 p-2");
    			add_location(div4, file$2, 18, 0, 656);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div4, anchor);
    			append_dev(div4, div0);
    			/*div0_binding*/ ctx[2](div0);
    			append_dev(div4, t0);
    			append_dev(div4, div1);
    			append_dev(div1, p);
    			/*div1_binding*/ ctx[3](div1);
    			append_dev(div4, t2);
    			append_dev(div4, div3);
    			append_dev(div3, div2);
    			append_dev(div2, button0);
    			append_dev(button0, i0);
    			append_dev(div2, t3);
    			append_dev(div2, button1);
    			append_dev(button1, i1);
    			append_dev(div2, t4);
    			append_dev(div2, button2);
    			append_dev(button2, i2);
    			append_dev(div2, t5);
    			append_dev(div2, button3);
    			append_dev(button3, i3);
    			append_dev(div2, t6);
    			append_dev(div2, button4);
    			append_dev(button4, i4);
    			append_dev(div2, t7);
    			append_dev(div2, button5);
    			append_dev(button5, i5);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div4);
    			/*div0_binding*/ ctx[2](null);
    			/*div1_binding*/ ctx[3](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("ProEditor", slots, []);
    	let editor = "";
    	let content = "";

    	onMount(() => {
    		let state = EditorState.create({
    			doc: DOMParser.fromSchema(schema).parse(content)
    		});

    		let view = new EditorView(editor, { state });
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ProEditor> was created with unknown prop '${key}'`);
    	});

    	function div0_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			editor = $$value;
    			$$invalidate(0, editor);
    		});
    	}

    	function div1_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			content = $$value;
    			$$invalidate(1, content);
    		});
    	}

    	$$self.$capture_state = () => ({
    		EditorState,
    		EditorView,
    		Schema,
    		DOMParser,
    		schema,
    		addListNodes,
    		exampleSetup,
    		onMount,
    		editor,
    		content
    	});

    	$$self.$inject_state = $$props => {
    		if ("editor" in $$props) $$invalidate(0, editor = $$props.editor);
    		if ("content" in $$props) $$invalidate(1, content = $$props.content);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [editor, content, div0_binding, div1_binding];
    }

    class ProEditor extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2, create_fragment$2, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ProEditor",
    			options,
    			id: create_fragment$2.name
    		});
    	}
    }

    var global$1 = (typeof global !== "undefined" ? global :
                typeof self !== "undefined" ? self :
                typeof window !== "undefined" ? window : {});

    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
    var inited = false;
    function init$1 () {
      inited = true;
      var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
      for (var i = 0, len = code.length; i < len; ++i) {
        lookup[i] = code[i];
        revLookup[code.charCodeAt(i)] = i;
      }

      revLookup['-'.charCodeAt(0)] = 62;
      revLookup['_'.charCodeAt(0)] = 63;
    }

    function toByteArray (b64) {
      if (!inited) {
        init$1();
      }
      var i, j, l, tmp, placeHolders, arr;
      var len = b64.length;

      if (len % 4 > 0) {
        throw new Error('Invalid string. Length must be a multiple of 4')
      }

      // the number of equal signs (place holders)
      // if there are two placeholders, than the two characters before it
      // represent one byte
      // if there is only one, then the three characters before it represent 2 bytes
      // this is just a cheap hack to not do indexOf twice
      placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;

      // base64 is 4/3 + up to two characters of the original data
      arr = new Arr(len * 3 / 4 - placeHolders);

      // if there are placeholders, only get up to the last complete 4 chars
      l = placeHolders > 0 ? len - 4 : len;

      var L = 0;

      for (i = 0, j = 0; i < l; i += 4, j += 3) {
        tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)];
        arr[L++] = (tmp >> 16) & 0xFF;
        arr[L++] = (tmp >> 8) & 0xFF;
        arr[L++] = tmp & 0xFF;
      }

      if (placeHolders === 2) {
        tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4);
        arr[L++] = tmp & 0xFF;
      } else if (placeHolders === 1) {
        tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2);
        arr[L++] = (tmp >> 8) & 0xFF;
        arr[L++] = tmp & 0xFF;
      }

      return arr
    }

    function tripletToBase64 (num) {
      return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
    }

    function encodeChunk (uint8, start, end) {
      var tmp;
      var output = [];
      for (var i = start; i < end; i += 3) {
        tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
        output.push(tripletToBase64(tmp));
      }
      return output.join('')
    }

    function fromByteArray (uint8) {
      if (!inited) {
        init$1();
      }
      var tmp;
      var len = uint8.length;
      var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
      var output = '';
      var parts = [];
      var maxChunkLength = 16383; // must be multiple of 3

      // go through the array every three bytes, we'll deal with trailing stuff later
      for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
        parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)));
      }

      // pad the end with zeros, but make sure to not forget the extra bytes
      if (extraBytes === 1) {
        tmp = uint8[len - 1];
        output += lookup[tmp >> 2];
        output += lookup[(tmp << 4) & 0x3F];
        output += '==';
      } else if (extraBytes === 2) {
        tmp = (uint8[len - 2] << 8) + (uint8[len - 1]);
        output += lookup[tmp >> 10];
        output += lookup[(tmp >> 4) & 0x3F];
        output += lookup[(tmp << 2) & 0x3F];
        output += '=';
      }

      parts.push(output);

      return parts.join('')
    }

    function read (buffer, offset, isLE, mLen, nBytes) {
      var e, m;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i = isLE ? (nBytes - 1) : 0;
      var d = isLE ? -1 : 1;
      var s = buffer[offset + i];

      i += d;

      e = s & ((1 << (-nBits)) - 1);
      s >>= (-nBits);
      nBits += eLen;
      for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

      m = e & ((1 << (-nBits)) - 1);
      e >>= (-nBits);
      nBits += mLen;
      for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

      if (e === 0) {
        e = 1 - eBias;
      } else if (e === eMax) {
        return m ? NaN : ((s ? -1 : 1) * Infinity)
      } else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
      }
      return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
    }

    function write (buffer, value, offset, isLE, mLen, nBytes) {
      var e, m, c;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);
      var i = isLE ? 0 : (nBytes - 1);
      var d = isLE ? 1 : -1;
      var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

      value = Math.abs(value);

      if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
      } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
          e--;
          c *= 2;
        }
        if (e + eBias >= 1) {
          value += rt / c;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c >= 2) {
          e++;
          c /= 2;
        }

        if (e + eBias >= eMax) {
          m = 0;
          e = eMax;
        } else if (e + eBias >= 1) {
          m = (value * c - 1) * Math.pow(2, mLen);
          e = e + eBias;
        } else {
          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e = 0;
        }
      }

      for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

      e = (e << mLen) | m;
      eLen += mLen;
      for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

      buffer[offset + i - d] |= s * 128;
    }

    var toString = {}.toString;

    var isArray = Array.isArray || function (arr) {
      return toString.call(arr) == '[object Array]';
    };

    var INSPECT_MAX_BYTES = 50;

    /**
     * If `Buffer.TYPED_ARRAY_SUPPORT`:
     *   === true    Use Uint8Array implementation (fastest)
     *   === false   Use Object implementation (most compatible, even IE6)
     *
     * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
     * Opera 11.6+, iOS 4.2+.
     *
     * Due to various browser bugs, sometimes the Object implementation will be used even
     * when the browser supports typed arrays.
     *
     * Note:
     *
     *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
     *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
     *
     *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
     *
     *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
     *     incorrect length in some situations.

     * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
     * get the Object implementation, which is slower but behaves correctly.
     */
    Buffer.TYPED_ARRAY_SUPPORT = global$1.TYPED_ARRAY_SUPPORT !== undefined
      ? global$1.TYPED_ARRAY_SUPPORT
      : true;

    function kMaxLength () {
      return Buffer.TYPED_ARRAY_SUPPORT
        ? 0x7fffffff
        : 0x3fffffff
    }

    function createBuffer (that, length) {
      if (kMaxLength() < length) {
        throw new RangeError('Invalid typed array length')
      }
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        // Return an augmented `Uint8Array` instance, for best performance
        that = new Uint8Array(length);
        that.__proto__ = Buffer.prototype;
      } else {
        // Fallback: Return an object instance of the Buffer class
        if (that === null) {
          that = new Buffer(length);
        }
        that.length = length;
      }

      return that
    }

    /**
     * The Buffer constructor returns instances of `Uint8Array` that have their
     * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
     * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
     * and the `Uint8Array` methods. Square bracket notation works as expected -- it
     * returns a single octet.
     *
     * The `Uint8Array` prototype remains unmodified.
     */

    function Buffer (arg, encodingOrOffset, length) {
      if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
        return new Buffer(arg, encodingOrOffset, length)
      }

      // Common case.
      if (typeof arg === 'number') {
        if (typeof encodingOrOffset === 'string') {
          throw new Error(
            'If encoding is specified then the first argument must be a string'
          )
        }
        return allocUnsafe(this, arg)
      }
      return from(this, arg, encodingOrOffset, length)
    }

    Buffer.poolSize = 8192; // not used by this implementation

    // TODO: Legacy, not needed anymore. Remove in next major version.
    Buffer._augment = function (arr) {
      arr.__proto__ = Buffer.prototype;
      return arr
    };

    function from (that, value, encodingOrOffset, length) {
      if (typeof value === 'number') {
        throw new TypeError('"value" argument must not be a number')
      }

      if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
        return fromArrayBuffer(that, value, encodingOrOffset, length)
      }

      if (typeof value === 'string') {
        return fromString(that, value, encodingOrOffset)
      }

      return fromObject(that, value)
    }

    /**
     * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
     * if value is a number.
     * Buffer.from(str[, encoding])
     * Buffer.from(array)
     * Buffer.from(buffer)
     * Buffer.from(arrayBuffer[, byteOffset[, length]])
     **/
    Buffer.from = function (value, encodingOrOffset, length) {
      return from(null, value, encodingOrOffset, length)
    };

    if (Buffer.TYPED_ARRAY_SUPPORT) {
      Buffer.prototype.__proto__ = Uint8Array.prototype;
      Buffer.__proto__ = Uint8Array;
    }

    function assertSize (size) {
      if (typeof size !== 'number') {
        throw new TypeError('"size" argument must be a number')
      } else if (size < 0) {
        throw new RangeError('"size" argument must not be negative')
      }
    }

    function alloc (that, size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(that, size)
      }
      if (fill !== undefined) {
        // Only pay attention to encoding if it's a string. This
        // prevents accidentally sending in a number that would
        // be interpretted as a start offset.
        return typeof encoding === 'string'
          ? createBuffer(that, size).fill(fill, encoding)
          : createBuffer(that, size).fill(fill)
      }
      return createBuffer(that, size)
    }

    /**
     * Creates a new filled Buffer instance.
     * alloc(size[, fill[, encoding]])
     **/
    Buffer.alloc = function (size, fill, encoding) {
      return alloc(null, size, fill, encoding)
    };

    function allocUnsafe (that, size) {
      assertSize(size);
      that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
      if (!Buffer.TYPED_ARRAY_SUPPORT) {
        for (var i = 0; i < size; ++i) {
          that[i] = 0;
        }
      }
      return that
    }

    /**
     * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
     * */
    Buffer.allocUnsafe = function (size) {
      return allocUnsafe(null, size)
    };
    /**
     * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
     */
    Buffer.allocUnsafeSlow = function (size) {
      return allocUnsafe(null, size)
    };

    function fromString (that, string, encoding) {
      if (typeof encoding !== 'string' || encoding === '') {
        encoding = 'utf8';
      }

      if (!Buffer.isEncoding(encoding)) {
        throw new TypeError('"encoding" must be a valid string encoding')
      }

      var length = byteLength(string, encoding) | 0;
      that = createBuffer(that, length);

      var actual = that.write(string, encoding);

      if (actual !== length) {
        // Writing a hex string, for example, that contains invalid characters will
        // cause everything after the first invalid character to be ignored. (e.g.
        // 'abxxcd' will be treated as 'ab')
        that = that.slice(0, actual);
      }

      return that
    }

    function fromArrayLike (that, array) {
      var length = array.length < 0 ? 0 : checked(array.length) | 0;
      that = createBuffer(that, length);
      for (var i = 0; i < length; i += 1) {
        that[i] = array[i] & 255;
      }
      return that
    }

    function fromArrayBuffer (that, array, byteOffset, length) {
      array.byteLength; // this throws if `array` is not a valid ArrayBuffer

      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('\'offset\' is out of bounds')
      }

      if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('\'length\' is out of bounds')
      }

      if (byteOffset === undefined && length === undefined) {
        array = new Uint8Array(array);
      } else if (length === undefined) {
        array = new Uint8Array(array, byteOffset);
      } else {
        array = new Uint8Array(array, byteOffset, length);
      }

      if (Buffer.TYPED_ARRAY_SUPPORT) {
        // Return an augmented `Uint8Array` instance, for best performance
        that = array;
        that.__proto__ = Buffer.prototype;
      } else {
        // Fallback: Return an object instance of the Buffer class
        that = fromArrayLike(that, array);
      }
      return that
    }

    function fromObject (that, obj) {
      if (internalIsBuffer(obj)) {
        var len = checked(obj.length) | 0;
        that = createBuffer(that, len);

        if (that.length === 0) {
          return that
        }

        obj.copy(that, 0, 0, len);
        return that
      }

      if (obj) {
        if ((typeof ArrayBuffer !== 'undefined' &&
            obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
          if (typeof obj.length !== 'number' || isnan(obj.length)) {
            return createBuffer(that, 0)
          }
          return fromArrayLike(that, obj)
        }

        if (obj.type === 'Buffer' && isArray(obj.data)) {
          return fromArrayLike(that, obj.data)
        }
      }

      throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
    }

    function checked (length) {
      // Note: cannot use `length < kMaxLength()` here because that fails when
      // length is NaN (which is otherwise coerced to zero.)
      if (length >= kMaxLength()) {
        throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                             'size: 0x' + kMaxLength().toString(16) + ' bytes')
      }
      return length | 0
    }
    Buffer.isBuffer = isBuffer;
    function internalIsBuffer (b) {
      return !!(b != null && b._isBuffer)
    }

    Buffer.compare = function compare (a, b) {
      if (!internalIsBuffer(a) || !internalIsBuffer(b)) {
        throw new TypeError('Arguments must be Buffers')
      }

      if (a === b) return 0

      var x = a.length;
      var y = b.length;

      for (var i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i];
          y = b[i];
          break
        }
      }

      if (x < y) return -1
      if (y < x) return 1
      return 0
    };

    Buffer.isEncoding = function isEncoding (encoding) {
      switch (String(encoding).toLowerCase()) {
        case 'hex':
        case 'utf8':
        case 'utf-8':
        case 'ascii':
        case 'latin1':
        case 'binary':
        case 'base64':
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return true
        default:
          return false
      }
    };

    Buffer.concat = function concat (list, length) {
      if (!isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers')
      }

      if (list.length === 0) {
        return Buffer.alloc(0)
      }

      var i;
      if (length === undefined) {
        length = 0;
        for (i = 0; i < list.length; ++i) {
          length += list[i].length;
        }
      }

      var buffer = Buffer.allocUnsafe(length);
      var pos = 0;
      for (i = 0; i < list.length; ++i) {
        var buf = list[i];
        if (!internalIsBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers')
        }
        buf.copy(buffer, pos);
        pos += buf.length;
      }
      return buffer
    };

    function byteLength (string, encoding) {
      if (internalIsBuffer(string)) {
        return string.length
      }
      if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
          (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
        return string.byteLength
      }
      if (typeof string !== 'string') {
        string = '' + string;
      }

      var len = string.length;
      if (len === 0) return 0

      // Use a for loop to avoid recursion
      var loweredCase = false;
      for (;;) {
        switch (encoding) {
          case 'ascii':
          case 'latin1':
          case 'binary':
            return len
          case 'utf8':
          case 'utf-8':
          case undefined:
            return utf8ToBytes(string).length
          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return len * 2
          case 'hex':
            return len >>> 1
          case 'base64':
            return base64ToBytes(string).length
          default:
            if (loweredCase) return utf8ToBytes(string).length // assume utf8
            encoding = ('' + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer.byteLength = byteLength;

    function slowToString (encoding, start, end) {
      var loweredCase = false;

      // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
      // property of a typed array.

      // This behaves neither like String nor Uint8Array in that we set start/end
      // to their upper/lower bounds if the value passed is out of range.
      // undefined is handled specially as per ECMA-262 6th Edition,
      // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
      if (start === undefined || start < 0) {
        start = 0;
      }
      // Return early if start > this.length. Done here to prevent potential uint32
      // coercion fail below.
      if (start > this.length) {
        return ''
      }

      if (end === undefined || end > this.length) {
        end = this.length;
      }

      if (end <= 0) {
        return ''
      }

      // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
      end >>>= 0;
      start >>>= 0;

      if (end <= start) {
        return ''
      }

      if (!encoding) encoding = 'utf8';

      while (true) {
        switch (encoding) {
          case 'hex':
            return hexSlice(this, start, end)

          case 'utf8':
          case 'utf-8':
            return utf8Slice(this, start, end)

          case 'ascii':
            return asciiSlice(this, start, end)

          case 'latin1':
          case 'binary':
            return latin1Slice(this, start, end)

          case 'base64':
            return base64Slice(this, start, end)

          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return utf16leSlice(this, start, end)

          default:
            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
            encoding = (encoding + '').toLowerCase();
            loweredCase = true;
        }
      }
    }

    // The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
    // Buffer instances.
    Buffer.prototype._isBuffer = true;

    function swap (b, n, m) {
      var i = b[n];
      b[n] = b[m];
      b[m] = i;
    }

    Buffer.prototype.swap16 = function swap16 () {
      var len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError('Buffer size must be a multiple of 16-bits')
      }
      for (var i = 0; i < len; i += 2) {
        swap(this, i, i + 1);
      }
      return this
    };

    Buffer.prototype.swap32 = function swap32 () {
      var len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError('Buffer size must be a multiple of 32-bits')
      }
      for (var i = 0; i < len; i += 4) {
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
      }
      return this
    };

    Buffer.prototype.swap64 = function swap64 () {
      var len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError('Buffer size must be a multiple of 64-bits')
      }
      for (var i = 0; i < len; i += 8) {
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
      }
      return this
    };

    Buffer.prototype.toString = function toString () {
      var length = this.length | 0;
      if (length === 0) return ''
      if (arguments.length === 0) return utf8Slice(this, 0, length)
      return slowToString.apply(this, arguments)
    };

    Buffer.prototype.equals = function equals (b) {
      if (!internalIsBuffer(b)) throw new TypeError('Argument must be a Buffer')
      if (this === b) return true
      return Buffer.compare(this, b) === 0
    };

    Buffer.prototype.inspect = function inspect () {
      var str = '';
      var max = INSPECT_MAX_BYTES;
      if (this.length > 0) {
        str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
        if (this.length > max) str += ' ... ';
      }
      return '<Buffer ' + str + '>'
    };

    Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
      if (!internalIsBuffer(target)) {
        throw new TypeError('Argument must be a Buffer')
      }

      if (start === undefined) {
        start = 0;
      }
      if (end === undefined) {
        end = target ? target.length : 0;
      }
      if (thisStart === undefined) {
        thisStart = 0;
      }
      if (thisEnd === undefined) {
        thisEnd = this.length;
      }

      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError('out of range index')
      }

      if (thisStart >= thisEnd && start >= end) {
        return 0
      }
      if (thisStart >= thisEnd) {
        return -1
      }
      if (start >= end) {
        return 1
      }

      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;

      if (this === target) return 0

      var x = thisEnd - thisStart;
      var y = end - start;
      var len = Math.min(x, y);

      var thisCopy = this.slice(thisStart, thisEnd);
      var targetCopy = target.slice(start, end);

      for (var i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x = thisCopy[i];
          y = targetCopy[i];
          break
        }
      }

      if (x < y) return -1
      if (y < x) return 1
      return 0
    };

    // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
    // OR the last index of `val` in `buffer` at offset <= `byteOffset`.
    //
    // Arguments:
    // - buffer - a Buffer to search
    // - val - a string, Buffer, or number
    // - byteOffset - an index into `buffer`; will be clamped to an int32
    // - encoding - an optional encoding, relevant is val is a string
    // - dir - true for indexOf, false for lastIndexOf
    function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
      // Empty buffer means no match
      if (buffer.length === 0) return -1

      // Normalize byteOffset
      if (typeof byteOffset === 'string') {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 0x7fffffff) {
        byteOffset = 0x7fffffff;
      } else if (byteOffset < -0x80000000) {
        byteOffset = -0x80000000;
      }
      byteOffset = +byteOffset;  // Coerce to Number.
      if (isNaN(byteOffset)) {
        // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
        byteOffset = dir ? 0 : (buffer.length - 1);
      }

      // Normalize byteOffset: negative offsets start from the end of the buffer
      if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
      if (byteOffset >= buffer.length) {
        if (dir) return -1
        else byteOffset = buffer.length - 1;
      } else if (byteOffset < 0) {
        if (dir) byteOffset = 0;
        else return -1
      }

      // Normalize val
      if (typeof val === 'string') {
        val = Buffer.from(val, encoding);
      }

      // Finally, search either indexOf (if dir is true) or lastIndexOf
      if (internalIsBuffer(val)) {
        // Special case: looking for empty string/buffer always fails
        if (val.length === 0) {
          return -1
        }
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
      } else if (typeof val === 'number') {
        val = val & 0xFF; // Search for a byte value [0-255]
        if (Buffer.TYPED_ARRAY_SUPPORT &&
            typeof Uint8Array.prototype.indexOf === 'function') {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
          }
        }
        return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
      }

      throw new TypeError('val must be string, number or Buffer')
    }

    function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
      var indexSize = 1;
      var arrLength = arr.length;
      var valLength = val.length;

      if (encoding !== undefined) {
        encoding = String(encoding).toLowerCase();
        if (encoding === 'ucs2' || encoding === 'ucs-2' ||
            encoding === 'utf16le' || encoding === 'utf-16le') {
          if (arr.length < 2 || val.length < 2) {
            return -1
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }

      function read (buf, i) {
        if (indexSize === 1) {
          return buf[i]
        } else {
          return buf.readUInt16BE(i * indexSize)
        }
      }

      var i;
      if (dir) {
        var foundIndex = -1;
        for (i = byteOffset; i < arrLength; i++) {
          if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1) foundIndex = i;
            if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
          } else {
            if (foundIndex !== -1) i -= i - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
        for (i = byteOffset; i >= 0; i--) {
          var found = true;
          for (var j = 0; j < valLength; j++) {
            if (read(arr, i + j) !== read(val, j)) {
              found = false;
              break
            }
          }
          if (found) return i
        }
      }

      return -1
    }

    Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1
    };

    Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
    };

    Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
    };

    function hexWrite (buf, string, offset, length) {
      offset = Number(offset) || 0;
      var remaining = buf.length - offset;
      if (!length) {
        length = remaining;
      } else {
        length = Number(length);
        if (length > remaining) {
          length = remaining;
        }
      }

      // must be an even number of digits
      var strLen = string.length;
      if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

      if (length > strLen / 2) {
        length = strLen / 2;
      }
      for (var i = 0; i < length; ++i) {
        var parsed = parseInt(string.substr(i * 2, 2), 16);
        if (isNaN(parsed)) return i
        buf[offset + i] = parsed;
      }
      return i
    }

    function utf8Write (buf, string, offset, length) {
      return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
    }

    function asciiWrite (buf, string, offset, length) {
      return blitBuffer(asciiToBytes(string), buf, offset, length)
    }

    function latin1Write (buf, string, offset, length) {
      return asciiWrite(buf, string, offset, length)
    }

    function base64Write (buf, string, offset, length) {
      return blitBuffer(base64ToBytes(string), buf, offset, length)
    }

    function ucs2Write (buf, string, offset, length) {
      return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
    }

    Buffer.prototype.write = function write (string, offset, length, encoding) {
      // Buffer#write(string)
      if (offset === undefined) {
        encoding = 'utf8';
        length = this.length;
        offset = 0;
      // Buffer#write(string, encoding)
      } else if (length === undefined && typeof offset === 'string') {
        encoding = offset;
        length = this.length;
        offset = 0;
      // Buffer#write(string, offset[, length][, encoding])
      } else if (isFinite(offset)) {
        offset = offset | 0;
        if (isFinite(length)) {
          length = length | 0;
          if (encoding === undefined) encoding = 'utf8';
        } else {
          encoding = length;
          length = undefined;
        }
      // legacy write(string, encoding, offset, length) - remove in v0.13
      } else {
        throw new Error(
          'Buffer.write(string, encoding, offset[, length]) is no longer supported'
        )
      }

      var remaining = this.length - offset;
      if (length === undefined || length > remaining) length = remaining;

      if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
        throw new RangeError('Attempt to write outside buffer bounds')
      }

      if (!encoding) encoding = 'utf8';

      var loweredCase = false;
      for (;;) {
        switch (encoding) {
          case 'hex':
            return hexWrite(this, string, offset, length)

          case 'utf8':
          case 'utf-8':
            return utf8Write(this, string, offset, length)

          case 'ascii':
            return asciiWrite(this, string, offset, length)

          case 'latin1':
          case 'binary':
            return latin1Write(this, string, offset, length)

          case 'base64':
            // Warning: maxLength not taken into account in base64Write
            return base64Write(this, string, offset, length)

          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return ucs2Write(this, string, offset, length)

          default:
            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
            encoding = ('' + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };

    Buffer.prototype.toJSON = function toJSON () {
      return {
        type: 'Buffer',
        data: Array.prototype.slice.call(this._arr || this, 0)
      }
    };

    function base64Slice (buf, start, end) {
      if (start === 0 && end === buf.length) {
        return fromByteArray(buf)
      } else {
        return fromByteArray(buf.slice(start, end))
      }
    }

    function utf8Slice (buf, start, end) {
      end = Math.min(buf.length, end);
      var res = [];

      var i = start;
      while (i < end) {
        var firstByte = buf[i];
        var codePoint = null;
        var bytesPerSequence = (firstByte > 0xEF) ? 4
          : (firstByte > 0xDF) ? 3
          : (firstByte > 0xBF) ? 2
          : 1;

        if (i + bytesPerSequence <= end) {
          var secondByte, thirdByte, fourthByte, tempCodePoint;

          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 0x80) {
                codePoint = firstByte;
              }
              break
            case 2:
              secondByte = buf[i + 1];
              if ((secondByte & 0xC0) === 0x80) {
                tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);
                if (tempCodePoint > 0x7F) {
                  codePoint = tempCodePoint;
                }
              }
              break
            case 3:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
                tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);
                if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                  codePoint = tempCodePoint;
                }
              }
              break
            case 4:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              fourthByte = buf[i + 3];
              if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
                tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);
                if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }

        if (codePoint === null) {
          // we did not generate a valid codePoint so insert a
          // replacement char (U+FFFD) and advance only 1 byte
          codePoint = 0xFFFD;
          bytesPerSequence = 1;
        } else if (codePoint > 0xFFFF) {
          // encode to utf16 (surrogate pair dance)
          codePoint -= 0x10000;
          res.push(codePoint >>> 10 & 0x3FF | 0xD800);
          codePoint = 0xDC00 | codePoint & 0x3FF;
        }

        res.push(codePoint);
        i += bytesPerSequence;
      }

      return decodeCodePointsArray(res)
    }

    // Based on http://stackoverflow.com/a/22747272/680742, the browser with
    // the lowest limit is Chrome, with 0x10000 args.
    // We go 1 magnitude less, for safety
    var MAX_ARGUMENTS_LENGTH = 0x1000;

    function decodeCodePointsArray (codePoints) {
      var len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
      }

      // Decode in chunks to avoid "call stack size exceeded".
      var res = '';
      var i = 0;
      while (i < len) {
        res += String.fromCharCode.apply(
          String,
          codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
        );
      }
      return res
    }

    function asciiSlice (buf, start, end) {
      var ret = '';
      end = Math.min(buf.length, end);

      for (var i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i] & 0x7F);
      }
      return ret
    }

    function latin1Slice (buf, start, end) {
      var ret = '';
      end = Math.min(buf.length, end);

      for (var i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i]);
      }
      return ret
    }

    function hexSlice (buf, start, end) {
      var len = buf.length;

      if (!start || start < 0) start = 0;
      if (!end || end < 0 || end > len) end = len;

      var out = '';
      for (var i = start; i < end; ++i) {
        out += toHex(buf[i]);
      }
      return out
    }

    function utf16leSlice (buf, start, end) {
      var bytes = buf.slice(start, end);
      var res = '';
      for (var i = 0; i < bytes.length; i += 2) {
        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
      }
      return res
    }

    Buffer.prototype.slice = function slice (start, end) {
      var len = this.length;
      start = ~~start;
      end = end === undefined ? len : ~~end;

      if (start < 0) {
        start += len;
        if (start < 0) start = 0;
      } else if (start > len) {
        start = len;
      }

      if (end < 0) {
        end += len;
        if (end < 0) end = 0;
      } else if (end > len) {
        end = len;
      }

      if (end < start) end = start;

      var newBuf;
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        newBuf = this.subarray(start, end);
        newBuf.__proto__ = Buffer.prototype;
      } else {
        var sliceLen = end - start;
        newBuf = new Buffer(sliceLen, undefined);
        for (var i = 0; i < sliceLen; ++i) {
          newBuf[i] = this[i + start];
        }
      }

      return newBuf
    };

    /*
     * Need to make sure that buffer isn't trying to write out of bounds.
     */
    function checkOffset (offset, ext, length) {
      if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
      if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
    }

    Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
      offset = offset | 0;
      byteLength = byteLength | 0;
      if (!noAssert) checkOffset(offset, byteLength, this.length);

      var val = this[offset];
      var mul = 1;
      var i = 0;
      while (++i < byteLength && (mul *= 0x100)) {
        val += this[offset + i] * mul;
      }

      return val
    };

    Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
      offset = offset | 0;
      byteLength = byteLength | 0;
      if (!noAssert) {
        checkOffset(offset, byteLength, this.length);
      }

      var val = this[offset + --byteLength];
      var mul = 1;
      while (byteLength > 0 && (mul *= 0x100)) {
        val += this[offset + --byteLength] * mul;
      }

      return val
    };

    Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 1, this.length);
      return this[offset]
    };

    Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] | (this[offset + 1] << 8)
    };

    Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 2, this.length);
      return (this[offset] << 8) | this[offset + 1]
    };

    Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length);

      return ((this[offset]) |
          (this[offset + 1] << 8) |
          (this[offset + 2] << 16)) +
          (this[offset + 3] * 0x1000000)
    };

    Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length);

      return (this[offset] * 0x1000000) +
        ((this[offset + 1] << 16) |
        (this[offset + 2] << 8) |
        this[offset + 3])
    };

    Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
      offset = offset | 0;
      byteLength = byteLength | 0;
      if (!noAssert) checkOffset(offset, byteLength, this.length);

      var val = this[offset];
      var mul = 1;
      var i = 0;
      while (++i < byteLength && (mul *= 0x100)) {
        val += this[offset + i] * mul;
      }
      mul *= 0x80;

      if (val >= mul) val -= Math.pow(2, 8 * byteLength);

      return val
    };

    Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
      offset = offset | 0;
      byteLength = byteLength | 0;
      if (!noAssert) checkOffset(offset, byteLength, this.length);

      var i = byteLength;
      var mul = 1;
      var val = this[offset + --i];
      while (i > 0 && (mul *= 0x100)) {
        val += this[offset + --i] * mul;
      }
      mul *= 0x80;

      if (val >= mul) val -= Math.pow(2, 8 * byteLength);

      return val
    };

    Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 1, this.length);
      if (!(this[offset] & 0x80)) return (this[offset])
      return ((0xff - this[offset] + 1) * -1)
    };

    Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 2, this.length);
      var val = this[offset] | (this[offset + 1] << 8);
      return (val & 0x8000) ? val | 0xFFFF0000 : val
    };

    Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 2, this.length);
      var val = this[offset + 1] | (this[offset] << 8);
      return (val & 0x8000) ? val | 0xFFFF0000 : val
    };

    Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length);

      return (this[offset]) |
        (this[offset + 1] << 8) |
        (this[offset + 2] << 16) |
        (this[offset + 3] << 24)
    };

    Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length);

      return (this[offset] << 24) |
        (this[offset + 1] << 16) |
        (this[offset + 2] << 8) |
        (this[offset + 3])
    };

    Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length);
      return read(this, offset, true, 23, 4)
    };

    Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length);
      return read(this, offset, false, 23, 4)
    };

    Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 8, this.length);
      return read(this, offset, true, 52, 8)
    };

    Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 8, this.length);
      return read(this, offset, false, 52, 8)
    };

    function checkInt (buf, value, offset, ext, max, min) {
      if (!internalIsBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
      if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
      if (offset + ext > buf.length) throw new RangeError('Index out of range')
    }

    Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
      value = +value;
      offset = offset | 0;
      byteLength = byteLength | 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
      }

      var mul = 1;
      var i = 0;
      this[offset] = value & 0xFF;
      while (++i < byteLength && (mul *= 0x100)) {
        this[offset + i] = (value / mul) & 0xFF;
      }

      return offset + byteLength
    };

    Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
      value = +value;
      offset = offset | 0;
      byteLength = byteLength | 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
      }

      var i = byteLength - 1;
      var mul = 1;
      this[offset + i] = value & 0xFF;
      while (--i >= 0 && (mul *= 0x100)) {
        this[offset + i] = (value / mul) & 0xFF;
      }

      return offset + byteLength
    };

    Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
      if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
      this[offset] = (value & 0xff);
      return offset + 1
    };

    function objectWriteUInt16 (buf, value, offset, littleEndian) {
      if (value < 0) value = 0xffff + value + 1;
      for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
        buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
          (littleEndian ? i : 1 - i) * 8;
      }
    }

    Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value & 0xff);
        this[offset + 1] = (value >>> 8);
      } else {
        objectWriteUInt16(this, value, offset, true);
      }
      return offset + 2
    };

    Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value >>> 8);
        this[offset + 1] = (value & 0xff);
      } else {
        objectWriteUInt16(this, value, offset, false);
      }
      return offset + 2
    };

    function objectWriteUInt32 (buf, value, offset, littleEndian) {
      if (value < 0) value = 0xffffffff + value + 1;
      for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
        buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff;
      }
    }

    Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset + 3] = (value >>> 24);
        this[offset + 2] = (value >>> 16);
        this[offset + 1] = (value >>> 8);
        this[offset] = (value & 0xff);
      } else {
        objectWriteUInt32(this, value, offset, true);
      }
      return offset + 4
    };

    Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value >>> 24);
        this[offset + 1] = (value >>> 16);
        this[offset + 2] = (value >>> 8);
        this[offset + 3] = (value & 0xff);
      } else {
        objectWriteUInt32(this, value, offset, false);
      }
      return offset + 4
    };

    Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength - 1);

        checkInt(this, value, offset, byteLength, limit - 1, -limit);
      }

      var i = 0;
      var mul = 1;
      var sub = 0;
      this[offset] = value & 0xFF;
      while (++i < byteLength && (mul *= 0x100)) {
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
      }

      return offset + byteLength
    };

    Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength - 1);

        checkInt(this, value, offset, byteLength, limit - 1, -limit);
      }

      var i = byteLength - 1;
      var mul = 1;
      var sub = 0;
      this[offset + i] = value & 0xFF;
      while (--i >= 0 && (mul *= 0x100)) {
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
      }

      return offset + byteLength
    };

    Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
      if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
      if (value < 0) value = 0xff + value + 1;
      this[offset] = (value & 0xff);
      return offset + 1
    };

    Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value & 0xff);
        this[offset + 1] = (value >>> 8);
      } else {
        objectWriteUInt16(this, value, offset, true);
      }
      return offset + 2
    };

    Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value >>> 8);
        this[offset + 1] = (value & 0xff);
      } else {
        objectWriteUInt16(this, value, offset, false);
      }
      return offset + 2
    };

    Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value & 0xff);
        this[offset + 1] = (value >>> 8);
        this[offset + 2] = (value >>> 16);
        this[offset + 3] = (value >>> 24);
      } else {
        objectWriteUInt32(this, value, offset, true);
      }
      return offset + 4
    };

    Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
      if (value < 0) value = 0xffffffff + value + 1;
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value >>> 24);
        this[offset + 1] = (value >>> 16);
        this[offset + 2] = (value >>> 8);
        this[offset + 3] = (value & 0xff);
      } else {
        objectWriteUInt32(this, value, offset, false);
      }
      return offset + 4
    };

    function checkIEEE754 (buf, value, offset, ext, max, min) {
      if (offset + ext > buf.length) throw new RangeError('Index out of range')
      if (offset < 0) throw new RangeError('Index out of range')
    }

    function writeFloat (buf, value, offset, littleEndian, noAssert) {
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 4);
      }
      write(buf, value, offset, littleEndian, 23, 4);
      return offset + 4
    }

    Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert)
    };

    Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert)
    };

    function writeDouble (buf, value, offset, littleEndian, noAssert) {
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 8);
      }
      write(buf, value, offset, littleEndian, 52, 8);
      return offset + 8
    }

    Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert)
    };

    Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert)
    };

    // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
    Buffer.prototype.copy = function copy (target, targetStart, start, end) {
      if (!start) start = 0;
      if (!end && end !== 0) end = this.length;
      if (targetStart >= target.length) targetStart = target.length;
      if (!targetStart) targetStart = 0;
      if (end > 0 && end < start) end = start;

      // Copy 0 bytes; we're done
      if (end === start) return 0
      if (target.length === 0 || this.length === 0) return 0

      // Fatal error conditions
      if (targetStart < 0) {
        throw new RangeError('targetStart out of bounds')
      }
      if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
      if (end < 0) throw new RangeError('sourceEnd out of bounds')

      // Are we oob?
      if (end > this.length) end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }

      var len = end - start;
      var i;

      if (this === target && start < targetStart && targetStart < end) {
        // descending copy from end
        for (i = len - 1; i >= 0; --i) {
          target[i + targetStart] = this[i + start];
        }
      } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
        // ascending copy from start
        for (i = 0; i < len; ++i) {
          target[i + targetStart] = this[i + start];
        }
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, start + len),
          targetStart
        );
      }

      return len
    };

    // Usage:
    //    buffer.fill(number[, offset[, end]])
    //    buffer.fill(buffer[, offset[, end]])
    //    buffer.fill(string[, offset[, end]][, encoding])
    Buffer.prototype.fill = function fill (val, start, end, encoding) {
      // Handle string cases:
      if (typeof val === 'string') {
        if (typeof start === 'string') {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === 'string') {
          encoding = end;
          end = this.length;
        }
        if (val.length === 1) {
          var code = val.charCodeAt(0);
          if (code < 256) {
            val = code;
          }
        }
        if (encoding !== undefined && typeof encoding !== 'string') {
          throw new TypeError('encoding must be a string')
        }
        if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
          throw new TypeError('Unknown encoding: ' + encoding)
        }
      } else if (typeof val === 'number') {
        val = val & 255;
      }

      // Invalid ranges are not set to a default, so can range check early.
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError('Out of range index')
      }

      if (end <= start) {
        return this
      }

      start = start >>> 0;
      end = end === undefined ? this.length : end >>> 0;

      if (!val) val = 0;

      var i;
      if (typeof val === 'number') {
        for (i = start; i < end; ++i) {
          this[i] = val;
        }
      } else {
        var bytes = internalIsBuffer(val)
          ? val
          : utf8ToBytes(new Buffer(val, encoding).toString());
        var len = bytes.length;
        for (i = 0; i < end - start; ++i) {
          this[i + start] = bytes[i % len];
        }
      }

      return this
    };

    // HELPER FUNCTIONS
    // ================

    var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

    function base64clean (str) {
      // Node strips out invalid characters like \n and \t from the string, base64-js does not
      str = stringtrim(str).replace(INVALID_BASE64_RE, '');
      // Node converts strings with length < 2 to ''
      if (str.length < 2) return ''
      // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
      while (str.length % 4 !== 0) {
        str = str + '=';
      }
      return str
    }

    function stringtrim (str) {
      if (str.trim) return str.trim()
      return str.replace(/^\s+|\s+$/g, '')
    }

    function toHex (n) {
      if (n < 16) return '0' + n.toString(16)
      return n.toString(16)
    }

    function utf8ToBytes (string, units) {
      units = units || Infinity;
      var codePoint;
      var length = string.length;
      var leadSurrogate = null;
      var bytes = [];

      for (var i = 0; i < length; ++i) {
        codePoint = string.charCodeAt(i);

        // is surrogate component
        if (codePoint > 0xD7FF && codePoint < 0xE000) {
          // last char was a lead
          if (!leadSurrogate) {
            // no lead yet
            if (codePoint > 0xDBFF) {
              // unexpected trail
              if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
              continue
            } else if (i + 1 === length) {
              // unpaired lead
              if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
              continue
            }

            // valid lead
            leadSurrogate = codePoint;

            continue
          }

          // 2 leads in a row
          if (codePoint < 0xDC00) {
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
            leadSurrogate = codePoint;
            continue
          }

          // valid surrogate pair
          codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
        } else if (leadSurrogate) {
          // valid bmp char, but last char was a lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        }

        leadSurrogate = null;

        // encode utf8
        if (codePoint < 0x80) {
          if ((units -= 1) < 0) break
          bytes.push(codePoint);
        } else if (codePoint < 0x800) {
          if ((units -= 2) < 0) break
          bytes.push(
            codePoint >> 0x6 | 0xC0,
            codePoint & 0x3F | 0x80
          );
        } else if (codePoint < 0x10000) {
          if ((units -= 3) < 0) break
          bytes.push(
            codePoint >> 0xC | 0xE0,
            codePoint >> 0x6 & 0x3F | 0x80,
            codePoint & 0x3F | 0x80
          );
        } else if (codePoint < 0x110000) {
          if ((units -= 4) < 0) break
          bytes.push(
            codePoint >> 0x12 | 0xF0,
            codePoint >> 0xC & 0x3F | 0x80,
            codePoint >> 0x6 & 0x3F | 0x80,
            codePoint & 0x3F | 0x80
          );
        } else {
          throw new Error('Invalid code point')
        }
      }

      return bytes
    }

    function asciiToBytes (str) {
      var byteArray = [];
      for (var i = 0; i < str.length; ++i) {
        // Node's code seems to be doing this and not & 0x7F..
        byteArray.push(str.charCodeAt(i) & 0xFF);
      }
      return byteArray
    }

    function utf16leToBytes (str, units) {
      var c, hi, lo;
      var byteArray = [];
      for (var i = 0; i < str.length; ++i) {
        if ((units -= 2) < 0) break

        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }

      return byteArray
    }


    function base64ToBytes (str) {
      return toByteArray(base64clean(str))
    }

    function blitBuffer (src, dst, offset, length) {
      for (var i = 0; i < length; ++i) {
        if ((i + offset >= dst.length) || (i >= src.length)) break
        dst[i + offset] = src[i];
      }
      return i
    }

    function isnan (val) {
      return val !== val // eslint-disable-line no-self-compare
    }


    // the following is from is-buffer, also by Feross Aboukhadijeh and with same lisence
    // The _isBuffer check is for Safari 5-7 support, because it's missing
    // Object.prototype.constructor. Remove this eventually
    function isBuffer(obj) {
      return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj))
    }

    function isFastBuffer (obj) {
      return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
    }

    // For Node v0.10 support. Remove this eventually.
    function isSlowBuffer (obj) {
      return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isFastBuffer(obj.slice(0, 0))
    }

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function unwrapExports (x) {
    	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
    }

    function createCommonjsModule(fn, module) {
    	return module = { exports: {} }, fn(module, module.exports), module.exports;
    }

    var quill = createCommonjsModule(function (module, exports) {
    /*!
     * Quill Editor v1.3.7
     * https://quilljs.com/
     * Copyright (c) 2014, Jason Chen
     * Copyright (c) 2013, salesforce.com
     */
    (function webpackUniversalModuleDefinition(root, factory) {
    	module.exports = factory();
    })(typeof self !== 'undefined' ? self : commonjsGlobal, function() {
    return /******/ (function(modules) { // webpackBootstrap
    /******/ 	// The module cache
    /******/ 	var installedModules = {};
    /******/
    /******/ 	// The require function
    /******/ 	function __webpack_require__(moduleId) {
    /******/
    /******/ 		// Check if module is in cache
    /******/ 		if(installedModules[moduleId]) {
    /******/ 			return installedModules[moduleId].exports;
    /******/ 		}
    /******/ 		// Create a new module (and put it into the cache)
    /******/ 		var module = installedModules[moduleId] = {
    /******/ 			i: moduleId,
    /******/ 			l: false,
    /******/ 			exports: {}
    /******/ 		};
    /******/
    /******/ 		// Execute the module function
    /******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
    /******/
    /******/ 		// Flag the module as loaded
    /******/ 		module.l = true;
    /******/
    /******/ 		// Return the exports of the module
    /******/ 		return module.exports;
    /******/ 	}
    /******/
    /******/
    /******/ 	// expose the modules object (__webpack_modules__)
    /******/ 	__webpack_require__.m = modules;
    /******/
    /******/ 	// expose the module cache
    /******/ 	__webpack_require__.c = installedModules;
    /******/
    /******/ 	// define getter function for harmony exports
    /******/ 	__webpack_require__.d = function(exports, name, getter) {
    /******/ 		if(!__webpack_require__.o(exports, name)) {
    /******/ 			Object.defineProperty(exports, name, {
    /******/ 				configurable: false,
    /******/ 				enumerable: true,
    /******/ 				get: getter
    /******/ 			});
    /******/ 		}
    /******/ 	};
    /******/
    /******/ 	// getDefaultExport function for compatibility with non-harmony modules
    /******/ 	__webpack_require__.n = function(module) {
    /******/ 		var getter = module && module.__esModule ?
    /******/ 			function getDefault() { return module['default']; } :
    /******/ 			function getModuleExports() { return module; };
    /******/ 		__webpack_require__.d(getter, 'a', getter);
    /******/ 		return getter;
    /******/ 	};
    /******/
    /******/ 	// Object.prototype.hasOwnProperty.call
    /******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
    /******/
    /******/ 	// __webpack_public_path__
    /******/ 	__webpack_require__.p = "";
    /******/
    /******/ 	// Load entry module and return exports
    /******/ 	return __webpack_require__(__webpack_require__.s = 109);
    /******/ })
    /************************************************************************/
    /******/ ([
    /* 0 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    var container_1 = __webpack_require__(17);
    var format_1 = __webpack_require__(18);
    var leaf_1 = __webpack_require__(19);
    var scroll_1 = __webpack_require__(45);
    var inline_1 = __webpack_require__(46);
    var block_1 = __webpack_require__(47);
    var embed_1 = __webpack_require__(48);
    var text_1 = __webpack_require__(49);
    var attributor_1 = __webpack_require__(12);
    var class_1 = __webpack_require__(32);
    var style_1 = __webpack_require__(33);
    var store_1 = __webpack_require__(31);
    var Registry = __webpack_require__(1);
    var Parchment = {
        Scope: Registry.Scope,
        create: Registry.create,
        find: Registry.find,
        query: Registry.query,
        register: Registry.register,
        Container: container_1.default,
        Format: format_1.default,
        Leaf: leaf_1.default,
        Embed: embed_1.default,
        Scroll: scroll_1.default,
        Block: block_1.default,
        Inline: inline_1.default,
        Text: text_1.default,
        Attributor: {
            Attribute: attributor_1.default,
            Class: class_1.default,
            Style: style_1.default,
            Store: store_1.default,
        },
    };
    exports.default = Parchment;


    /***/ }),
    /* 1 */
    /***/ (function(module, exports, __webpack_require__) {

    var __extends = (this && this.__extends) || (function () {
        var extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    Object.defineProperty(exports, "__esModule", { value: true });
    var ParchmentError = /** @class */ (function (_super) {
        __extends(ParchmentError, _super);
        function ParchmentError(message) {
            var _this = this;
            message = '[Parchment] ' + message;
            _this = _super.call(this, message) || this;
            _this.message = message;
            _this.name = _this.constructor.name;
            return _this;
        }
        return ParchmentError;
    }(Error));
    exports.ParchmentError = ParchmentError;
    var attributes = {};
    var classes = {};
    var tags = {};
    var types = {};
    exports.DATA_KEY = '__blot';
    var Scope;
    (function (Scope) {
        Scope[Scope["TYPE"] = 3] = "TYPE";
        Scope[Scope["LEVEL"] = 12] = "LEVEL";
        Scope[Scope["ATTRIBUTE"] = 13] = "ATTRIBUTE";
        Scope[Scope["BLOT"] = 14] = "BLOT";
        Scope[Scope["INLINE"] = 7] = "INLINE";
        Scope[Scope["BLOCK"] = 11] = "BLOCK";
        Scope[Scope["BLOCK_BLOT"] = 10] = "BLOCK_BLOT";
        Scope[Scope["INLINE_BLOT"] = 6] = "INLINE_BLOT";
        Scope[Scope["BLOCK_ATTRIBUTE"] = 9] = "BLOCK_ATTRIBUTE";
        Scope[Scope["INLINE_ATTRIBUTE"] = 5] = "INLINE_ATTRIBUTE";
        Scope[Scope["ANY"] = 15] = "ANY";
    })(Scope = exports.Scope || (exports.Scope = {}));
    function create(input, value) {
        var match = query(input);
        if (match == null) {
            throw new ParchmentError("Unable to create " + input + " blot");
        }
        var BlotClass = match;
        var node = 
        // @ts-ignore
        input instanceof Node || input['nodeType'] === Node.TEXT_NODE ? input : BlotClass.create(value);
        return new BlotClass(node, value);
    }
    exports.create = create;
    function find(node, bubble) {
        if (bubble === void 0) { bubble = false; }
        if (node == null)
            return null;
        // @ts-ignore
        if (node[exports.DATA_KEY] != null)
            return node[exports.DATA_KEY].blot;
        if (bubble)
            return find(node.parentNode, bubble);
        return null;
    }
    exports.find = find;
    function query(query, scope) {
        if (scope === void 0) { scope = Scope.ANY; }
        var match;
        if (typeof query === 'string') {
            match = types[query] || attributes[query];
            // @ts-ignore
        }
        else if (query instanceof Text || query['nodeType'] === Node.TEXT_NODE) {
            match = types['text'];
        }
        else if (typeof query === 'number') {
            if (query & Scope.LEVEL & Scope.BLOCK) {
                match = types['block'];
            }
            else if (query & Scope.LEVEL & Scope.INLINE) {
                match = types['inline'];
            }
        }
        else if (query instanceof HTMLElement) {
            var names = (query.getAttribute('class') || '').split(/\s+/);
            for (var i in names) {
                match = classes[names[i]];
                if (match)
                    break;
            }
            match = match || tags[query.tagName];
        }
        if (match == null)
            return null;
        // @ts-ignore
        if (scope & Scope.LEVEL & match.scope && scope & Scope.TYPE & match.scope)
            return match;
        return null;
    }
    exports.query = query;
    function register() {
        var Definitions = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            Definitions[_i] = arguments[_i];
        }
        if (Definitions.length > 1) {
            return Definitions.map(function (d) {
                return register(d);
            });
        }
        var Definition = Definitions[0];
        if (typeof Definition.blotName !== 'string' && typeof Definition.attrName !== 'string') {
            throw new ParchmentError('Invalid definition');
        }
        else if (Definition.blotName === 'abstract') {
            throw new ParchmentError('Cannot register abstract class');
        }
        types[Definition.blotName || Definition.attrName] = Definition;
        if (typeof Definition.keyName === 'string') {
            attributes[Definition.keyName] = Definition;
        }
        else {
            if (Definition.className != null) {
                classes[Definition.className] = Definition;
            }
            if (Definition.tagName != null) {
                if (Array.isArray(Definition.tagName)) {
                    Definition.tagName = Definition.tagName.map(function (tagName) {
                        return tagName.toUpperCase();
                    });
                }
                else {
                    Definition.tagName = Definition.tagName.toUpperCase();
                }
                var tagNames = Array.isArray(Definition.tagName) ? Definition.tagName : [Definition.tagName];
                tagNames.forEach(function (tag) {
                    if (tags[tag] == null || Definition.className == null) {
                        tags[tag] = Definition;
                    }
                });
            }
        }
        return Definition;
    }
    exports.register = register;


    /***/ }),
    /* 2 */
    /***/ (function(module, exports, __webpack_require__) {

    var diff = __webpack_require__(51);
    var equal = __webpack_require__(11);
    var extend = __webpack_require__(3);
    var op = __webpack_require__(20);


    var NULL_CHARACTER = String.fromCharCode(0);  // Placeholder char for embed in diff()


    var Delta = function (ops) {
      // Assume we are given a well formed ops
      if (Array.isArray(ops)) {
        this.ops = ops;
      } else if (ops != null && Array.isArray(ops.ops)) {
        this.ops = ops.ops;
      } else {
        this.ops = [];
      }
    };


    Delta.prototype.insert = function (text, attributes) {
      var newOp = {};
      if (text.length === 0) return this;
      newOp.insert = text;
      if (attributes != null && typeof attributes === 'object' && Object.keys(attributes).length > 0) {
        newOp.attributes = attributes;
      }
      return this.push(newOp);
    };

    Delta.prototype['delete'] = function (length) {
      if (length <= 0) return this;
      return this.push({ 'delete': length });
    };

    Delta.prototype.retain = function (length, attributes) {
      if (length <= 0) return this;
      var newOp = { retain: length };
      if (attributes != null && typeof attributes === 'object' && Object.keys(attributes).length > 0) {
        newOp.attributes = attributes;
      }
      return this.push(newOp);
    };

    Delta.prototype.push = function (newOp) {
      var index = this.ops.length;
      var lastOp = this.ops[index - 1];
      newOp = extend(true, {}, newOp);
      if (typeof lastOp === 'object') {
        if (typeof newOp['delete'] === 'number' && typeof lastOp['delete'] === 'number') {
          this.ops[index - 1] = { 'delete': lastOp['delete'] + newOp['delete'] };
          return this;
        }
        // Since it does not matter if we insert before or after deleting at the same index,
        // always prefer to insert first
        if (typeof lastOp['delete'] === 'number' && newOp.insert != null) {
          index -= 1;
          lastOp = this.ops[index - 1];
          if (typeof lastOp !== 'object') {
            this.ops.unshift(newOp);
            return this;
          }
        }
        if (equal(newOp.attributes, lastOp.attributes)) {
          if (typeof newOp.insert === 'string' && typeof lastOp.insert === 'string') {
            this.ops[index - 1] = { insert: lastOp.insert + newOp.insert };
            if (typeof newOp.attributes === 'object') this.ops[index - 1].attributes = newOp.attributes;
            return this;
          } else if (typeof newOp.retain === 'number' && typeof lastOp.retain === 'number') {
            this.ops[index - 1] = { retain: lastOp.retain + newOp.retain };
            if (typeof newOp.attributes === 'object') this.ops[index - 1].attributes = newOp.attributes;
            return this;
          }
        }
      }
      if (index === this.ops.length) {
        this.ops.push(newOp);
      } else {
        this.ops.splice(index, 0, newOp);
      }
      return this;
    };

    Delta.prototype.chop = function () {
      var lastOp = this.ops[this.ops.length - 1];
      if (lastOp && lastOp.retain && !lastOp.attributes) {
        this.ops.pop();
      }
      return this;
    };

    Delta.prototype.filter = function (predicate) {
      return this.ops.filter(predicate);
    };

    Delta.prototype.forEach = function (predicate) {
      this.ops.forEach(predicate);
    };

    Delta.prototype.map = function (predicate) {
      return this.ops.map(predicate);
    };

    Delta.prototype.partition = function (predicate) {
      var passed = [], failed = [];
      this.forEach(function(op) {
        var target = predicate(op) ? passed : failed;
        target.push(op);
      });
      return [passed, failed];
    };

    Delta.prototype.reduce = function (predicate, initial) {
      return this.ops.reduce(predicate, initial);
    };

    Delta.prototype.changeLength = function () {
      return this.reduce(function (length, elem) {
        if (elem.insert) {
          return length + op.length(elem);
        } else if (elem.delete) {
          return length - elem.delete;
        }
        return length;
      }, 0);
    };

    Delta.prototype.length = function () {
      return this.reduce(function (length, elem) {
        return length + op.length(elem);
      }, 0);
    };

    Delta.prototype.slice = function (start, end) {
      start = start || 0;
      if (typeof end !== 'number') end = Infinity;
      var ops = [];
      var iter = op.iterator(this.ops);
      var index = 0;
      while (index < end && iter.hasNext()) {
        var nextOp;
        if (index < start) {
          nextOp = iter.next(start - index);
        } else {
          nextOp = iter.next(end - index);
          ops.push(nextOp);
        }
        index += op.length(nextOp);
      }
      return new Delta(ops);
    };


    Delta.prototype.compose = function (other) {
      var thisIter = op.iterator(this.ops);
      var otherIter = op.iterator(other.ops);
      var ops = [];
      var firstOther = otherIter.peek();
      if (firstOther != null && typeof firstOther.retain === 'number' && firstOther.attributes == null) {
        var firstLeft = firstOther.retain;
        while (thisIter.peekType() === 'insert' && thisIter.peekLength() <= firstLeft) {
          firstLeft -= thisIter.peekLength();
          ops.push(thisIter.next());
        }
        if (firstOther.retain - firstLeft > 0) {
          otherIter.next(firstOther.retain - firstLeft);
        }
      }
      var delta = new Delta(ops);
      while (thisIter.hasNext() || otherIter.hasNext()) {
        if (otherIter.peekType() === 'insert') {
          delta.push(otherIter.next());
        } else if (thisIter.peekType() === 'delete') {
          delta.push(thisIter.next());
        } else {
          var length = Math.min(thisIter.peekLength(), otherIter.peekLength());
          var thisOp = thisIter.next(length);
          var otherOp = otherIter.next(length);
          if (typeof otherOp.retain === 'number') {
            var newOp = {};
            if (typeof thisOp.retain === 'number') {
              newOp.retain = length;
            } else {
              newOp.insert = thisOp.insert;
            }
            // Preserve null when composing with a retain, otherwise remove it for inserts
            var attributes = op.attributes.compose(thisOp.attributes, otherOp.attributes, typeof thisOp.retain === 'number');
            if (attributes) newOp.attributes = attributes;
            delta.push(newOp);

            // Optimization if rest of other is just retain
            if (!otherIter.hasNext() && equal(delta.ops[delta.ops.length - 1], newOp)) {
              var rest = new Delta(thisIter.rest());
              return delta.concat(rest).chop();
            }

          // Other op should be delete, we could be an insert or retain
          // Insert + delete cancels out
          } else if (typeof otherOp['delete'] === 'number' && typeof thisOp.retain === 'number') {
            delta.push(otherOp);
          }
        }
      }
      return delta.chop();
    };

    Delta.prototype.concat = function (other) {
      var delta = new Delta(this.ops.slice());
      if (other.ops.length > 0) {
        delta.push(other.ops[0]);
        delta.ops = delta.ops.concat(other.ops.slice(1));
      }
      return delta;
    };

    Delta.prototype.diff = function (other, index) {
      if (this.ops === other.ops) {
        return new Delta();
      }
      var strings = [this, other].map(function (delta) {
        return delta.map(function (op) {
          if (op.insert != null) {
            return typeof op.insert === 'string' ? op.insert : NULL_CHARACTER;
          }
          var prep = (delta === other) ? 'on' : 'with';
          throw new Error('diff() called ' + prep + ' non-document');
        }).join('');
      });
      var delta = new Delta();
      var diffResult = diff(strings[0], strings[1], index);
      var thisIter = op.iterator(this.ops);
      var otherIter = op.iterator(other.ops);
      diffResult.forEach(function (component) {
        var length = component[1].length;
        while (length > 0) {
          var opLength = 0;
          switch (component[0]) {
            case diff.INSERT:
              opLength = Math.min(otherIter.peekLength(), length);
              delta.push(otherIter.next(opLength));
              break;
            case diff.DELETE:
              opLength = Math.min(length, thisIter.peekLength());
              thisIter.next(opLength);
              delta['delete'](opLength);
              break;
            case diff.EQUAL:
              opLength = Math.min(thisIter.peekLength(), otherIter.peekLength(), length);
              var thisOp = thisIter.next(opLength);
              var otherOp = otherIter.next(opLength);
              if (equal(thisOp.insert, otherOp.insert)) {
                delta.retain(opLength, op.attributes.diff(thisOp.attributes, otherOp.attributes));
              } else {
                delta.push(otherOp)['delete'](opLength);
              }
              break;
          }
          length -= opLength;
        }
      });
      return delta.chop();
    };

    Delta.prototype.eachLine = function (predicate, newline) {
      newline = newline || '\n';
      var iter = op.iterator(this.ops);
      var line = new Delta();
      var i = 0;
      while (iter.hasNext()) {
        if (iter.peekType() !== 'insert') return;
        var thisOp = iter.peek();
        var start = op.length(thisOp) - iter.peekLength();
        var index = typeof thisOp.insert === 'string' ?
          thisOp.insert.indexOf(newline, start) - start : -1;
        if (index < 0) {
          line.push(iter.next());
        } else if (index > 0) {
          line.push(iter.next(index));
        } else {
          if (predicate(line, iter.next(1).attributes || {}, i) === false) {
            return;
          }
          i += 1;
          line = new Delta();
        }
      }
      if (line.length() > 0) {
        predicate(line, {}, i);
      }
    };

    Delta.prototype.transform = function (other, priority) {
      priority = !!priority;
      if (typeof other === 'number') {
        return this.transformPosition(other, priority);
      }
      var thisIter = op.iterator(this.ops);
      var otherIter = op.iterator(other.ops);
      var delta = new Delta();
      while (thisIter.hasNext() || otherIter.hasNext()) {
        if (thisIter.peekType() === 'insert' && (priority || otherIter.peekType() !== 'insert')) {
          delta.retain(op.length(thisIter.next()));
        } else if (otherIter.peekType() === 'insert') {
          delta.push(otherIter.next());
        } else {
          var length = Math.min(thisIter.peekLength(), otherIter.peekLength());
          var thisOp = thisIter.next(length);
          var otherOp = otherIter.next(length);
          if (thisOp['delete']) {
            // Our delete either makes their delete redundant or removes their retain
            continue;
          } else if (otherOp['delete']) {
            delta.push(otherOp);
          } else {
            // We retain either their retain or insert
            delta.retain(length, op.attributes.transform(thisOp.attributes, otherOp.attributes, priority));
          }
        }
      }
      return delta.chop();
    };

    Delta.prototype.transformPosition = function (index, priority) {
      priority = !!priority;
      var thisIter = op.iterator(this.ops);
      var offset = 0;
      while (thisIter.hasNext() && offset <= index) {
        var length = thisIter.peekLength();
        var nextType = thisIter.peekType();
        thisIter.next();
        if (nextType === 'delete') {
          index -= Math.min(length, index - offset);
          continue;
        } else if (nextType === 'insert' && (offset < index || !priority)) {
          index += length;
        }
        offset += length;
      }
      return index;
    };


    module.exports = Delta;


    /***/ }),
    /* 3 */
    /***/ (function(module, exports) {

    var hasOwn = Object.prototype.hasOwnProperty;
    var toStr = Object.prototype.toString;
    var defineProperty = Object.defineProperty;
    var gOPD = Object.getOwnPropertyDescriptor;

    var isArray = function isArray(arr) {
    	if (typeof Array.isArray === 'function') {
    		return Array.isArray(arr);
    	}

    	return toStr.call(arr) === '[object Array]';
    };

    var isPlainObject = function isPlainObject(obj) {
    	if (!obj || toStr.call(obj) !== '[object Object]') {
    		return false;
    	}

    	var hasOwnConstructor = hasOwn.call(obj, 'constructor');
    	var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');
    	// Not own constructor property must be Object
    	if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
    		return false;
    	}

    	// Own properties are enumerated firstly, so to speed up,
    	// if last one is own, then all properties are own.
    	var key;
    	for (key in obj) { /**/ }

    	return typeof key === 'undefined' || hasOwn.call(obj, key);
    };

    // If name is '__proto__', and Object.defineProperty is available, define __proto__ as an own property on target
    var setProperty = function setProperty(target, options) {
    	if (defineProperty && options.name === '__proto__') {
    		defineProperty(target, options.name, {
    			enumerable: true,
    			configurable: true,
    			value: options.newValue,
    			writable: true
    		});
    	} else {
    		target[options.name] = options.newValue;
    	}
    };

    // Return undefined instead of __proto__ if '__proto__' is not an own property
    var getProperty = function getProperty(obj, name) {
    	if (name === '__proto__') {
    		if (!hasOwn.call(obj, name)) {
    			return void 0;
    		} else if (gOPD) {
    			// In early versions of node, obj['__proto__'] is buggy when obj has
    			// __proto__ as an own property. Object.getOwnPropertyDescriptor() works.
    			return gOPD(obj, name).value;
    		}
    	}

    	return obj[name];
    };

    module.exports = function extend() {
    	var options, name, src, copy, copyIsArray, clone;
    	var target = arguments[0];
    	var i = 1;
    	var length = arguments.length;
    	var deep = false;

    	// Handle a deep copy situation
    	if (typeof target === 'boolean') {
    		deep = target;
    		target = arguments[1] || {};
    		// skip the boolean and the target
    		i = 2;
    	}
    	if (target == null || (typeof target !== 'object' && typeof target !== 'function')) {
    		target = {};
    	}

    	for (; i < length; ++i) {
    		options = arguments[i];
    		// Only deal with non-null/undefined values
    		if (options != null) {
    			// Extend the base object
    			for (name in options) {
    				src = getProperty(target, name);
    				copy = getProperty(options, name);

    				// Prevent never-ending loop
    				if (target !== copy) {
    					// Recurse if we're merging plain objects or arrays
    					if (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {
    						if (copyIsArray) {
    							copyIsArray = false;
    							clone = src && isArray(src) ? src : [];
    						} else {
    							clone = src && isPlainObject(src) ? src : {};
    						}

    						// Never move original objects, clone them
    						setProperty(target, { name: name, newValue: extend(deep, clone, copy) });

    					// Don't bring in undefined values
    					} else if (typeof copy !== 'undefined') {
    						setProperty(target, { name: name, newValue: copy });
    					}
    				}
    			}
    		}
    	}

    	// Return the modified object
    	return target;
    };


    /***/ }),
    /* 4 */
    /***/ (function(module, exports, __webpack_require__) {


    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = exports.BlockEmbed = exports.bubbleFormats = undefined;

    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

    var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

    var _extend = __webpack_require__(3);

    var _extend2 = _interopRequireDefault(_extend);

    var _quillDelta = __webpack_require__(2);

    var _quillDelta2 = _interopRequireDefault(_quillDelta);

    var _parchment = __webpack_require__(0);

    var _parchment2 = _interopRequireDefault(_parchment);

    var _break = __webpack_require__(16);

    var _break2 = _interopRequireDefault(_break);

    var _inline = __webpack_require__(6);

    var _inline2 = _interopRequireDefault(_inline);

    var _text = __webpack_require__(7);

    var _text2 = _interopRequireDefault(_text);

    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    var NEWLINE_LENGTH = 1;

    var BlockEmbed = function (_Parchment$Embed) {
      _inherits(BlockEmbed, _Parchment$Embed);

      function BlockEmbed() {
        _classCallCheck(this, BlockEmbed);

        return _possibleConstructorReturn(this, (BlockEmbed.__proto__ || Object.getPrototypeOf(BlockEmbed)).apply(this, arguments));
      }

      _createClass(BlockEmbed, [{
        key: 'attach',
        value: function attach() {
          _get(BlockEmbed.prototype.__proto__ || Object.getPrototypeOf(BlockEmbed.prototype), 'attach', this).call(this);
          this.attributes = new _parchment2.default.Attributor.Store(this.domNode);
        }
      }, {
        key: 'delta',
        value: function delta() {
          return new _quillDelta2.default().insert(this.value(), (0, _extend2.default)(this.formats(), this.attributes.values()));
        }
      }, {
        key: 'format',
        value: function format(name, value) {
          var attribute = _parchment2.default.query(name, _parchment2.default.Scope.BLOCK_ATTRIBUTE);
          if (attribute != null) {
            this.attributes.attribute(attribute, value);
          }
        }
      }, {
        key: 'formatAt',
        value: function formatAt(index, length, name, value) {
          this.format(name, value);
        }
      }, {
        key: 'insertAt',
        value: function insertAt(index, value, def) {
          if (typeof value === 'string' && value.endsWith('\n')) {
            var block = _parchment2.default.create(Block.blotName);
            this.parent.insertBefore(block, index === 0 ? this : this.next);
            block.insertAt(0, value.slice(0, -1));
          } else {
            _get(BlockEmbed.prototype.__proto__ || Object.getPrototypeOf(BlockEmbed.prototype), 'insertAt', this).call(this, index, value, def);
          }
        }
      }]);

      return BlockEmbed;
    }(_parchment2.default.Embed);

    BlockEmbed.scope = _parchment2.default.Scope.BLOCK_BLOT;
    // It is important for cursor behavior BlockEmbeds use tags that are block level elements


    var Block = function (_Parchment$Block) {
      _inherits(Block, _Parchment$Block);

      function Block(domNode) {
        _classCallCheck(this, Block);

        var _this2 = _possibleConstructorReturn(this, (Block.__proto__ || Object.getPrototypeOf(Block)).call(this, domNode));

        _this2.cache = {};
        return _this2;
      }

      _createClass(Block, [{
        key: 'delta',
        value: function delta() {
          if (this.cache.delta == null) {
            this.cache.delta = this.descendants(_parchment2.default.Leaf).reduce(function (delta, leaf) {
              if (leaf.length() === 0) {
                return delta;
              } else {
                return delta.insert(leaf.value(), bubbleFormats(leaf));
              }
            }, new _quillDelta2.default()).insert('\n', bubbleFormats(this));
          }
          return this.cache.delta;
        }
      }, {
        key: 'deleteAt',
        value: function deleteAt(index, length) {
          _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), 'deleteAt', this).call(this, index, length);
          this.cache = {};
        }
      }, {
        key: 'formatAt',
        value: function formatAt(index, length, name, value) {
          if (length <= 0) return;
          if (_parchment2.default.query(name, _parchment2.default.Scope.BLOCK)) {
            if (index + length === this.length()) {
              this.format(name, value);
            }
          } else {
            _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), 'formatAt', this).call(this, index, Math.min(length, this.length() - index - 1), name, value);
          }
          this.cache = {};
        }
      }, {
        key: 'insertAt',
        value: function insertAt(index, value, def) {
          if (def != null) return _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), 'insertAt', this).call(this, index, value, def);
          if (value.length === 0) return;
          var lines = value.split('\n');
          var text = lines.shift();
          if (text.length > 0) {
            if (index < this.length() - 1 || this.children.tail == null) {
              _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), 'insertAt', this).call(this, Math.min(index, this.length() - 1), text);
            } else {
              this.children.tail.insertAt(this.children.tail.length(), text);
            }
            this.cache = {};
          }
          var block = this;
          lines.reduce(function (index, line) {
            block = block.split(index, true);
            block.insertAt(0, line);
            return line.length;
          }, index + text.length);
        }
      }, {
        key: 'insertBefore',
        value: function insertBefore(blot, ref) {
          var head = this.children.head;
          _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), 'insertBefore', this).call(this, blot, ref);
          if (head instanceof _break2.default) {
            head.remove();
          }
          this.cache = {};
        }
      }, {
        key: 'length',
        value: function length() {
          if (this.cache.length == null) {
            this.cache.length = _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), 'length', this).call(this) + NEWLINE_LENGTH;
          }
          return this.cache.length;
        }
      }, {
        key: 'moveChildren',
        value: function moveChildren(target, ref) {
          _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), 'moveChildren', this).call(this, target, ref);
          this.cache = {};
        }
      }, {
        key: 'optimize',
        value: function optimize(context) {
          _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), 'optimize', this).call(this, context);
          this.cache = {};
        }
      }, {
        key: 'path',
        value: function path(index) {
          return _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), 'path', this).call(this, index, true);
        }
      }, {
        key: 'removeChild',
        value: function removeChild(child) {
          _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), 'removeChild', this).call(this, child);
          this.cache = {};
        }
      }, {
        key: 'split',
        value: function split(index) {
          var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

          if (force && (index === 0 || index >= this.length() - NEWLINE_LENGTH)) {
            var clone = this.clone();
            if (index === 0) {
              this.parent.insertBefore(clone, this);
              return this;
            } else {
              this.parent.insertBefore(clone, this.next);
              return clone;
            }
          } else {
            var next = _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), 'split', this).call(this, index, force);
            this.cache = {};
            return next;
          }
        }
      }]);

      return Block;
    }(_parchment2.default.Block);

    Block.blotName = 'block';
    Block.tagName = 'P';
    Block.defaultChild = 'break';
    Block.allowedChildren = [_inline2.default, _parchment2.default.Embed, _text2.default];

    function bubbleFormats(blot) {
      var formats = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (blot == null) return formats;
      if (typeof blot.formats === 'function') {
        formats = (0, _extend2.default)(formats, blot.formats());
      }
      if (blot.parent == null || blot.parent.blotName == 'scroll' || blot.parent.statics.scope !== blot.statics.scope) {
        return formats;
      }
      return bubbleFormats(blot.parent, formats);
    }

    exports.bubbleFormats = bubbleFormats;
    exports.BlockEmbed = BlockEmbed;
    exports.default = Block;

    /***/ }),
    /* 5 */
    /***/ (function(module, exports, __webpack_require__) {


    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = exports.overload = exports.expandConfig = undefined;

    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

    var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

    __webpack_require__(50);

    var _quillDelta = __webpack_require__(2);

    var _quillDelta2 = _interopRequireDefault(_quillDelta);

    var _editor = __webpack_require__(14);

    var _editor2 = _interopRequireDefault(_editor);

    var _emitter3 = __webpack_require__(8);

    var _emitter4 = _interopRequireDefault(_emitter3);

    var _module = __webpack_require__(9);

    var _module2 = _interopRequireDefault(_module);

    var _parchment = __webpack_require__(0);

    var _parchment2 = _interopRequireDefault(_parchment);

    var _selection = __webpack_require__(15);

    var _selection2 = _interopRequireDefault(_selection);

    var _extend = __webpack_require__(3);

    var _extend2 = _interopRequireDefault(_extend);

    var _logger = __webpack_require__(10);

    var _logger2 = _interopRequireDefault(_logger);

    var _theme = __webpack_require__(34);

    var _theme2 = _interopRequireDefault(_theme);

    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    var debug = (0, _logger2.default)('quill');

    var Quill = function () {
      _createClass(Quill, null, [{
        key: 'debug',
        value: function debug(limit) {
          if (limit === true) {
            limit = 'log';
          }
          _logger2.default.level(limit);
        }
      }, {
        key: 'find',
        value: function find(node) {
          return node.__quill || _parchment2.default.find(node);
        }
      }, {
        key: 'import',
        value: function _import(name) {
          if (this.imports[name] == null) {
            debug.error('Cannot import ' + name + '. Are you sure it was registered?');
          }
          return this.imports[name];
        }
      }, {
        key: 'register',
        value: function register(path, target) {
          var _this = this;

          var overwrite = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

          if (typeof path !== 'string') {
            var name = path.attrName || path.blotName;
            if (typeof name === 'string') {
              // register(Blot | Attributor, overwrite)
              this.register('formats/' + name, path, target);
            } else {
              Object.keys(path).forEach(function (key) {
                _this.register(key, path[key], target);
              });
            }
          } else {
            if (this.imports[path] != null && !overwrite) {
              debug.warn('Overwriting ' + path + ' with', target);
            }
            this.imports[path] = target;
            if ((path.startsWith('blots/') || path.startsWith('formats/')) && target.blotName !== 'abstract') {
              _parchment2.default.register(target);
            } else if (path.startsWith('modules') && typeof target.register === 'function') {
              target.register();
            }
          }
        }
      }]);

      function Quill(container) {
        var _this2 = this;

        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        _classCallCheck(this, Quill);

        this.options = expandConfig(container, options);
        this.container = this.options.container;
        if (this.container == null) {
          return debug.error('Invalid Quill container', container);
        }
        if (this.options.debug) {
          Quill.debug(this.options.debug);
        }
        var html = this.container.innerHTML.trim();
        this.container.classList.add('ql-container');
        this.container.innerHTML = '';
        this.container.__quill = this;
        this.root = this.addContainer('ql-editor');
        this.root.classList.add('ql-blank');
        this.root.setAttribute('data-gramm', false);
        this.scrollingContainer = this.options.scrollingContainer || this.root;
        this.emitter = new _emitter4.default();
        this.scroll = _parchment2.default.create(this.root, {
          emitter: this.emitter,
          whitelist: this.options.formats
        });
        this.editor = new _editor2.default(this.scroll);
        this.selection = new _selection2.default(this.scroll, this.emitter);
        this.theme = new this.options.theme(this, this.options);
        this.keyboard = this.theme.addModule('keyboard');
        this.clipboard = this.theme.addModule('clipboard');
        this.history = this.theme.addModule('history');
        this.theme.init();
        this.emitter.on(_emitter4.default.events.EDITOR_CHANGE, function (type) {
          if (type === _emitter4.default.events.TEXT_CHANGE) {
            _this2.root.classList.toggle('ql-blank', _this2.editor.isBlank());
          }
        });
        this.emitter.on(_emitter4.default.events.SCROLL_UPDATE, function (source, mutations) {
          var range = _this2.selection.lastRange;
          var index = range && range.length === 0 ? range.index : undefined;
          modify.call(_this2, function () {
            return _this2.editor.update(null, mutations, index);
          }, source);
        });
        var contents = this.clipboard.convert('<div class=\'ql-editor\' style="white-space: normal;">' + html + '<p><br></p></div>');
        this.setContents(contents);
        this.history.clear();
        if (this.options.placeholder) {
          this.root.setAttribute('data-placeholder', this.options.placeholder);
        }
        if (this.options.readOnly) {
          this.disable();
        }
      }

      _createClass(Quill, [{
        key: 'addContainer',
        value: function addContainer(container) {
          var refNode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

          if (typeof container === 'string') {
            var className = container;
            container = document.createElement('div');
            container.classList.add(className);
          }
          this.container.insertBefore(container, refNode);
          return container;
        }
      }, {
        key: 'blur',
        value: function blur() {
          this.selection.setRange(null);
        }
      }, {
        key: 'deleteText',
        value: function deleteText(index, length, source) {
          var _this3 = this;

          var _overload = overload(index, length, source);

          var _overload2 = _slicedToArray(_overload, 4);

          index = _overload2[0];
          length = _overload2[1];
          source = _overload2[3];

          return modify.call(this, function () {
            return _this3.editor.deleteText(index, length);
          }, source, index, -1 * length);
        }
      }, {
        key: 'disable',
        value: function disable() {
          this.enable(false);
        }
      }, {
        key: 'enable',
        value: function enable() {
          var enabled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

          this.scroll.enable(enabled);
          this.container.classList.toggle('ql-disabled', !enabled);
        }
      }, {
        key: 'focus',
        value: function focus() {
          var scrollTop = this.scrollingContainer.scrollTop;
          this.selection.focus();
          this.scrollingContainer.scrollTop = scrollTop;
          this.scrollIntoView();
        }
      }, {
        key: 'format',
        value: function format(name, value) {
          var _this4 = this;

          var source = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _emitter4.default.sources.API;

          return modify.call(this, function () {
            var range = _this4.getSelection(true);
            var change = new _quillDelta2.default();
            if (range == null) {
              return change;
            } else if (_parchment2.default.query(name, _parchment2.default.Scope.BLOCK)) {
              change = _this4.editor.formatLine(range.index, range.length, _defineProperty({}, name, value));
            } else if (range.length === 0) {
              _this4.selection.format(name, value);
              return change;
            } else {
              change = _this4.editor.formatText(range.index, range.length, _defineProperty({}, name, value));
            }
            _this4.setSelection(range, _emitter4.default.sources.SILENT);
            return change;
          }, source);
        }
      }, {
        key: 'formatLine',
        value: function formatLine(index, length, name, value, source) {
          var _this5 = this;

          var formats = void 0;

          var _overload3 = overload(index, length, name, value, source);

          var _overload4 = _slicedToArray(_overload3, 4);

          index = _overload4[0];
          length = _overload4[1];
          formats = _overload4[2];
          source = _overload4[3];

          return modify.call(this, function () {
            return _this5.editor.formatLine(index, length, formats);
          }, source, index, 0);
        }
      }, {
        key: 'formatText',
        value: function formatText(index, length, name, value, source) {
          var _this6 = this;

          var formats = void 0;

          var _overload5 = overload(index, length, name, value, source);

          var _overload6 = _slicedToArray(_overload5, 4);

          index = _overload6[0];
          length = _overload6[1];
          formats = _overload6[2];
          source = _overload6[3];

          return modify.call(this, function () {
            return _this6.editor.formatText(index, length, formats);
          }, source, index, 0);
        }
      }, {
        key: 'getBounds',
        value: function getBounds(index) {
          var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

          var bounds = void 0;
          if (typeof index === 'number') {
            bounds = this.selection.getBounds(index, length);
          } else {
            bounds = this.selection.getBounds(index.index, index.length);
          }
          var containerBounds = this.container.getBoundingClientRect();
          return {
            bottom: bounds.bottom - containerBounds.top,
            height: bounds.height,
            left: bounds.left - containerBounds.left,
            right: bounds.right - containerBounds.left,
            top: bounds.top - containerBounds.top,
            width: bounds.width
          };
        }
      }, {
        key: 'getContents',
        value: function getContents() {
          var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
          var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.getLength() - index;

          var _overload7 = overload(index, length);

          var _overload8 = _slicedToArray(_overload7, 2);

          index = _overload8[0];
          length = _overload8[1];

          return this.editor.getContents(index, length);
        }
      }, {
        key: 'getFormat',
        value: function getFormat() {
          var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getSelection(true);
          var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

          if (typeof index === 'number') {
            return this.editor.getFormat(index, length);
          } else {
            return this.editor.getFormat(index.index, index.length);
          }
        }
      }, {
        key: 'getIndex',
        value: function getIndex(blot) {
          return blot.offset(this.scroll);
        }
      }, {
        key: 'getLength',
        value: function getLength() {
          return this.scroll.length();
        }
      }, {
        key: 'getLeaf',
        value: function getLeaf(index) {
          return this.scroll.leaf(index);
        }
      }, {
        key: 'getLine',
        value: function getLine(index) {
          return this.scroll.line(index);
        }
      }, {
        key: 'getLines',
        value: function getLines() {
          var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
          var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Number.MAX_VALUE;

          if (typeof index !== 'number') {
            return this.scroll.lines(index.index, index.length);
          } else {
            return this.scroll.lines(index, length);
          }
        }
      }, {
        key: 'getModule',
        value: function getModule(name) {
          return this.theme.modules[name];
        }
      }, {
        key: 'getSelection',
        value: function getSelection() {
          var focus = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

          if (focus) this.focus();
          this.update(); // Make sure we access getRange with editor in consistent state
          return this.selection.getRange()[0];
        }
      }, {
        key: 'getText',
        value: function getText() {
          var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
          var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.getLength() - index;

          var _overload9 = overload(index, length);

          var _overload10 = _slicedToArray(_overload9, 2);

          index = _overload10[0];
          length = _overload10[1];

          return this.editor.getText(index, length);
        }
      }, {
        key: 'hasFocus',
        value: function hasFocus() {
          return this.selection.hasFocus();
        }
      }, {
        key: 'insertEmbed',
        value: function insertEmbed(index, embed, value) {
          var _this7 = this;

          var source = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Quill.sources.API;

          return modify.call(this, function () {
            return _this7.editor.insertEmbed(index, embed, value);
          }, source, index);
        }
      }, {
        key: 'insertText',
        value: function insertText(index, text, name, value, source) {
          var _this8 = this;

          var formats = void 0;

          var _overload11 = overload(index, 0, name, value, source);

          var _overload12 = _slicedToArray(_overload11, 4);

          index = _overload12[0];
          formats = _overload12[2];
          source = _overload12[3];

          return modify.call(this, function () {
            return _this8.editor.insertText(index, text, formats);
          }, source, index, text.length);
        }
      }, {
        key: 'isEnabled',
        value: function isEnabled() {
          return !this.container.classList.contains('ql-disabled');
        }
      }, {
        key: 'off',
        value: function off() {
          return this.emitter.off.apply(this.emitter, arguments);
        }
      }, {
        key: 'on',
        value: function on() {
          return this.emitter.on.apply(this.emitter, arguments);
        }
      }, {
        key: 'once',
        value: function once() {
          return this.emitter.once.apply(this.emitter, arguments);
        }
      }, {
        key: 'pasteHTML',
        value: function pasteHTML(index, html, source) {
          this.clipboard.dangerouslyPasteHTML(index, html, source);
        }
      }, {
        key: 'removeFormat',
        value: function removeFormat(index, length, source) {
          var _this9 = this;

          var _overload13 = overload(index, length, source);

          var _overload14 = _slicedToArray(_overload13, 4);

          index = _overload14[0];
          length = _overload14[1];
          source = _overload14[3];

          return modify.call(this, function () {
            return _this9.editor.removeFormat(index, length);
          }, source, index);
        }
      }, {
        key: 'scrollIntoView',
        value: function scrollIntoView() {
          this.selection.scrollIntoView(this.scrollingContainer);
        }
      }, {
        key: 'setContents',
        value: function setContents(delta) {
          var _this10 = this;

          var source = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _emitter4.default.sources.API;

          return modify.call(this, function () {
            delta = new _quillDelta2.default(delta);
            var length = _this10.getLength();
            var deleted = _this10.editor.deleteText(0, length);
            var applied = _this10.editor.applyDelta(delta);
            var lastOp = applied.ops[applied.ops.length - 1];
            if (lastOp != null && typeof lastOp.insert === 'string' && lastOp.insert[lastOp.insert.length - 1] === '\n') {
              _this10.editor.deleteText(_this10.getLength() - 1, 1);
              applied.delete(1);
            }
            var ret = deleted.compose(applied);
            return ret;
          }, source);
        }
      }, {
        key: 'setSelection',
        value: function setSelection(index, length, source) {
          if (index == null) {
            this.selection.setRange(null, length || Quill.sources.API);
          } else {
            var _overload15 = overload(index, length, source);

            var _overload16 = _slicedToArray(_overload15, 4);

            index = _overload16[0];
            length = _overload16[1];
            source = _overload16[3];

            this.selection.setRange(new _selection.Range(index, length), source);
            if (source !== _emitter4.default.sources.SILENT) {
              this.selection.scrollIntoView(this.scrollingContainer);
            }
          }
        }
      }, {
        key: 'setText',
        value: function setText(text) {
          var source = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _emitter4.default.sources.API;

          var delta = new _quillDelta2.default().insert(text);
          return this.setContents(delta, source);
        }
      }, {
        key: 'update',
        value: function update() {
          var source = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _emitter4.default.sources.USER;

          var change = this.scroll.update(source); // Will update selection before selection.update() does if text changes
          this.selection.update(source);
          return change;
        }
      }, {
        key: 'updateContents',
        value: function updateContents(delta) {
          var _this11 = this;

          var source = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _emitter4.default.sources.API;

          return modify.call(this, function () {
            delta = new _quillDelta2.default(delta);
            return _this11.editor.applyDelta(delta, source);
          }, source, true);
        }
      }]);

      return Quill;
    }();

    Quill.DEFAULTS = {
      bounds: null,
      formats: null,
      modules: {},
      placeholder: '',
      readOnly: false,
      scrollingContainer: null,
      strict: true,
      theme: 'default'
    };
    Quill.events = _emitter4.default.events;
    Quill.sources = _emitter4.default.sources;
    // eslint-disable-next-line no-undef
    Quill.version =   "1.3.7";

    Quill.imports = {
      'delta': _quillDelta2.default,
      'parchment': _parchment2.default,
      'core/module': _module2.default,
      'core/theme': _theme2.default
    };

    function expandConfig(container, userConfig) {
      userConfig = (0, _extend2.default)(true, {
        container: container,
        modules: {
          clipboard: true,
          keyboard: true,
          history: true
        }
      }, userConfig);
      if (!userConfig.theme || userConfig.theme === Quill.DEFAULTS.theme) {
        userConfig.theme = _theme2.default;
      } else {
        userConfig.theme = Quill.import('themes/' + userConfig.theme);
        if (userConfig.theme == null) {
          throw new Error('Invalid theme ' + userConfig.theme + '. Did you register it?');
        }
      }
      var themeConfig = (0, _extend2.default)(true, {}, userConfig.theme.DEFAULTS);
      [themeConfig, userConfig].forEach(function (config) {
        config.modules = config.modules || {};
        Object.keys(config.modules).forEach(function (module) {
          if (config.modules[module] === true) {
            config.modules[module] = {};
          }
        });
      });
      var moduleNames = Object.keys(themeConfig.modules).concat(Object.keys(userConfig.modules));
      var moduleConfig = moduleNames.reduce(function (config, name) {
        var moduleClass = Quill.import('modules/' + name);
        if (moduleClass == null) {
          debug.error('Cannot load ' + name + ' module. Are you sure you registered it?');
        } else {
          config[name] = moduleClass.DEFAULTS || {};
        }
        return config;
      }, {});
      // Special case toolbar shorthand
      if (userConfig.modules != null && userConfig.modules.toolbar && userConfig.modules.toolbar.constructor !== Object) {
        userConfig.modules.toolbar = {
          container: userConfig.modules.toolbar
        };
      }
      userConfig = (0, _extend2.default)(true, {}, Quill.DEFAULTS, { modules: moduleConfig }, themeConfig, userConfig);
      ['bounds', 'container', 'scrollingContainer'].forEach(function (key) {
        if (typeof userConfig[key] === 'string') {
          userConfig[key] = document.querySelector(userConfig[key]);
        }
      });
      userConfig.modules = Object.keys(userConfig.modules).reduce(function (config, name) {
        if (userConfig.modules[name]) {
          config[name] = userConfig.modules[name];
        }
        return config;
      }, {});
      return userConfig;
    }

    // Handle selection preservation and TEXT_CHANGE emission
    // common to modification APIs
    function modify(modifier, source, index, shift) {
      if (this.options.strict && !this.isEnabled() && source === _emitter4.default.sources.USER) {
        return new _quillDelta2.default();
      }
      var range = index == null ? null : this.getSelection();
      var oldDelta = this.editor.delta;
      var change = modifier();
      if (range != null) {
        if (index === true) index = range.index;
        if (shift == null) {
          range = shiftRange(range, change, source);
        } else if (shift !== 0) {
          range = shiftRange(range, index, shift, source);
        }
        this.setSelection(range, _emitter4.default.sources.SILENT);
      }
      if (change.length() > 0) {
        var _emitter;

        var args = [_emitter4.default.events.TEXT_CHANGE, change, oldDelta, source];
        (_emitter = this.emitter).emit.apply(_emitter, [_emitter4.default.events.EDITOR_CHANGE].concat(args));
        if (source !== _emitter4.default.sources.SILENT) {
          var _emitter2;

          (_emitter2 = this.emitter).emit.apply(_emitter2, args);
        }
      }
      return change;
    }

    function overload(index, length, name, value, source) {
      var formats = {};
      if (typeof index.index === 'number' && typeof index.length === 'number') {
        // Allow for throwaway end (used by insertText/insertEmbed)
        if (typeof length !== 'number') {
          source = value, value = name, name = length, length = index.length, index = index.index;
        } else {
          length = index.length, index = index.index;
        }
      } else if (typeof length !== 'number') {
        source = value, value = name, name = length, length = 0;
      }
      // Handle format being object, two format name/value strings or excluded
      if ((typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {
        formats = name;
        source = value;
      } else if (typeof name === 'string') {
        if (value != null) {
          formats[name] = value;
        } else {
          source = name;
        }
      }
      // Handle optional source
      source = source || _emitter4.default.sources.API;
      return [index, length, formats, source];
    }

    function shiftRange(range, index, length, source) {
      if (range == null) return null;
      var start = void 0,
          end = void 0;
      if (index instanceof _quillDelta2.default) {
        var _map = [range.index, range.index + range.length].map(function (pos) {
          return index.transformPosition(pos, source !== _emitter4.default.sources.USER);
        });

        var _map2 = _slicedToArray(_map, 2);

        start = _map2[0];
        end = _map2[1];
      } else {
        var _map3 = [range.index, range.index + range.length].map(function (pos) {
          if (pos < index || pos === index && source === _emitter4.default.sources.USER) return pos;
          if (length >= 0) {
            return pos + length;
          } else {
            return Math.max(index, pos + length);
          }
        });

        var _map4 = _slicedToArray(_map3, 2);

        start = _map4[0];
        end = _map4[1];
      }
      return new _selection.Range(start, end - start);
    }

    exports.expandConfig = expandConfig;
    exports.overload = overload;
    exports.default = Quill;

    /***/ }),
    /* 6 */
    /***/ (function(module, exports, __webpack_require__) {


    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

    var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

    var _text = __webpack_require__(7);

    var _text2 = _interopRequireDefault(_text);

    var _parchment = __webpack_require__(0);

    var _parchment2 = _interopRequireDefault(_parchment);

    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    var Inline = function (_Parchment$Inline) {
      _inherits(Inline, _Parchment$Inline);

      function Inline() {
        _classCallCheck(this, Inline);

        return _possibleConstructorReturn(this, (Inline.__proto__ || Object.getPrototypeOf(Inline)).apply(this, arguments));
      }

      _createClass(Inline, [{
        key: 'formatAt',
        value: function formatAt(index, length, name, value) {
          if (Inline.compare(this.statics.blotName, name) < 0 && _parchment2.default.query(name, _parchment2.default.Scope.BLOT)) {
            var blot = this.isolate(index, length);
            if (value) {
              blot.wrap(name, value);
            }
          } else {
            _get(Inline.prototype.__proto__ || Object.getPrototypeOf(Inline.prototype), 'formatAt', this).call(this, index, length, name, value);
          }
        }
      }, {
        key: 'optimize',
        value: function optimize(context) {
          _get(Inline.prototype.__proto__ || Object.getPrototypeOf(Inline.prototype), 'optimize', this).call(this, context);
          if (this.parent instanceof Inline && Inline.compare(this.statics.blotName, this.parent.statics.blotName) > 0) {
            var parent = this.parent.isolate(this.offset(), this.length());
            this.moveChildren(parent);
            parent.wrap(this);
          }
        }
      }], [{
        key: 'compare',
        value: function compare(self, other) {
          var selfIndex = Inline.order.indexOf(self);
          var otherIndex = Inline.order.indexOf(other);
          if (selfIndex >= 0 || otherIndex >= 0) {
            return selfIndex - otherIndex;
          } else if (self === other) {
            return 0;
          } else if (self < other) {
            return -1;
          } else {
            return 1;
          }
        }
      }]);

      return Inline;
    }(_parchment2.default.Inline);

    Inline.allowedChildren = [Inline, _parchment2.default.Embed, _text2.default];
    // Lower index means deeper in the DOM tree, since not found (-1) is for embeds
    Inline.order = ['cursor', 'inline', // Must be lower
    'underline', 'strike', 'italic', 'bold', 'script', 'link', 'code' // Must be higher
    ];

    exports.default = Inline;

    /***/ }),
    /* 7 */
    /***/ (function(module, exports, __webpack_require__) {


    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    var _parchment = __webpack_require__(0);

    var _parchment2 = _interopRequireDefault(_parchment);

    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    var TextBlot = function (_Parchment$Text) {
      _inherits(TextBlot, _Parchment$Text);

      function TextBlot() {
        _classCallCheck(this, TextBlot);

        return _possibleConstructorReturn(this, (TextBlot.__proto__ || Object.getPrototypeOf(TextBlot)).apply(this, arguments));
      }

      return TextBlot;
    }(_parchment2.default.Text);

    exports.default = TextBlot;

    /***/ }),
    /* 8 */
    /***/ (function(module, exports, __webpack_require__) {


    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

    var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

    var _eventemitter = __webpack_require__(54);

    var _eventemitter2 = _interopRequireDefault(_eventemitter);

    var _logger = __webpack_require__(10);

    var _logger2 = _interopRequireDefault(_logger);

    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    var debug = (0, _logger2.default)('quill:events');

    var EVENTS = ['selectionchange', 'mousedown', 'mouseup', 'click'];

    EVENTS.forEach(function (eventName) {
      document.addEventListener(eventName, function () {
        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        [].slice.call(document.querySelectorAll('.ql-container')).forEach(function (node) {
          // TODO use WeakMap
          if (node.__quill && node.__quill.emitter) {
            var _node$__quill$emitter;

            (_node$__quill$emitter = node.__quill.emitter).handleDOM.apply(_node$__quill$emitter, args);
          }
        });
      });
    });

    var Emitter = function (_EventEmitter) {
      _inherits(Emitter, _EventEmitter);

      function Emitter() {
        _classCallCheck(this, Emitter);

        var _this = _possibleConstructorReturn(this, (Emitter.__proto__ || Object.getPrototypeOf(Emitter)).call(this));

        _this.listeners = {};
        _this.on('error', debug.error);
        return _this;
      }

      _createClass(Emitter, [{
        key: 'emit',
        value: function emit() {
          debug.log.apply(debug, arguments);
          _get(Emitter.prototype.__proto__ || Object.getPrototypeOf(Emitter.prototype), 'emit', this).apply(this, arguments);
        }
      }, {
        key: 'handleDOM',
        value: function handleDOM(event) {
          for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
            args[_key2 - 1] = arguments[_key2];
          }

          (this.listeners[event.type] || []).forEach(function (_ref) {
            var node = _ref.node,
                handler = _ref.handler;

            if (event.target === node || node.contains(event.target)) {
              handler.apply(undefined, [event].concat(args));
            }
          });
        }
      }, {
        key: 'listenDOM',
        value: function listenDOM(eventName, node, handler) {
          if (!this.listeners[eventName]) {
            this.listeners[eventName] = [];
          }
          this.listeners[eventName].push({ node: node, handler: handler });
        }
      }]);

      return Emitter;
    }(_eventemitter2.default);

    Emitter.events = {
      EDITOR_CHANGE: 'editor-change',
      SCROLL_BEFORE_UPDATE: 'scroll-before-update',
      SCROLL_OPTIMIZE: 'scroll-optimize',
      SCROLL_UPDATE: 'scroll-update',
      SELECTION_CHANGE: 'selection-change',
      TEXT_CHANGE: 'text-change'
    };
    Emitter.sources = {
      API: 'api',
      SILENT: 'silent',
      USER: 'user'
    };

    exports.default = Emitter;

    /***/ }),
    /* 9 */
    /***/ (function(module, exports, __webpack_require__) {


    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    var Module = function Module(quill) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, Module);

      this.quill = quill;
      this.options = options;
    };

    Module.DEFAULTS = {};

    exports.default = Module;

    /***/ }),
    /* 10 */
    /***/ (function(module, exports, __webpack_require__) {


    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var levels = ['error', 'warn', 'log', 'info'];
    var level = 'warn';

    function debug(method) {
      if (levels.indexOf(method) <= levels.indexOf(level)) {
        var _console;

        for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }

        (_console = console)[method].apply(_console, args); // eslint-disable-line no-console
      }
    }

    function namespace(ns) {
      return levels.reduce(function (logger, method) {
        logger[method] = debug.bind(console, method, ns);
        return logger;
      }, {});
    }

    debug.level = namespace.level = function (newLevel) {
      level = newLevel;
    };

    exports.default = namespace;

    /***/ }),
    /* 11 */
    /***/ (function(module, exports, __webpack_require__) {

    var pSlice = Array.prototype.slice;
    var objectKeys = __webpack_require__(52);
    var isArguments = __webpack_require__(53);

    var deepEqual = module.exports = function (actual, expected, opts) {
      if (!opts) opts = {};
      // 7.1. All identical values are equivalent, as determined by ===.
      if (actual === expected) {
        return true;

      } else if (actual instanceof Date && expected instanceof Date) {
        return actual.getTime() === expected.getTime();

      // 7.3. Other pairs that do not both pass typeof value == 'object',
      // equivalence is determined by ==.
      } else if (!actual || !expected || typeof actual != 'object' && typeof expected != 'object') {
        return opts.strict ? actual === expected : actual == expected;

      // 7.4. For all other Object pairs, including Array objects, equivalence is
      // determined by having the same number of owned properties (as verified
      // with Object.prototype.hasOwnProperty.call), the same set of keys
      // (although not necessarily the same order), equivalent values for every
      // corresponding key, and an identical 'prototype' property. Note: this
      // accounts for both named and indexed properties on Arrays.
      } else {
        return objEquiv(actual, expected, opts);
      }
    };

    function isUndefinedOrNull(value) {
      return value === null || value === undefined;
    }

    function isBuffer (x) {
      if (!x || typeof x !== 'object' || typeof x.length !== 'number') return false;
      if (typeof x.copy !== 'function' || typeof x.slice !== 'function') {
        return false;
      }
      if (x.length > 0 && typeof x[0] !== 'number') return false;
      return true;
    }

    function objEquiv(a, b, opts) {
      var i, key;
      if (isUndefinedOrNull(a) || isUndefinedOrNull(b))
        return false;
      // an identical 'prototype' property.
      if (a.prototype !== b.prototype) return false;
      //~~~I've managed to break Object.keys through screwy arguments passing.
      //   Converting to array solves the problem.
      if (isArguments(a)) {
        if (!isArguments(b)) {
          return false;
        }
        a = pSlice.call(a);
        b = pSlice.call(b);
        return deepEqual(a, b, opts);
      }
      if (isBuffer(a)) {
        if (!isBuffer(b)) {
          return false;
        }
        if (a.length !== b.length) return false;
        for (i = 0; i < a.length; i++) {
          if (a[i] !== b[i]) return false;
        }
        return true;
      }
      try {
        var ka = objectKeys(a),
            kb = objectKeys(b);
      } catch (e) {//happens when one is a string literal and the other isn't
        return false;
      }
      // having the same number of owned properties (keys incorporates
      // hasOwnProperty)
      if (ka.length != kb.length)
        return false;
      //the same set of keys (although not necessarily the same order),
      ka.sort();
      kb.sort();
      //~~~cheap key test
      for (i = ka.length - 1; i >= 0; i--) {
        if (ka[i] != kb[i])
          return false;
      }
      //equivalent values for every corresponding key, and
      //~~~possibly expensive deep test
      for (i = ka.length - 1; i >= 0; i--) {
        key = ka[i];
        if (!deepEqual(a[key], b[key], opts)) return false;
      }
      return typeof a === typeof b;
    }


    /***/ }),
    /* 12 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    var Registry = __webpack_require__(1);
    var Attributor = /** @class */ (function () {
        function Attributor(attrName, keyName, options) {
            if (options === void 0) { options = {}; }
            this.attrName = attrName;
            this.keyName = keyName;
            var attributeBit = Registry.Scope.TYPE & Registry.Scope.ATTRIBUTE;
            if (options.scope != null) {
                // Ignore type bits, force attribute bit
                this.scope = (options.scope & Registry.Scope.LEVEL) | attributeBit;
            }
            else {
                this.scope = Registry.Scope.ATTRIBUTE;
            }
            if (options.whitelist != null)
                this.whitelist = options.whitelist;
        }
        Attributor.keys = function (node) {
            return [].map.call(node.attributes, function (item) {
                return item.name;
            });
        };
        Attributor.prototype.add = function (node, value) {
            if (!this.canAdd(node, value))
                return false;
            node.setAttribute(this.keyName, value);
            return true;
        };
        Attributor.prototype.canAdd = function (node, value) {
            var match = Registry.query(node, Registry.Scope.BLOT & (this.scope | Registry.Scope.TYPE));
            if (match == null)
                return false;
            if (this.whitelist == null)
                return true;
            if (typeof value === 'string') {
                return this.whitelist.indexOf(value.replace(/["']/g, '')) > -1;
            }
            else {
                return this.whitelist.indexOf(value) > -1;
            }
        };
        Attributor.prototype.remove = function (node) {
            node.removeAttribute(this.keyName);
        };
        Attributor.prototype.value = function (node) {
            var value = node.getAttribute(this.keyName);
            if (this.canAdd(node, value) && value) {
                return value;
            }
            return '';
        };
        return Attributor;
    }());
    exports.default = Attributor;


    /***/ }),
    /* 13 */
    /***/ (function(module, exports, __webpack_require__) {


    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = exports.Code = undefined;

    var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

    var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

    var _quillDelta = __webpack_require__(2);

    var _quillDelta2 = _interopRequireDefault(_quillDelta);

    var _parchment = __webpack_require__(0);

    var _parchment2 = _interopRequireDefault(_parchment);

    var _block = __webpack_require__(4);

    var _block2 = _interopRequireDefault(_block);

    var _inline = __webpack_require__(6);

    var _inline2 = _interopRequireDefault(_inline);

    var _text = __webpack_require__(7);

    var _text2 = _interopRequireDefault(_text);

    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    var Code = function (_Inline) {
      _inherits(Code, _Inline);

      function Code() {
        _classCallCheck(this, Code);

        return _possibleConstructorReturn(this, (Code.__proto__ || Object.getPrototypeOf(Code)).apply(this, arguments));
      }

      return Code;
    }(_inline2.default);

    Code.blotName = 'code';
    Code.tagName = 'CODE';

    var CodeBlock = function (_Block) {
      _inherits(CodeBlock, _Block);

      function CodeBlock() {
        _classCallCheck(this, CodeBlock);

        return _possibleConstructorReturn(this, (CodeBlock.__proto__ || Object.getPrototypeOf(CodeBlock)).apply(this, arguments));
      }

      _createClass(CodeBlock, [{
        key: 'delta',
        value: function delta() {
          var _this3 = this;

          var text = this.domNode.textContent;
          if (text.endsWith('\n')) {
            // Should always be true
            text = text.slice(0, -1);
          }
          return text.split('\n').reduce(function (delta, frag) {
            return delta.insert(frag).insert('\n', _this3.formats());
          }, new _quillDelta2.default());
        }
      }, {
        key: 'format',
        value: function format(name, value) {
          if (name === this.statics.blotName && value) return;

          var _descendant = this.descendant(_text2.default, this.length() - 1),
              _descendant2 = _slicedToArray(_descendant, 1),
              text = _descendant2[0];

          if (text != null) {
            text.deleteAt(text.length() - 1, 1);
          }
          _get(CodeBlock.prototype.__proto__ || Object.getPrototypeOf(CodeBlock.prototype), 'format', this).call(this, name, value);
        }
      }, {
        key: 'formatAt',
        value: function formatAt(index, length, name, value) {
          if (length === 0) return;
          if (_parchment2.default.query(name, _parchment2.default.Scope.BLOCK) == null || name === this.statics.blotName && value === this.statics.formats(this.domNode)) {
            return;
          }
          var nextNewline = this.newlineIndex(index);
          if (nextNewline < 0 || nextNewline >= index + length) return;
          var prevNewline = this.newlineIndex(index, true) + 1;
          var isolateLength = nextNewline - prevNewline + 1;
          var blot = this.isolate(prevNewline, isolateLength);
          var next = blot.next;
          blot.format(name, value);
          if (next instanceof CodeBlock) {
            next.formatAt(0, index - prevNewline + length - isolateLength, name, value);
          }
        }
      }, {
        key: 'insertAt',
        value: function insertAt(index, value, def) {
          if (def != null) return;

          var _descendant3 = this.descendant(_text2.default, index),
              _descendant4 = _slicedToArray(_descendant3, 2),
              text = _descendant4[0],
              offset = _descendant4[1];

          text.insertAt(offset, value);
        }
      }, {
        key: 'length',
        value: function length() {
          var length = this.domNode.textContent.length;
          if (!this.domNode.textContent.endsWith('\n')) {
            return length + 1;
          }
          return length;
        }
      }, {
        key: 'newlineIndex',
        value: function newlineIndex(searchIndex) {
          var reverse = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

          if (!reverse) {
            var offset = this.domNode.textContent.slice(searchIndex).indexOf('\n');
            return offset > -1 ? searchIndex + offset : -1;
          } else {
            return this.domNode.textContent.slice(0, searchIndex).lastIndexOf('\n');
          }
        }
      }, {
        key: 'optimize',
        value: function optimize(context) {
          if (!this.domNode.textContent.endsWith('\n')) {
            this.appendChild(_parchment2.default.create('text', '\n'));
          }
          _get(CodeBlock.prototype.__proto__ || Object.getPrototypeOf(CodeBlock.prototype), 'optimize', this).call(this, context);
          var next = this.next;
          if (next != null && next.prev === this && next.statics.blotName === this.statics.blotName && this.statics.formats(this.domNode) === next.statics.formats(next.domNode)) {
            next.optimize(context);
            next.moveChildren(this);
            next.remove();
          }
        }
      }, {
        key: 'replace',
        value: function replace(target) {
          _get(CodeBlock.prototype.__proto__ || Object.getPrototypeOf(CodeBlock.prototype), 'replace', this).call(this, target);
          [].slice.call(this.domNode.querySelectorAll('*')).forEach(function (node) {
            var blot = _parchment2.default.find(node);
            if (blot == null) {
              node.parentNode.removeChild(node);
            } else if (blot instanceof _parchment2.default.Embed) {
              blot.remove();
            } else {
              blot.unwrap();
            }
          });
        }
      }], [{
        key: 'create',
        value: function create(value) {
          var domNode = _get(CodeBlock.__proto__ || Object.getPrototypeOf(CodeBlock), 'create', this).call(this, value);
          domNode.setAttribute('spellcheck', false);
          return domNode;
        }
      }, {
        key: 'formats',
        value: function formats() {
          return true;
        }
      }]);

      return CodeBlock;
    }(_block2.default);

    CodeBlock.blotName = 'code-block';
    CodeBlock.tagName = 'PRE';
    CodeBlock.TAB = '  ';

    exports.Code = Code;
    exports.default = CodeBlock;

    /***/ }),
    /* 14 */
    /***/ (function(module, exports, __webpack_require__) {


    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

    var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

    var _quillDelta = __webpack_require__(2);

    var _quillDelta2 = _interopRequireDefault(_quillDelta);

    var _op = __webpack_require__(20);

    var _op2 = _interopRequireDefault(_op);

    var _parchment = __webpack_require__(0);

    var _parchment2 = _interopRequireDefault(_parchment);

    var _code = __webpack_require__(13);

    var _code2 = _interopRequireDefault(_code);

    var _cursor = __webpack_require__(24);

    var _cursor2 = _interopRequireDefault(_cursor);

    var _block = __webpack_require__(4);

    var _block2 = _interopRequireDefault(_block);

    var _break = __webpack_require__(16);

    var _break2 = _interopRequireDefault(_break);

    var _clone = __webpack_require__(21);

    var _clone2 = _interopRequireDefault(_clone);

    var _deepEqual = __webpack_require__(11);

    var _deepEqual2 = _interopRequireDefault(_deepEqual);

    var _extend = __webpack_require__(3);

    var _extend2 = _interopRequireDefault(_extend);

    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    var ASCII = /^[ -~]*$/;

    var Editor = function () {
      function Editor(scroll) {
        _classCallCheck(this, Editor);

        this.scroll = scroll;
        this.delta = this.getDelta();
      }

      _createClass(Editor, [{
        key: 'applyDelta',
        value: function applyDelta(delta) {
          var _this = this;

          var consumeNextNewline = false;
          this.scroll.update();
          var scrollLength = this.scroll.length();
          this.scroll.batchStart();
          delta = normalizeDelta(delta);
          delta.reduce(function (index, op) {
            var length = op.retain || op.delete || op.insert.length || 1;
            var attributes = op.attributes || {};
            if (op.insert != null) {
              if (typeof op.insert === 'string') {
                var text = op.insert;
                if (text.endsWith('\n') && consumeNextNewline) {
                  consumeNextNewline = false;
                  text = text.slice(0, -1);
                }
                if (index >= scrollLength && !text.endsWith('\n')) {
                  consumeNextNewline = true;
                }
                _this.scroll.insertAt(index, text);

                var _scroll$line = _this.scroll.line(index),
                    _scroll$line2 = _slicedToArray(_scroll$line, 2),
                    line = _scroll$line2[0],
                    offset = _scroll$line2[1];

                var formats = (0, _extend2.default)({}, (0, _block.bubbleFormats)(line));
                if (line instanceof _block2.default) {
                  var _line$descendant = line.descendant(_parchment2.default.Leaf, offset),
                      _line$descendant2 = _slicedToArray(_line$descendant, 1),
                      leaf = _line$descendant2[0];

                  formats = (0, _extend2.default)(formats, (0, _block.bubbleFormats)(leaf));
                }
                attributes = _op2.default.attributes.diff(formats, attributes) || {};
              } else if (_typeof(op.insert) === 'object') {
                var key = Object.keys(op.insert)[0]; // There should only be one key
                if (key == null) return index;
                _this.scroll.insertAt(index, key, op.insert[key]);
              }
              scrollLength += length;
            }
            Object.keys(attributes).forEach(function (name) {
              _this.scroll.formatAt(index, length, name, attributes[name]);
            });
            return index + length;
          }, 0);
          delta.reduce(function (index, op) {
            if (typeof op.delete === 'number') {
              _this.scroll.deleteAt(index, op.delete);
              return index;
            }
            return index + (op.retain || op.insert.length || 1);
          }, 0);
          this.scroll.batchEnd();
          return this.update(delta);
        }
      }, {
        key: 'deleteText',
        value: function deleteText(index, length) {
          this.scroll.deleteAt(index, length);
          return this.update(new _quillDelta2.default().retain(index).delete(length));
        }
      }, {
        key: 'formatLine',
        value: function formatLine(index, length) {
          var _this2 = this;

          var formats = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

          this.scroll.update();
          Object.keys(formats).forEach(function (format) {
            if (_this2.scroll.whitelist != null && !_this2.scroll.whitelist[format]) return;
            var lines = _this2.scroll.lines(index, Math.max(length, 1));
            var lengthRemaining = length;
            lines.forEach(function (line) {
              var lineLength = line.length();
              if (!(line instanceof _code2.default)) {
                line.format(format, formats[format]);
              } else {
                var codeIndex = index - line.offset(_this2.scroll);
                var codeLength = line.newlineIndex(codeIndex + lengthRemaining) - codeIndex + 1;
                line.formatAt(codeIndex, codeLength, format, formats[format]);
              }
              lengthRemaining -= lineLength;
            });
          });
          this.scroll.optimize();
          return this.update(new _quillDelta2.default().retain(index).retain(length, (0, _clone2.default)(formats)));
        }
      }, {
        key: 'formatText',
        value: function formatText(index, length) {
          var _this3 = this;

          var formats = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

          Object.keys(formats).forEach(function (format) {
            _this3.scroll.formatAt(index, length, format, formats[format]);
          });
          return this.update(new _quillDelta2.default().retain(index).retain(length, (0, _clone2.default)(formats)));
        }
      }, {
        key: 'getContents',
        value: function getContents(index, length) {
          return this.delta.slice(index, index + length);
        }
      }, {
        key: 'getDelta',
        value: function getDelta() {
          return this.scroll.lines().reduce(function (delta, line) {
            return delta.concat(line.delta());
          }, new _quillDelta2.default());
        }
      }, {
        key: 'getFormat',
        value: function getFormat(index) {
          var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

          var lines = [],
              leaves = [];
          if (length === 0) {
            this.scroll.path(index).forEach(function (path) {
              var _path = _slicedToArray(path, 1),
                  blot = _path[0];

              if (blot instanceof _block2.default) {
                lines.push(blot);
              } else if (blot instanceof _parchment2.default.Leaf) {
                leaves.push(blot);
              }
            });
          } else {
            lines = this.scroll.lines(index, length);
            leaves = this.scroll.descendants(_parchment2.default.Leaf, index, length);
          }
          var formatsArr = [lines, leaves].map(function (blots) {
            if (blots.length === 0) return {};
            var formats = (0, _block.bubbleFormats)(blots.shift());
            while (Object.keys(formats).length > 0) {
              var blot = blots.shift();
              if (blot == null) return formats;
              formats = combineFormats((0, _block.bubbleFormats)(blot), formats);
            }
            return formats;
          });
          return _extend2.default.apply(_extend2.default, formatsArr);
        }
      }, {
        key: 'getText',
        value: function getText(index, length) {
          return this.getContents(index, length).filter(function (op) {
            return typeof op.insert === 'string';
          }).map(function (op) {
            return op.insert;
          }).join('');
        }
      }, {
        key: 'insertEmbed',
        value: function insertEmbed(index, embed, value) {
          this.scroll.insertAt(index, embed, value);
          return this.update(new _quillDelta2.default().retain(index).insert(_defineProperty({}, embed, value)));
        }
      }, {
        key: 'insertText',
        value: function insertText(index, text) {
          var _this4 = this;

          var formats = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

          text = text.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
          this.scroll.insertAt(index, text);
          Object.keys(formats).forEach(function (format) {
            _this4.scroll.formatAt(index, text.length, format, formats[format]);
          });
          return this.update(new _quillDelta2.default().retain(index).insert(text, (0, _clone2.default)(formats)));
        }
      }, {
        key: 'isBlank',
        value: function isBlank() {
          if (this.scroll.children.length == 0) return true;
          if (this.scroll.children.length > 1) return false;
          var block = this.scroll.children.head;
          if (block.statics.blotName !== _block2.default.blotName) return false;
          if (block.children.length > 1) return false;
          return block.children.head instanceof _break2.default;
        }
      }, {
        key: 'removeFormat',
        value: function removeFormat(index, length) {
          var text = this.getText(index, length);

          var _scroll$line3 = this.scroll.line(index + length),
              _scroll$line4 = _slicedToArray(_scroll$line3, 2),
              line = _scroll$line4[0],
              offset = _scroll$line4[1];

          var suffixLength = 0,
              suffix = new _quillDelta2.default();
          if (line != null) {
            if (!(line instanceof _code2.default)) {
              suffixLength = line.length() - offset;
            } else {
              suffixLength = line.newlineIndex(offset) - offset + 1;
            }
            suffix = line.delta().slice(offset, offset + suffixLength - 1).insert('\n');
          }
          var contents = this.getContents(index, length + suffixLength);
          var diff = contents.diff(new _quillDelta2.default().insert(text).concat(suffix));
          var delta = new _quillDelta2.default().retain(index).concat(diff);
          return this.applyDelta(delta);
        }
      }, {
        key: 'update',
        value: function update(change) {
          var mutations = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
          var cursorIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;

          var oldDelta = this.delta;
          if (mutations.length === 1 && mutations[0].type === 'characterData' && mutations[0].target.data.match(ASCII) && _parchment2.default.find(mutations[0].target)) {
            // Optimization for character changes
            var textBlot = _parchment2.default.find(mutations[0].target);
            var formats = (0, _block.bubbleFormats)(textBlot);
            var index = textBlot.offset(this.scroll);
            var oldValue = mutations[0].oldValue.replace(_cursor2.default.CONTENTS, '');
            var oldText = new _quillDelta2.default().insert(oldValue);
            var newText = new _quillDelta2.default().insert(textBlot.value());
            var diffDelta = new _quillDelta2.default().retain(index).concat(oldText.diff(newText, cursorIndex));
            change = diffDelta.reduce(function (delta, op) {
              if (op.insert) {
                return delta.insert(op.insert, formats);
              } else {
                return delta.push(op);
              }
            }, new _quillDelta2.default());
            this.delta = oldDelta.compose(change);
          } else {
            this.delta = this.getDelta();
            if (!change || !(0, _deepEqual2.default)(oldDelta.compose(change), this.delta)) {
              change = oldDelta.diff(this.delta, cursorIndex);
            }
          }
          return change;
        }
      }]);

      return Editor;
    }();

    function combineFormats(formats, combined) {
      return Object.keys(combined).reduce(function (merged, name) {
        if (formats[name] == null) return merged;
        if (combined[name] === formats[name]) {
          merged[name] = combined[name];
        } else if (Array.isArray(combined[name])) {
          if (combined[name].indexOf(formats[name]) < 0) {
            merged[name] = combined[name].concat([formats[name]]);
          }
        } else {
          merged[name] = [combined[name], formats[name]];
        }
        return merged;
      }, {});
    }

    function normalizeDelta(delta) {
      return delta.reduce(function (delta, op) {
        if (op.insert === 1) {
          var attributes = (0, _clone2.default)(op.attributes);
          delete attributes['image'];
          return delta.insert({ image: op.attributes.image }, attributes);
        }
        if (op.attributes != null && (op.attributes.list === true || op.attributes.bullet === true)) {
          op = (0, _clone2.default)(op);
          if (op.attributes.list) {
            op.attributes.list = 'ordered';
          } else {
            op.attributes.list = 'bullet';
            delete op.attributes.bullet;
          }
        }
        if (typeof op.insert === 'string') {
          var text = op.insert.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
          return delta.insert(text, op.attributes);
        }
        return delta.push(op);
      }, new _quillDelta2.default());
    }

    exports.default = Editor;

    /***/ }),
    /* 15 */
    /***/ (function(module, exports, __webpack_require__) {


    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = exports.Range = undefined;

    var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

    var _parchment = __webpack_require__(0);

    var _parchment2 = _interopRequireDefault(_parchment);

    var _clone = __webpack_require__(21);

    var _clone2 = _interopRequireDefault(_clone);

    var _deepEqual = __webpack_require__(11);

    var _deepEqual2 = _interopRequireDefault(_deepEqual);

    var _emitter3 = __webpack_require__(8);

    var _emitter4 = _interopRequireDefault(_emitter3);

    var _logger = __webpack_require__(10);

    var _logger2 = _interopRequireDefault(_logger);

    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    var debug = (0, _logger2.default)('quill:selection');

    var Range = function Range(index) {
      var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

      _classCallCheck(this, Range);

      this.index = index;
      this.length = length;
    };

    var Selection = function () {
      function Selection(scroll, emitter) {
        var _this = this;

        _classCallCheck(this, Selection);

        this.emitter = emitter;
        this.scroll = scroll;
        this.composing = false;
        this.mouseDown = false;
        this.root = this.scroll.domNode;
        this.cursor = _parchment2.default.create('cursor', this);
        // savedRange is last non-null range
        this.lastRange = this.savedRange = new Range(0, 0);
        this.handleComposition();
        this.handleDragging();
        this.emitter.listenDOM('selectionchange', document, function () {
          if (!_this.mouseDown) {
            setTimeout(_this.update.bind(_this, _emitter4.default.sources.USER), 1);
          }
        });
        this.emitter.on(_emitter4.default.events.EDITOR_CHANGE, function (type, delta) {
          if (type === _emitter4.default.events.TEXT_CHANGE && delta.length() > 0) {
            _this.update(_emitter4.default.sources.SILENT);
          }
        });
        this.emitter.on(_emitter4.default.events.SCROLL_BEFORE_UPDATE, function () {
          if (!_this.hasFocus()) return;
          var native = _this.getNativeRange();
          if (native == null) return;
          if (native.start.node === _this.cursor.textNode) return; // cursor.restore() will handle
          // TODO unclear if this has negative side effects
          _this.emitter.once(_emitter4.default.events.SCROLL_UPDATE, function () {
            try {
              _this.setNativeRange(native.start.node, native.start.offset, native.end.node, native.end.offset);
            } catch (ignored) {}
          });
        });
        this.emitter.on(_emitter4.default.events.SCROLL_OPTIMIZE, function (mutations, context) {
          if (context.range) {
            var _context$range = context.range,
                startNode = _context$range.startNode,
                startOffset = _context$range.startOffset,
                endNode = _context$range.endNode,
                endOffset = _context$range.endOffset;

            _this.setNativeRange(startNode, startOffset, endNode, endOffset);
          }
        });
        this.update(_emitter4.default.sources.SILENT);
      }

      _createClass(Selection, [{
        key: 'handleComposition',
        value: function handleComposition() {
          var _this2 = this;

          this.root.addEventListener('compositionstart', function () {
            _this2.composing = true;
          });
          this.root.addEventListener('compositionend', function () {
            _this2.composing = false;
            if (_this2.cursor.parent) {
              var range = _this2.cursor.restore();
              if (!range) return;
              setTimeout(function () {
                _this2.setNativeRange(range.startNode, range.startOffset, range.endNode, range.endOffset);
              }, 1);
            }
          });
        }
      }, {
        key: 'handleDragging',
        value: function handleDragging() {
          var _this3 = this;

          this.emitter.listenDOM('mousedown', document.body, function () {
            _this3.mouseDown = true;
          });
          this.emitter.listenDOM('mouseup', document.body, function () {
            _this3.mouseDown = false;
            _this3.update(_emitter4.default.sources.USER);
          });
        }
      }, {
        key: 'focus',
        value: function focus() {
          if (this.hasFocus()) return;
          this.root.focus();
          this.setRange(this.savedRange);
        }
      }, {
        key: 'format',
        value: function format(_format, value) {
          if (this.scroll.whitelist != null && !this.scroll.whitelist[_format]) return;
          this.scroll.update();
          var nativeRange = this.getNativeRange();
          if (nativeRange == null || !nativeRange.native.collapsed || _parchment2.default.query(_format, _parchment2.default.Scope.BLOCK)) return;
          if (nativeRange.start.node !== this.cursor.textNode) {
            var blot = _parchment2.default.find(nativeRange.start.node, false);
            if (blot == null) return;
            // TODO Give blot ability to not split
            if (blot instanceof _parchment2.default.Leaf) {
              var after = blot.split(nativeRange.start.offset);
              blot.parent.insertBefore(this.cursor, after);
            } else {
              blot.insertBefore(this.cursor, nativeRange.start.node); // Should never happen
            }
            this.cursor.attach();
          }
          this.cursor.format(_format, value);
          this.scroll.optimize();
          this.setNativeRange(this.cursor.textNode, this.cursor.textNode.data.length);
          this.update();
        }
      }, {
        key: 'getBounds',
        value: function getBounds(index) {
          var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

          var scrollLength = this.scroll.length();
          index = Math.min(index, scrollLength - 1);
          length = Math.min(index + length, scrollLength - 1) - index;
          var node = void 0,
              _scroll$leaf = this.scroll.leaf(index),
              _scroll$leaf2 = _slicedToArray(_scroll$leaf, 2),
              leaf = _scroll$leaf2[0],
              offset = _scroll$leaf2[1];
          if (leaf == null) return null;

          var _leaf$position = leaf.position(offset, true);

          var _leaf$position2 = _slicedToArray(_leaf$position, 2);

          node = _leaf$position2[0];
          offset = _leaf$position2[1];

          var range = document.createRange();
          if (length > 0) {
            range.setStart(node, offset);

            var _scroll$leaf3 = this.scroll.leaf(index + length);

            var _scroll$leaf4 = _slicedToArray(_scroll$leaf3, 2);

            leaf = _scroll$leaf4[0];
            offset = _scroll$leaf4[1];

            if (leaf == null) return null;

            var _leaf$position3 = leaf.position(offset, true);

            var _leaf$position4 = _slicedToArray(_leaf$position3, 2);

            node = _leaf$position4[0];
            offset = _leaf$position4[1];

            range.setEnd(node, offset);
            return range.getBoundingClientRect();
          } else {
            var side = 'left';
            var rect = void 0;
            if (node instanceof Text) {
              if (offset < node.data.length) {
                range.setStart(node, offset);
                range.setEnd(node, offset + 1);
              } else {
                range.setStart(node, offset - 1);
                range.setEnd(node, offset);
                side = 'right';
              }
              rect = range.getBoundingClientRect();
            } else {
              rect = leaf.domNode.getBoundingClientRect();
              if (offset > 0) side = 'right';
            }
            return {
              bottom: rect.top + rect.height,
              height: rect.height,
              left: rect[side],
              right: rect[side],
              top: rect.top,
              width: 0
            };
          }
        }
      }, {
        key: 'getNativeRange',
        value: function getNativeRange() {
          var selection = document.getSelection();
          if (selection == null || selection.rangeCount <= 0) return null;
          var nativeRange = selection.getRangeAt(0);
          if (nativeRange == null) return null;
          var range = this.normalizeNative(nativeRange);
          debug.info('getNativeRange', range);
          return range;
        }
      }, {
        key: 'getRange',
        value: function getRange() {
          var normalized = this.getNativeRange();
          if (normalized == null) return [null, null];
          var range = this.normalizedToRange(normalized);
          return [range, normalized];
        }
      }, {
        key: 'hasFocus',
        value: function hasFocus() {
          return document.activeElement === this.root;
        }
      }, {
        key: 'normalizedToRange',
        value: function normalizedToRange(range) {
          var _this4 = this;

          var positions = [[range.start.node, range.start.offset]];
          if (!range.native.collapsed) {
            positions.push([range.end.node, range.end.offset]);
          }
          var indexes = positions.map(function (position) {
            var _position = _slicedToArray(position, 2),
                node = _position[0],
                offset = _position[1];

            var blot = _parchment2.default.find(node, true);
            var index = blot.offset(_this4.scroll);
            if (offset === 0) {
              return index;
            } else if (blot instanceof _parchment2.default.Container) {
              return index + blot.length();
            } else {
              return index + blot.index(node, offset);
            }
          });
          var end = Math.min(Math.max.apply(Math, _toConsumableArray(indexes)), this.scroll.length() - 1);
          var start = Math.min.apply(Math, [end].concat(_toConsumableArray(indexes)));
          return new Range(start, end - start);
        }
      }, {
        key: 'normalizeNative',
        value: function normalizeNative(nativeRange) {
          if (!contains(this.root, nativeRange.startContainer) || !nativeRange.collapsed && !contains(this.root, nativeRange.endContainer)) {
            return null;
          }
          var range = {
            start: { node: nativeRange.startContainer, offset: nativeRange.startOffset },
            end: { node: nativeRange.endContainer, offset: nativeRange.endOffset },
            native: nativeRange
          };
          [range.start, range.end].forEach(function (position) {
            var node = position.node,
                offset = position.offset;
            while (!(node instanceof Text) && node.childNodes.length > 0) {
              if (node.childNodes.length > offset) {
                node = node.childNodes[offset];
                offset = 0;
              } else if (node.childNodes.length === offset) {
                node = node.lastChild;
                offset = node instanceof Text ? node.data.length : node.childNodes.length + 1;
              } else {
                break;
              }
            }
            position.node = node, position.offset = offset;
          });
          return range;
        }
      }, {
        key: 'rangeToNative',
        value: function rangeToNative(range) {
          var _this5 = this;

          var indexes = range.collapsed ? [range.index] : [range.index, range.index + range.length];
          var args = [];
          var scrollLength = this.scroll.length();
          indexes.forEach(function (index, i) {
            index = Math.min(scrollLength - 1, index);
            var node = void 0,
                _scroll$leaf5 = _this5.scroll.leaf(index),
                _scroll$leaf6 = _slicedToArray(_scroll$leaf5, 2),
                leaf = _scroll$leaf6[0],
                offset = _scroll$leaf6[1];
            var _leaf$position5 = leaf.position(offset, i !== 0);

            var _leaf$position6 = _slicedToArray(_leaf$position5, 2);

            node = _leaf$position6[0];
            offset = _leaf$position6[1];

            args.push(node, offset);
          });
          if (args.length < 2) {
            args = args.concat(args);
          }
          return args;
        }
      }, {
        key: 'scrollIntoView',
        value: function scrollIntoView(scrollingContainer) {
          var range = this.lastRange;
          if (range == null) return;
          var bounds = this.getBounds(range.index, range.length);
          if (bounds == null) return;
          var limit = this.scroll.length() - 1;

          var _scroll$line = this.scroll.line(Math.min(range.index, limit)),
              _scroll$line2 = _slicedToArray(_scroll$line, 1),
              first = _scroll$line2[0];

          var last = first;
          if (range.length > 0) {
            var _scroll$line3 = this.scroll.line(Math.min(range.index + range.length, limit));

            var _scroll$line4 = _slicedToArray(_scroll$line3, 1);

            last = _scroll$line4[0];
          }
          if (first == null || last == null) return;
          var scrollBounds = scrollingContainer.getBoundingClientRect();
          if (bounds.top < scrollBounds.top) {
            scrollingContainer.scrollTop -= scrollBounds.top - bounds.top;
          } else if (bounds.bottom > scrollBounds.bottom) {
            scrollingContainer.scrollTop += bounds.bottom - scrollBounds.bottom;
          }
        }
      }, {
        key: 'setNativeRange',
        value: function setNativeRange(startNode, startOffset) {
          var endNode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : startNode;
          var endOffset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : startOffset;
          var force = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

          debug.info('setNativeRange', startNode, startOffset, endNode, endOffset);
          if (startNode != null && (this.root.parentNode == null || startNode.parentNode == null || endNode.parentNode == null)) {
            return;
          }
          var selection = document.getSelection();
          if (selection == null) return;
          if (startNode != null) {
            if (!this.hasFocus()) this.root.focus();
            var native = (this.getNativeRange() || {}).native;
            if (native == null || force || startNode !== native.startContainer || startOffset !== native.startOffset || endNode !== native.endContainer || endOffset !== native.endOffset) {

              if (startNode.tagName == "BR") {
                startOffset = [].indexOf.call(startNode.parentNode.childNodes, startNode);
                startNode = startNode.parentNode;
              }
              if (endNode.tagName == "BR") {
                endOffset = [].indexOf.call(endNode.parentNode.childNodes, endNode);
                endNode = endNode.parentNode;
              }
              var range = document.createRange();
              range.setStart(startNode, startOffset);
              range.setEnd(endNode, endOffset);
              selection.removeAllRanges();
              selection.addRange(range);
            }
          } else {
            selection.removeAllRanges();
            this.root.blur();
            document.body.focus(); // root.blur() not enough on IE11+Travis+SauceLabs (but not local VMs)
          }
        }
      }, {
        key: 'setRange',
        value: function setRange(range) {
          var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
          var source = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _emitter4.default.sources.API;

          if (typeof force === 'string') {
            source = force;
            force = false;
          }
          debug.info('setRange', range);
          if (range != null) {
            var args = this.rangeToNative(range);
            this.setNativeRange.apply(this, _toConsumableArray(args).concat([force]));
          } else {
            this.setNativeRange(null);
          }
          this.update(source);
        }
      }, {
        key: 'update',
        value: function update() {
          var source = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _emitter4.default.sources.USER;

          var oldRange = this.lastRange;

          var _getRange = this.getRange(),
              _getRange2 = _slicedToArray(_getRange, 2),
              lastRange = _getRange2[0],
              nativeRange = _getRange2[1];

          this.lastRange = lastRange;
          if (this.lastRange != null) {
            this.savedRange = this.lastRange;
          }
          if (!(0, _deepEqual2.default)(oldRange, this.lastRange)) {
            var _emitter;

            if (!this.composing && nativeRange != null && nativeRange.native.collapsed && nativeRange.start.node !== this.cursor.textNode) {
              this.cursor.restore();
            }
            var args = [_emitter4.default.events.SELECTION_CHANGE, (0, _clone2.default)(this.lastRange), (0, _clone2.default)(oldRange), source];
            (_emitter = this.emitter).emit.apply(_emitter, [_emitter4.default.events.EDITOR_CHANGE].concat(args));
            if (source !== _emitter4.default.sources.SILENT) {
              var _emitter2;

              (_emitter2 = this.emitter).emit.apply(_emitter2, args);
            }
          }
        }
      }]);

      return Selection;
    }();

    function contains(parent, descendant) {
      try {
        // Firefox inserts inaccessible nodes around video elements
        descendant.parentNode;
      } catch (e) {
        return false;
      }
      // IE11 has bug with Text nodes
      // https://connect.microsoft.com/IE/feedback/details/780874/node-contains-is-incorrect
      if (descendant instanceof Text) {
        descendant = descendant.parentNode;
      }
      return parent.contains(descendant);
    }

    exports.Range = Range;
    exports.default = Selection;

    /***/ }),
    /* 16 */
    /***/ (function(module, exports, __webpack_require__) {


    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

    var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

    var _parchment = __webpack_require__(0);

    var _parchment2 = _interopRequireDefault(_parchment);

    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    var Break = function (_Parchment$Embed) {
      _inherits(Break, _Parchment$Embed);

      function Break() {
        _classCallCheck(this, Break);

        return _possibleConstructorReturn(this, (Break.__proto__ || Object.getPrototypeOf(Break)).apply(this, arguments));
      }

      _createClass(Break, [{
        key: 'insertInto',
        value: function insertInto(parent, ref) {
          if (parent.children.length === 0) {
            _get(Break.prototype.__proto__ || Object.getPrototypeOf(Break.prototype), 'insertInto', this).call(this, parent, ref);
          } else {
            this.remove();
          }
        }
      }, {
        key: 'length',
        value: function length() {
          return 0;
        }
      }, {
        key: 'value',
        value: function value() {
          return '';
        }
      }], [{
        key: 'value',
        value: function value() {
          return undefined;
        }
      }]);

      return Break;
    }(_parchment2.default.Embed);

    Break.blotName = 'break';
    Break.tagName = 'BR';

    exports.default = Break;

    /***/ }),
    /* 17 */
    /***/ (function(module, exports, __webpack_require__) {

    var __extends = (this && this.__extends) || (function () {
        var extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    Object.defineProperty(exports, "__esModule", { value: true });
    var linked_list_1 = __webpack_require__(44);
    var shadow_1 = __webpack_require__(30);
    var Registry = __webpack_require__(1);
    var ContainerBlot = /** @class */ (function (_super) {
        __extends(ContainerBlot, _super);
        function ContainerBlot(domNode) {
            var _this = _super.call(this, domNode) || this;
            _this.build();
            return _this;
        }
        ContainerBlot.prototype.appendChild = function (other) {
            this.insertBefore(other);
        };
        ContainerBlot.prototype.attach = function () {
            _super.prototype.attach.call(this);
            this.children.forEach(function (child) {
                child.attach();
            });
        };
        ContainerBlot.prototype.build = function () {
            var _this = this;
            this.children = new linked_list_1.default();
            // Need to be reversed for if DOM nodes already in order
            [].slice
                .call(this.domNode.childNodes)
                .reverse()
                .forEach(function (node) {
                try {
                    var child = makeBlot(node);
                    _this.insertBefore(child, _this.children.head || undefined);
                }
                catch (err) {
                    if (err instanceof Registry.ParchmentError)
                        return;
                    else
                        throw err;
                }
            });
        };
        ContainerBlot.prototype.deleteAt = function (index, length) {
            if (index === 0 && length === this.length()) {
                return this.remove();
            }
            this.children.forEachAt(index, length, function (child, offset, length) {
                child.deleteAt(offset, length);
            });
        };
        ContainerBlot.prototype.descendant = function (criteria, index) {
            var _a = this.children.find(index), child = _a[0], offset = _a[1];
            if ((criteria.blotName == null && criteria(child)) ||
                (criteria.blotName != null && child instanceof criteria)) {
                return [child, offset];
            }
            else if (child instanceof ContainerBlot) {
                return child.descendant(criteria, offset);
            }
            else {
                return [null, -1];
            }
        };
        ContainerBlot.prototype.descendants = function (criteria, index, length) {
            if (index === void 0) { index = 0; }
            if (length === void 0) { length = Number.MAX_VALUE; }
            var descendants = [];
            var lengthLeft = length;
            this.children.forEachAt(index, length, function (child, index, length) {
                if ((criteria.blotName == null && criteria(child)) ||
                    (criteria.blotName != null && child instanceof criteria)) {
                    descendants.push(child);
                }
                if (child instanceof ContainerBlot) {
                    descendants = descendants.concat(child.descendants(criteria, index, lengthLeft));
                }
                lengthLeft -= length;
            });
            return descendants;
        };
        ContainerBlot.prototype.detach = function () {
            this.children.forEach(function (child) {
                child.detach();
            });
            _super.prototype.detach.call(this);
        };
        ContainerBlot.prototype.formatAt = function (index, length, name, value) {
            this.children.forEachAt(index, length, function (child, offset, length) {
                child.formatAt(offset, length, name, value);
            });
        };
        ContainerBlot.prototype.insertAt = function (index, value, def) {
            var _a = this.children.find(index), child = _a[0], offset = _a[1];
            if (child) {
                child.insertAt(offset, value, def);
            }
            else {
                var blot = def == null ? Registry.create('text', value) : Registry.create(value, def);
                this.appendChild(blot);
            }
        };
        ContainerBlot.prototype.insertBefore = function (childBlot, refBlot) {
            if (this.statics.allowedChildren != null &&
                !this.statics.allowedChildren.some(function (child) {
                    return childBlot instanceof child;
                })) {
                throw new Registry.ParchmentError("Cannot insert " + childBlot.statics.blotName + " into " + this.statics.blotName);
            }
            childBlot.insertInto(this, refBlot);
        };
        ContainerBlot.prototype.length = function () {
            return this.children.reduce(function (memo, child) {
                return memo + child.length();
            }, 0);
        };
        ContainerBlot.prototype.moveChildren = function (targetParent, refNode) {
            this.children.forEach(function (child) {
                targetParent.insertBefore(child, refNode);
            });
        };
        ContainerBlot.prototype.optimize = function (context) {
            _super.prototype.optimize.call(this, context);
            if (this.children.length === 0) {
                if (this.statics.defaultChild != null) {
                    var child = Registry.create(this.statics.defaultChild);
                    this.appendChild(child);
                    child.optimize(context);
                }
                else {
                    this.remove();
                }
            }
        };
        ContainerBlot.prototype.path = function (index, inclusive) {
            if (inclusive === void 0) { inclusive = false; }
            var _a = this.children.find(index, inclusive), child = _a[0], offset = _a[1];
            var position = [[this, index]];
            if (child instanceof ContainerBlot) {
                return position.concat(child.path(offset, inclusive));
            }
            else if (child != null) {
                position.push([child, offset]);
            }
            return position;
        };
        ContainerBlot.prototype.removeChild = function (child) {
            this.children.remove(child);
        };
        ContainerBlot.prototype.replace = function (target) {
            if (target instanceof ContainerBlot) {
                target.moveChildren(this);
            }
            _super.prototype.replace.call(this, target);
        };
        ContainerBlot.prototype.split = function (index, force) {
            if (force === void 0) { force = false; }
            if (!force) {
                if (index === 0)
                    return this;
                if (index === this.length())
                    return this.next;
            }
            var after = this.clone();
            this.parent.insertBefore(after, this.next);
            this.children.forEachAt(index, this.length(), function (child, offset, length) {
                child = child.split(offset, force);
                after.appendChild(child);
            });
            return after;
        };
        ContainerBlot.prototype.unwrap = function () {
            this.moveChildren(this.parent, this.next);
            this.remove();
        };
        ContainerBlot.prototype.update = function (mutations, context) {
            var _this = this;
            var addedNodes = [];
            var removedNodes = [];
            mutations.forEach(function (mutation) {
                if (mutation.target === _this.domNode && mutation.type === 'childList') {
                    addedNodes.push.apply(addedNodes, mutation.addedNodes);
                    removedNodes.push.apply(removedNodes, mutation.removedNodes);
                }
            });
            removedNodes.forEach(function (node) {
                // Check node has actually been removed
                // One exception is Chrome does not immediately remove IFRAMEs
                // from DOM but MutationRecord is correct in its reported removal
                if (node.parentNode != null &&
                    // @ts-ignore
                    node.tagName !== 'IFRAME' &&
                    document.body.compareDocumentPosition(node) & Node.DOCUMENT_POSITION_CONTAINED_BY) {
                    return;
                }
                var blot = Registry.find(node);
                if (blot == null)
                    return;
                if (blot.domNode.parentNode == null || blot.domNode.parentNode === _this.domNode) {
                    blot.detach();
                }
            });
            addedNodes
                .filter(function (node) {
                return node.parentNode == _this.domNode;
            })
                .sort(function (a, b) {
                if (a === b)
                    return 0;
                if (a.compareDocumentPosition(b) & Node.DOCUMENT_POSITION_FOLLOWING) {
                    return 1;
                }
                return -1;
            })
                .forEach(function (node) {
                var refBlot = null;
                if (node.nextSibling != null) {
                    refBlot = Registry.find(node.nextSibling);
                }
                var blot = makeBlot(node);
                if (blot.next != refBlot || blot.next == null) {
                    if (blot.parent != null) {
                        blot.parent.removeChild(_this);
                    }
                    _this.insertBefore(blot, refBlot || undefined);
                }
            });
        };
        return ContainerBlot;
    }(shadow_1.default));
    function makeBlot(node) {
        var blot = Registry.find(node);
        if (blot == null) {
            try {
                blot = Registry.create(node);
            }
            catch (e) {
                blot = Registry.create(Registry.Scope.INLINE);
                [].slice.call(node.childNodes).forEach(function (child) {
                    // @ts-ignore
                    blot.domNode.appendChild(child);
                });
                if (node.parentNode) {
                    node.parentNode.replaceChild(blot.domNode, node);
                }
                blot.attach();
            }
        }
        return blot;
    }
    exports.default = ContainerBlot;


    /***/ }),
    /* 18 */
    /***/ (function(module, exports, __webpack_require__) {

    var __extends = (this && this.__extends) || (function () {
        var extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    Object.defineProperty(exports, "__esModule", { value: true });
    var attributor_1 = __webpack_require__(12);
    var store_1 = __webpack_require__(31);
    var container_1 = __webpack_require__(17);
    var Registry = __webpack_require__(1);
    var FormatBlot = /** @class */ (function (_super) {
        __extends(FormatBlot, _super);
        function FormatBlot(domNode) {
            var _this = _super.call(this, domNode) || this;
            _this.attributes = new store_1.default(_this.domNode);
            return _this;
        }
        FormatBlot.formats = function (domNode) {
            if (typeof this.tagName === 'string') {
                return true;
            }
            else if (Array.isArray(this.tagName)) {
                return domNode.tagName.toLowerCase();
            }
            return undefined;
        };
        FormatBlot.prototype.format = function (name, value) {
            var format = Registry.query(name);
            if (format instanceof attributor_1.default) {
                this.attributes.attribute(format, value);
            }
            else if (value) {
                if (format != null && (name !== this.statics.blotName || this.formats()[name] !== value)) {
                    this.replaceWith(name, value);
                }
            }
        };
        FormatBlot.prototype.formats = function () {
            var formats = this.attributes.values();
            var format = this.statics.formats(this.domNode);
            if (format != null) {
                formats[this.statics.blotName] = format;
            }
            return formats;
        };
        FormatBlot.prototype.replaceWith = function (name, value) {
            var replacement = _super.prototype.replaceWith.call(this, name, value);
            this.attributes.copy(replacement);
            return replacement;
        };
        FormatBlot.prototype.update = function (mutations, context) {
            var _this = this;
            _super.prototype.update.call(this, mutations, context);
            if (mutations.some(function (mutation) {
                return mutation.target === _this.domNode && mutation.type === 'attributes';
            })) {
                this.attributes.build();
            }
        };
        FormatBlot.prototype.wrap = function (name, value) {
            var wrapper = _super.prototype.wrap.call(this, name, value);
            if (wrapper instanceof FormatBlot && wrapper.statics.scope === this.statics.scope) {
                this.attributes.move(wrapper);
            }
            return wrapper;
        };
        return FormatBlot;
    }(container_1.default));
    exports.default = FormatBlot;


    /***/ }),
    /* 19 */
    /***/ (function(module, exports, __webpack_require__) {

    var __extends = (this && this.__extends) || (function () {
        var extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    Object.defineProperty(exports, "__esModule", { value: true });
    var shadow_1 = __webpack_require__(30);
    var Registry = __webpack_require__(1);
    var LeafBlot = /** @class */ (function (_super) {
        __extends(LeafBlot, _super);
        function LeafBlot() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        LeafBlot.value = function (domNode) {
            return true;
        };
        LeafBlot.prototype.index = function (node, offset) {
            if (this.domNode === node ||
                this.domNode.compareDocumentPosition(node) & Node.DOCUMENT_POSITION_CONTAINED_BY) {
                return Math.min(offset, 1);
            }
            return -1;
        };
        LeafBlot.prototype.position = function (index, inclusive) {
            var offset = [].indexOf.call(this.parent.domNode.childNodes, this.domNode);
            if (index > 0)
                offset += 1;
            return [this.parent.domNode, offset];
        };
        LeafBlot.prototype.value = function () {
            var _a;
            return _a = {}, _a[this.statics.blotName] = this.statics.value(this.domNode) || true, _a;
        };
        LeafBlot.scope = Registry.Scope.INLINE_BLOT;
        return LeafBlot;
    }(shadow_1.default));
    exports.default = LeafBlot;


    /***/ }),
    /* 20 */
    /***/ (function(module, exports, __webpack_require__) {

    var equal = __webpack_require__(11);
    var extend = __webpack_require__(3);


    var lib = {
      attributes: {
        compose: function (a, b, keepNull) {
          if (typeof a !== 'object') a = {};
          if (typeof b !== 'object') b = {};
          var attributes = extend(true, {}, b);
          if (!keepNull) {
            attributes = Object.keys(attributes).reduce(function (copy, key) {
              if (attributes[key] != null) {
                copy[key] = attributes[key];
              }
              return copy;
            }, {});
          }
          for (var key in a) {
            if (a[key] !== undefined && b[key] === undefined) {
              attributes[key] = a[key];
            }
          }
          return Object.keys(attributes).length > 0 ? attributes : undefined;
        },

        diff: function(a, b) {
          if (typeof a !== 'object') a = {};
          if (typeof b !== 'object') b = {};
          var attributes = Object.keys(a).concat(Object.keys(b)).reduce(function (attributes, key) {
            if (!equal(a[key], b[key])) {
              attributes[key] = b[key] === undefined ? null : b[key];
            }
            return attributes;
          }, {});
          return Object.keys(attributes).length > 0 ? attributes : undefined;
        },

        transform: function (a, b, priority) {
          if (typeof a !== 'object') return b;
          if (typeof b !== 'object') return undefined;
          if (!priority) return b;  // b simply overwrites us without priority
          var attributes = Object.keys(b).reduce(function (attributes, key) {
            if (a[key] === undefined) attributes[key] = b[key];  // null is a valid value
            return attributes;
          }, {});
          return Object.keys(attributes).length > 0 ? attributes : undefined;
        }
      },

      iterator: function (ops) {
        return new Iterator(ops);
      },

      length: function (op) {
        if (typeof op['delete'] === 'number') {
          return op['delete'];
        } else if (typeof op.retain === 'number') {
          return op.retain;
        } else {
          return typeof op.insert === 'string' ? op.insert.length : 1;
        }
      }
    };


    function Iterator(ops) {
      this.ops = ops;
      this.index = 0;
      this.offset = 0;
    }
    Iterator.prototype.hasNext = function () {
      return this.peekLength() < Infinity;
    };

    Iterator.prototype.next = function (length) {
      if (!length) length = Infinity;
      var nextOp = this.ops[this.index];
      if (nextOp) {
        var offset = this.offset;
        var opLength = lib.length(nextOp);
        if (length >= opLength - offset) {
          length = opLength - offset;
          this.index += 1;
          this.offset = 0;
        } else {
          this.offset += length;
        }
        if (typeof nextOp['delete'] === 'number') {
          return { 'delete': length };
        } else {
          var retOp = {};
          if (nextOp.attributes) {
            retOp.attributes = nextOp.attributes;
          }
          if (typeof nextOp.retain === 'number') {
            retOp.retain = length;
          } else if (typeof nextOp.insert === 'string') {
            retOp.insert = nextOp.insert.substr(offset, length);
          } else {
            // offset should === 0, length should === 1
            retOp.insert = nextOp.insert;
          }
          return retOp;
        }
      } else {
        return { retain: Infinity };
      }
    };

    Iterator.prototype.peek = function () {
      return this.ops[this.index];
    };

    Iterator.prototype.peekLength = function () {
      if (this.ops[this.index]) {
        // Should never return 0 if our index is being managed correctly
        return lib.length(this.ops[this.index]) - this.offset;
      } else {
        return Infinity;
      }
    };

    Iterator.prototype.peekType = function () {
      if (this.ops[this.index]) {
        if (typeof this.ops[this.index]['delete'] === 'number') {
          return 'delete';
        } else if (typeof this.ops[this.index].retain === 'number') {
          return 'retain';
        } else {
          return 'insert';
        }
      }
      return 'retain';
    };

    Iterator.prototype.rest = function () {
      if (!this.hasNext()) {
        return [];
      } else if (this.offset === 0) {
        return this.ops.slice(this.index);
      } else {
        var offset = this.offset;
        var index = this.index;
        var next = this.next();
        var rest = this.ops.slice(this.index);
        this.offset = offset;
        this.index = index;
        return [next].concat(rest);
      }
    };


    module.exports = lib;


    /***/ }),
    /* 21 */
    /***/ (function(module, exports) {

    var clone = (function() {

    function _instanceof(obj, type) {
      return type != null && obj instanceof type;
    }

    var nativeMap;
    try {
      nativeMap = Map;
    } catch(_) {
      // maybe a reference error because no `Map`. Give it a dummy value that no
      // value will ever be an instanceof.
      nativeMap = function() {};
    }

    var nativeSet;
    try {
      nativeSet = Set;
    } catch(_) {
      nativeSet = function() {};
    }

    var nativePromise;
    try {
      nativePromise = Promise;
    } catch(_) {
      nativePromise = function() {};
    }

    /**
     * Clones (copies) an Object using deep copying.
     *
     * This function supports circular references by default, but if you are certain
     * there are no circular references in your object, you can save some CPU time
     * by calling clone(obj, false).
     *
     * Caution: if `circular` is false and `parent` contains circular references,
     * your program may enter an infinite loop and crash.
     *
     * @param `parent` - the object to be cloned
     * @param `circular` - set to true if the object to be cloned may contain
     *    circular references. (optional - true by default)
     * @param `depth` - set to a number if the object is only to be cloned to
     *    a particular depth. (optional - defaults to Infinity)
     * @param `prototype` - sets the prototype to be used when cloning an object.
     *    (optional - defaults to parent prototype).
     * @param `includeNonEnumerable` - set to true if the non-enumerable properties
     *    should be cloned as well. Non-enumerable properties on the prototype
     *    chain will be ignored. (optional - false by default)
    */
    function clone(parent, circular, depth, prototype, includeNonEnumerable) {
      if (typeof circular === 'object') {
        depth = circular.depth;
        prototype = circular.prototype;
        includeNonEnumerable = circular.includeNonEnumerable;
        circular = circular.circular;
      }
      // maintain two arrays for circular references, where corresponding parents
      // and children have the same index
      var allParents = [];
      var allChildren = [];

      var useBuffer = typeof Buffer != 'undefined';

      if (typeof circular == 'undefined')
        circular = true;

      if (typeof depth == 'undefined')
        depth = Infinity;

      // recurse this function so we don't reset allParents and allChildren
      function _clone(parent, depth) {
        // cloning null always returns null
        if (parent === null)
          return null;

        if (depth === 0)
          return parent;

        var child;
        var proto;
        if (typeof parent != 'object') {
          return parent;
        }

        if (_instanceof(parent, nativeMap)) {
          child = new nativeMap();
        } else if (_instanceof(parent, nativeSet)) {
          child = new nativeSet();
        } else if (_instanceof(parent, nativePromise)) {
          child = new nativePromise(function (resolve, reject) {
            parent.then(function(value) {
              resolve(_clone(value, depth - 1));
            }, function(err) {
              reject(_clone(err, depth - 1));
            });
          });
        } else if (clone.__isArray(parent)) {
          child = [];
        } else if (clone.__isRegExp(parent)) {
          child = new RegExp(parent.source, __getRegExpFlags(parent));
          if (parent.lastIndex) child.lastIndex = parent.lastIndex;
        } else if (clone.__isDate(parent)) {
          child = new Date(parent.getTime());
        } else if (useBuffer && isBuffer(parent)) {
          if (Buffer.allocUnsafe) {
            // Node.js >= 4.5.0
            child = Buffer.allocUnsafe(parent.length);
          } else {
            // Older Node.js versions
            child = new Buffer(parent.length);
          }
          parent.copy(child);
          return child;
        } else if (_instanceof(parent, Error)) {
          child = Object.create(parent);
        } else {
          if (typeof prototype == 'undefined') {
            proto = Object.getPrototypeOf(parent);
            child = Object.create(proto);
          }
          else {
            child = Object.create(prototype);
            proto = prototype;
          }
        }

        if (circular) {
          var index = allParents.indexOf(parent);

          if (index != -1) {
            return allChildren[index];
          }
          allParents.push(parent);
          allChildren.push(child);
        }

        if (_instanceof(parent, nativeMap)) {
          parent.forEach(function(value, key) {
            var keyChild = _clone(key, depth - 1);
            var valueChild = _clone(value, depth - 1);
            child.set(keyChild, valueChild);
          });
        }
        if (_instanceof(parent, nativeSet)) {
          parent.forEach(function(value) {
            var entryChild = _clone(value, depth - 1);
            child.add(entryChild);
          });
        }

        for (var i in parent) {
          var attrs;
          if (proto) {
            attrs = Object.getOwnPropertyDescriptor(proto, i);
          }

          if (attrs && attrs.set == null) {
            continue;
          }
          child[i] = _clone(parent[i], depth - 1);
        }

        if (Object.getOwnPropertySymbols) {
          var symbols = Object.getOwnPropertySymbols(parent);
          for (var i = 0; i < symbols.length; i++) {
            // Don't need to worry about cloning a symbol because it is a primitive,
            // like a number or string.
            var symbol = symbols[i];
            var descriptor = Object.getOwnPropertyDescriptor(parent, symbol);
            if (descriptor && !descriptor.enumerable && !includeNonEnumerable) {
              continue;
            }
            child[symbol] = _clone(parent[symbol], depth - 1);
            if (!descriptor.enumerable) {
              Object.defineProperty(child, symbol, {
                enumerable: false
              });
            }
          }
        }

        if (includeNonEnumerable) {
          var allPropertyNames = Object.getOwnPropertyNames(parent);
          for (var i = 0; i < allPropertyNames.length; i++) {
            var propertyName = allPropertyNames[i];
            var descriptor = Object.getOwnPropertyDescriptor(parent, propertyName);
            if (descriptor && descriptor.enumerable) {
              continue;
            }
            child[propertyName] = _clone(parent[propertyName], depth - 1);
            Object.defineProperty(child, propertyName, {
              enumerable: false
            });
          }
        }

        return child;
      }

      return _clone(parent, depth);
    }

    /**
     * Simple flat clone using prototype, accepts only objects, usefull for property
     * override on FLAT configuration object (no nested props).
     *
     * USE WITH CAUTION! This may not behave as you wish if you do not know how this
     * works.
     */
    clone.clonePrototype = function clonePrototype(parent) {
      if (parent === null)
        return null;

      var c = function () {};
      c.prototype = parent;
      return new c();
    };

    // private utility functions

    function __objToStr(o) {
      return Object.prototype.toString.call(o);
    }
    clone.__objToStr = __objToStr;

    function __isDate(o) {
      return typeof o === 'object' && __objToStr(o) === '[object Date]';
    }
    clone.__isDate = __isDate;

    function __isArray(o) {
      return typeof o === 'object' && __objToStr(o) === '[object Array]';
    }
    clone.__isArray = __isArray;

    function __isRegExp(o) {
      return typeof o === 'object' && __objToStr(o) === '[object RegExp]';
    }
    clone.__isRegExp = __isRegExp;

    function __getRegExpFlags(re) {
      var flags = '';
      if (re.global) flags += 'g';
      if (re.ignoreCase) flags += 'i';
      if (re.multiline) flags += 'm';
      return flags;
    }
    clone.__getRegExpFlags = __getRegExpFlags;

    return clone;
    })();

    if (typeof module === 'object' && module.exports) {
      module.exports = clone;
    }


    /***/ }),
    /* 22 */
    /***/ (function(module, exports, __webpack_require__) {


    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

    var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

    var _parchment = __webpack_require__(0);

    var _parchment2 = _interopRequireDefault(_parchment);

    var _emitter = __webpack_require__(8);

    var _emitter2 = _interopRequireDefault(_emitter);

    var _block = __webpack_require__(4);

    var _block2 = _interopRequireDefault(_block);

    var _break = __webpack_require__(16);

    var _break2 = _interopRequireDefault(_break);

    var _code = __webpack_require__(13);

    var _code2 = _interopRequireDefault(_code);

    var _container = __webpack_require__(25);

    var _container2 = _interopRequireDefault(_container);

    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    function isLine(blot) {
      return blot instanceof _block2.default || blot instanceof _block.BlockEmbed;
    }

    var Scroll = function (_Parchment$Scroll) {
      _inherits(Scroll, _Parchment$Scroll);

      function Scroll(domNode, config) {
        _classCallCheck(this, Scroll);

        var _this = _possibleConstructorReturn(this, (Scroll.__proto__ || Object.getPrototypeOf(Scroll)).call(this, domNode));

        _this.emitter = config.emitter;
        if (Array.isArray(config.whitelist)) {
          _this.whitelist = config.whitelist.reduce(function (whitelist, format) {
            whitelist[format] = true;
            return whitelist;
          }, {});
        }
        // Some reason fixes composition issues with character languages in Windows/Chrome, Safari
        _this.domNode.addEventListener('DOMNodeInserted', function () {});
        _this.optimize();
        _this.enable();
        return _this;
      }

      _createClass(Scroll, [{
        key: 'batchStart',
        value: function batchStart() {
          this.batch = true;
        }
      }, {
        key: 'batchEnd',
        value: function batchEnd() {
          this.batch = false;
          this.optimize();
        }
      }, {
        key: 'deleteAt',
        value: function deleteAt(index, length) {
          var _line = this.line(index),
              _line2 = _slicedToArray(_line, 2),
              first = _line2[0],
              offset = _line2[1];

          var _line3 = this.line(index + length),
              _line4 = _slicedToArray(_line3, 1),
              last = _line4[0];

          _get(Scroll.prototype.__proto__ || Object.getPrototypeOf(Scroll.prototype), 'deleteAt', this).call(this, index, length);
          if (last != null && first !== last && offset > 0) {
            if (first instanceof _block.BlockEmbed || last instanceof _block.BlockEmbed) {
              this.optimize();
              return;
            }
            if (first instanceof _code2.default) {
              var newlineIndex = first.newlineIndex(first.length(), true);
              if (newlineIndex > -1) {
                first = first.split(newlineIndex + 1);
                if (first === last) {
                  this.optimize();
                  return;
                }
              }
            } else if (last instanceof _code2.default) {
              var _newlineIndex = last.newlineIndex(0);
              if (_newlineIndex > -1) {
                last.split(_newlineIndex + 1);
              }
            }
            var ref = last.children.head instanceof _break2.default ? null : last.children.head;
            first.moveChildren(last, ref);
            first.remove();
          }
          this.optimize();
        }
      }, {
        key: 'enable',
        value: function enable() {
          var enabled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

          this.domNode.setAttribute('contenteditable', enabled);
        }
      }, {
        key: 'formatAt',
        value: function formatAt(index, length, format, value) {
          if (this.whitelist != null && !this.whitelist[format]) return;
          _get(Scroll.prototype.__proto__ || Object.getPrototypeOf(Scroll.prototype), 'formatAt', this).call(this, index, length, format, value);
          this.optimize();
        }
      }, {
        key: 'insertAt',
        value: function insertAt(index, value, def) {
          if (def != null && this.whitelist != null && !this.whitelist[value]) return;
          if (index >= this.length()) {
            if (def == null || _parchment2.default.query(value, _parchment2.default.Scope.BLOCK) == null) {
              var blot = _parchment2.default.create(this.statics.defaultChild);
              this.appendChild(blot);
              if (def == null && value.endsWith('\n')) {
                value = value.slice(0, -1);
              }
              blot.insertAt(0, value, def);
            } else {
              var embed = _parchment2.default.create(value, def);
              this.appendChild(embed);
            }
          } else {
            _get(Scroll.prototype.__proto__ || Object.getPrototypeOf(Scroll.prototype), 'insertAt', this).call(this, index, value, def);
          }
          this.optimize();
        }
      }, {
        key: 'insertBefore',
        value: function insertBefore(blot, ref) {
          if (blot.statics.scope === _parchment2.default.Scope.INLINE_BLOT) {
            var wrapper = _parchment2.default.create(this.statics.defaultChild);
            wrapper.appendChild(blot);
            blot = wrapper;
          }
          _get(Scroll.prototype.__proto__ || Object.getPrototypeOf(Scroll.prototype), 'insertBefore', this).call(this, blot, ref);
        }
      }, {
        key: 'leaf',
        value: function leaf(index) {
          return this.path(index).pop() || [null, -1];
        }
      }, {
        key: 'line',
        value: function line(index) {
          if (index === this.length()) {
            return this.line(index - 1);
          }
          return this.descendant(isLine, index);
        }
      }, {
        key: 'lines',
        value: function lines() {
          var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
          var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Number.MAX_VALUE;

          var getLines = function getLines(blot, index, length) {
            var lines = [],
                lengthLeft = length;
            blot.children.forEachAt(index, length, function (child, index, length) {
              if (isLine(child)) {
                lines.push(child);
              } else if (child instanceof _parchment2.default.Container) {
                lines = lines.concat(getLines(child, index, lengthLeft));
              }
              lengthLeft -= length;
            });
            return lines;
          };
          return getLines(this, index, length);
        }
      }, {
        key: 'optimize',
        value: function optimize() {
          var mutations = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
          var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

          if (this.batch === true) return;
          _get(Scroll.prototype.__proto__ || Object.getPrototypeOf(Scroll.prototype), 'optimize', this).call(this, mutations, context);
          if (mutations.length > 0) {
            this.emitter.emit(_emitter2.default.events.SCROLL_OPTIMIZE, mutations, context);
          }
        }
      }, {
        key: 'path',
        value: function path(index) {
          return _get(Scroll.prototype.__proto__ || Object.getPrototypeOf(Scroll.prototype), 'path', this).call(this, index).slice(1); // Exclude self
        }
      }, {
        key: 'update',
        value: function update(mutations) {
          if (this.batch === true) return;
          var source = _emitter2.default.sources.USER;
          if (typeof mutations === 'string') {
            source = mutations;
          }
          if (!Array.isArray(mutations)) {
            mutations = this.observer.takeRecords();
          }
          if (mutations.length > 0) {
            this.emitter.emit(_emitter2.default.events.SCROLL_BEFORE_UPDATE, source, mutations);
          }
          _get(Scroll.prototype.__proto__ || Object.getPrototypeOf(Scroll.prototype), 'update', this).call(this, mutations.concat([])); // pass copy
          if (mutations.length > 0) {
            this.emitter.emit(_emitter2.default.events.SCROLL_UPDATE, source, mutations);
          }
        }
      }]);

      return Scroll;
    }(_parchment2.default.Scroll);

    Scroll.blotName = 'scroll';
    Scroll.className = 'ql-editor';
    Scroll.tagName = 'DIV';
    Scroll.defaultChild = 'block';
    Scroll.allowedChildren = [_block2.default, _block.BlockEmbed, _container2.default];

    exports.default = Scroll;

    /***/ }),
    /* 23 */
    /***/ (function(module, exports, __webpack_require__) {


    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.SHORTKEY = exports.default = undefined;

    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

    var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

    var _clone = __webpack_require__(21);

    var _clone2 = _interopRequireDefault(_clone);

    var _deepEqual = __webpack_require__(11);

    var _deepEqual2 = _interopRequireDefault(_deepEqual);

    var _extend = __webpack_require__(3);

    var _extend2 = _interopRequireDefault(_extend);

    var _quillDelta = __webpack_require__(2);

    var _quillDelta2 = _interopRequireDefault(_quillDelta);

    var _op = __webpack_require__(20);

    var _op2 = _interopRequireDefault(_op);

    var _parchment = __webpack_require__(0);

    var _parchment2 = _interopRequireDefault(_parchment);

    var _quill = __webpack_require__(5);

    var _quill2 = _interopRequireDefault(_quill);

    var _logger = __webpack_require__(10);

    var _logger2 = _interopRequireDefault(_logger);

    var _module = __webpack_require__(9);

    var _module2 = _interopRequireDefault(_module);

    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    var debug = (0, _logger2.default)('quill:keyboard');

    var SHORTKEY = /Mac/i.test(navigator.platform) ? 'metaKey' : 'ctrlKey';

    var Keyboard = function (_Module) {
      _inherits(Keyboard, _Module);

      _createClass(Keyboard, null, [{
        key: 'match',
        value: function match(evt, binding) {
          binding = normalize(binding);
          if (['altKey', 'ctrlKey', 'metaKey', 'shiftKey'].some(function (key) {
            return !!binding[key] !== evt[key] && binding[key] !== null;
          })) {
            return false;
          }
          return binding.key === (evt.which || evt.keyCode);
        }
      }]);

      function Keyboard(quill, options) {
        _classCallCheck(this, Keyboard);

        var _this = _possibleConstructorReturn(this, (Keyboard.__proto__ || Object.getPrototypeOf(Keyboard)).call(this, quill, options));

        _this.bindings = {};
        Object.keys(_this.options.bindings).forEach(function (name) {
          if (name === 'list autofill' && quill.scroll.whitelist != null && !quill.scroll.whitelist['list']) {
            return;
          }
          if (_this.options.bindings[name]) {
            _this.addBinding(_this.options.bindings[name]);
          }
        });
        _this.addBinding({ key: Keyboard.keys.ENTER, shiftKey: null }, handleEnter);
        _this.addBinding({ key: Keyboard.keys.ENTER, metaKey: null, ctrlKey: null, altKey: null }, function () {});
        if (/Firefox/i.test(navigator.userAgent)) {
          // Need to handle delete and backspace for Firefox in the general case #1171
          _this.addBinding({ key: Keyboard.keys.BACKSPACE }, { collapsed: true }, handleBackspace);
          _this.addBinding({ key: Keyboard.keys.DELETE }, { collapsed: true }, handleDelete);
        } else {
          _this.addBinding({ key: Keyboard.keys.BACKSPACE }, { collapsed: true, prefix: /^.?$/ }, handleBackspace);
          _this.addBinding({ key: Keyboard.keys.DELETE }, { collapsed: true, suffix: /^.?$/ }, handleDelete);
        }
        _this.addBinding({ key: Keyboard.keys.BACKSPACE }, { collapsed: false }, handleDeleteRange);
        _this.addBinding({ key: Keyboard.keys.DELETE }, { collapsed: false }, handleDeleteRange);
        _this.addBinding({ key: Keyboard.keys.BACKSPACE, altKey: null, ctrlKey: null, metaKey: null, shiftKey: null }, { collapsed: true, offset: 0 }, handleBackspace);
        _this.listen();
        return _this;
      }

      _createClass(Keyboard, [{
        key: 'addBinding',
        value: function addBinding(key) {
          var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
          var handler = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

          var binding = normalize(key);
          if (binding == null || binding.key == null) {
            return debug.warn('Attempted to add invalid keyboard binding', binding);
          }
          if (typeof context === 'function') {
            context = { handler: context };
          }
          if (typeof handler === 'function') {
            handler = { handler: handler };
          }
          binding = (0, _extend2.default)(binding, context, handler);
          this.bindings[binding.key] = this.bindings[binding.key] || [];
          this.bindings[binding.key].push(binding);
        }
      }, {
        key: 'listen',
        value: function listen() {
          var _this2 = this;

          this.quill.root.addEventListener('keydown', function (evt) {
            if (evt.defaultPrevented) return;
            var which = evt.which || evt.keyCode;
            var bindings = (_this2.bindings[which] || []).filter(function (binding) {
              return Keyboard.match(evt, binding);
            });
            if (bindings.length === 0) return;
            var range = _this2.quill.getSelection();
            if (range == null || !_this2.quill.hasFocus()) return;

            var _quill$getLine = _this2.quill.getLine(range.index),
                _quill$getLine2 = _slicedToArray(_quill$getLine, 2),
                line = _quill$getLine2[0],
                offset = _quill$getLine2[1];

            var _quill$getLeaf = _this2.quill.getLeaf(range.index),
                _quill$getLeaf2 = _slicedToArray(_quill$getLeaf, 2),
                leafStart = _quill$getLeaf2[0],
                offsetStart = _quill$getLeaf2[1];

            var _ref = range.length === 0 ? [leafStart, offsetStart] : _this2.quill.getLeaf(range.index + range.length),
                _ref2 = _slicedToArray(_ref, 2),
                leafEnd = _ref2[0],
                offsetEnd = _ref2[1];

            var prefixText = leafStart instanceof _parchment2.default.Text ? leafStart.value().slice(0, offsetStart) : '';
            var suffixText = leafEnd instanceof _parchment2.default.Text ? leafEnd.value().slice(offsetEnd) : '';
            var curContext = {
              collapsed: range.length === 0,
              empty: range.length === 0 && line.length() <= 1,
              format: _this2.quill.getFormat(range),
              offset: offset,
              prefix: prefixText,
              suffix: suffixText
            };
            var prevented = bindings.some(function (binding) {
              if (binding.collapsed != null && binding.collapsed !== curContext.collapsed) return false;
              if (binding.empty != null && binding.empty !== curContext.empty) return false;
              if (binding.offset != null && binding.offset !== curContext.offset) return false;
              if (Array.isArray(binding.format)) {
                // any format is present
                if (binding.format.every(function (name) {
                  return curContext.format[name] == null;
                })) {
                  return false;
                }
              } else if (_typeof(binding.format) === 'object') {
                // all formats must match
                if (!Object.keys(binding.format).every(function (name) {
                  if (binding.format[name] === true) return curContext.format[name] != null;
                  if (binding.format[name] === false) return curContext.format[name] == null;
                  return (0, _deepEqual2.default)(binding.format[name], curContext.format[name]);
                })) {
                  return false;
                }
              }
              if (binding.prefix != null && !binding.prefix.test(curContext.prefix)) return false;
              if (binding.suffix != null && !binding.suffix.test(curContext.suffix)) return false;
              return binding.handler.call(_this2, range, curContext) !== true;
            });
            if (prevented) {
              evt.preventDefault();
            }
          });
        }
      }]);

      return Keyboard;
    }(_module2.default);

    Keyboard.keys = {
      BACKSPACE: 8,
      TAB: 9,
      ENTER: 13,
      ESCAPE: 27,
      LEFT: 37,
      UP: 38,
      RIGHT: 39,
      DOWN: 40,
      DELETE: 46
    };

    Keyboard.DEFAULTS = {
      bindings: {
        'bold': makeFormatHandler('bold'),
        'italic': makeFormatHandler('italic'),
        'underline': makeFormatHandler('underline'),
        'indent': {
          // highlight tab or tab at beginning of list, indent or blockquote
          key: Keyboard.keys.TAB,
          format: ['blockquote', 'indent', 'list'],
          handler: function handler(range, context) {
            if (context.collapsed && context.offset !== 0) return true;
            this.quill.format('indent', '+1', _quill2.default.sources.USER);
          }
        },
        'outdent': {
          key: Keyboard.keys.TAB,
          shiftKey: true,
          format: ['blockquote', 'indent', 'list'],
          // highlight tab or tab at beginning of list, indent or blockquote
          handler: function handler(range, context) {
            if (context.collapsed && context.offset !== 0) return true;
            this.quill.format('indent', '-1', _quill2.default.sources.USER);
          }
        },
        'outdent backspace': {
          key: Keyboard.keys.BACKSPACE,
          collapsed: true,
          shiftKey: null,
          metaKey: null,
          ctrlKey: null,
          altKey: null,
          format: ['indent', 'list'],
          offset: 0,
          handler: function handler(range, context) {
            if (context.format.indent != null) {
              this.quill.format('indent', '-1', _quill2.default.sources.USER);
            } else if (context.format.list != null) {
              this.quill.format('list', false, _quill2.default.sources.USER);
            }
          }
        },
        'indent code-block': makeCodeBlockHandler(true),
        'outdent code-block': makeCodeBlockHandler(false),
        'remove tab': {
          key: Keyboard.keys.TAB,
          shiftKey: true,
          collapsed: true,
          prefix: /\t$/,
          handler: function handler(range) {
            this.quill.deleteText(range.index - 1, 1, _quill2.default.sources.USER);
          }
        },
        'tab': {
          key: Keyboard.keys.TAB,
          handler: function handler(range) {
            this.quill.history.cutoff();
            var delta = new _quillDelta2.default().retain(range.index).delete(range.length).insert('\t');
            this.quill.updateContents(delta, _quill2.default.sources.USER);
            this.quill.history.cutoff();
            this.quill.setSelection(range.index + 1, _quill2.default.sources.SILENT);
          }
        },
        'list empty enter': {
          key: Keyboard.keys.ENTER,
          collapsed: true,
          format: ['list'],
          empty: true,
          handler: function handler(range, context) {
            this.quill.format('list', false, _quill2.default.sources.USER);
            if (context.format.indent) {
              this.quill.format('indent', false, _quill2.default.sources.USER);
            }
          }
        },
        'checklist enter': {
          key: Keyboard.keys.ENTER,
          collapsed: true,
          format: { list: 'checked' },
          handler: function handler(range) {
            var _quill$getLine3 = this.quill.getLine(range.index),
                _quill$getLine4 = _slicedToArray(_quill$getLine3, 2),
                line = _quill$getLine4[0],
                offset = _quill$getLine4[1];

            var formats = (0, _extend2.default)({}, line.formats(), { list: 'checked' });
            var delta = new _quillDelta2.default().retain(range.index).insert('\n', formats).retain(line.length() - offset - 1).retain(1, { list: 'unchecked' });
            this.quill.updateContents(delta, _quill2.default.sources.USER);
            this.quill.setSelection(range.index + 1, _quill2.default.sources.SILENT);
            this.quill.scrollIntoView();
          }
        },
        'header enter': {
          key: Keyboard.keys.ENTER,
          collapsed: true,
          format: ['header'],
          suffix: /^$/,
          handler: function handler(range, context) {
            var _quill$getLine5 = this.quill.getLine(range.index),
                _quill$getLine6 = _slicedToArray(_quill$getLine5, 2),
                line = _quill$getLine6[0],
                offset = _quill$getLine6[1];

            var delta = new _quillDelta2.default().retain(range.index).insert('\n', context.format).retain(line.length() - offset - 1).retain(1, { header: null });
            this.quill.updateContents(delta, _quill2.default.sources.USER);
            this.quill.setSelection(range.index + 1, _quill2.default.sources.SILENT);
            this.quill.scrollIntoView();
          }
        },
        'list autofill': {
          key: ' ',
          collapsed: true,
          format: { list: false },
          prefix: /^\s*?(\d+\.|-|\*|\[ ?\]|\[x\])$/,
          handler: function handler(range, context) {
            var length = context.prefix.length;

            var _quill$getLine7 = this.quill.getLine(range.index),
                _quill$getLine8 = _slicedToArray(_quill$getLine7, 2),
                line = _quill$getLine8[0],
                offset = _quill$getLine8[1];

            if (offset > length) return true;
            var value = void 0;
            switch (context.prefix.trim()) {
              case '[]':case '[ ]':
                value = 'unchecked';
                break;
              case '[x]':
                value = 'checked';
                break;
              case '-':case '*':
                value = 'bullet';
                break;
              default:
                value = 'ordered';
            }
            this.quill.insertText(range.index, ' ', _quill2.default.sources.USER);
            this.quill.history.cutoff();
            var delta = new _quillDelta2.default().retain(range.index - offset).delete(length + 1).retain(line.length() - 2 - offset).retain(1, { list: value });
            this.quill.updateContents(delta, _quill2.default.sources.USER);
            this.quill.history.cutoff();
            this.quill.setSelection(range.index - length, _quill2.default.sources.SILENT);
          }
        },
        'code exit': {
          key: Keyboard.keys.ENTER,
          collapsed: true,
          format: ['code-block'],
          prefix: /\n\n$/,
          suffix: /^\s+$/,
          handler: function handler(range) {
            var _quill$getLine9 = this.quill.getLine(range.index),
                _quill$getLine10 = _slicedToArray(_quill$getLine9, 2),
                line = _quill$getLine10[0],
                offset = _quill$getLine10[1];

            var delta = new _quillDelta2.default().retain(range.index + line.length() - offset - 2).retain(1, { 'code-block': null }).delete(1);
            this.quill.updateContents(delta, _quill2.default.sources.USER);
          }
        },
        'embed left': makeEmbedArrowHandler(Keyboard.keys.LEFT, false),
        'embed left shift': makeEmbedArrowHandler(Keyboard.keys.LEFT, true),
        'embed right': makeEmbedArrowHandler(Keyboard.keys.RIGHT, false),
        'embed right shift': makeEmbedArrowHandler(Keyboard.keys.RIGHT, true)
      }
    };

    function makeEmbedArrowHandler(key, shiftKey) {
      var _ref3;

      var where = key === Keyboard.keys.LEFT ? 'prefix' : 'suffix';
      return _ref3 = {
        key: key,
        shiftKey: shiftKey,
        altKey: null
      }, _defineProperty(_ref3, where, /^$/), _defineProperty(_ref3, 'handler', function handler(range) {
        var index = range.index;
        if (key === Keyboard.keys.RIGHT) {
          index += range.length + 1;
        }

        var _quill$getLeaf3 = this.quill.getLeaf(index),
            _quill$getLeaf4 = _slicedToArray(_quill$getLeaf3, 1),
            leaf = _quill$getLeaf4[0];

        if (!(leaf instanceof _parchment2.default.Embed)) return true;
        if (key === Keyboard.keys.LEFT) {
          if (shiftKey) {
            this.quill.setSelection(range.index - 1, range.length + 1, _quill2.default.sources.USER);
          } else {
            this.quill.setSelection(range.index - 1, _quill2.default.sources.USER);
          }
        } else {
          if (shiftKey) {
            this.quill.setSelection(range.index, range.length + 1, _quill2.default.sources.USER);
          } else {
            this.quill.setSelection(range.index + range.length + 1, _quill2.default.sources.USER);
          }
        }
        return false;
      }), _ref3;
    }

    function handleBackspace(range, context) {
      if (range.index === 0 || this.quill.getLength() <= 1) return;

      var _quill$getLine11 = this.quill.getLine(range.index),
          _quill$getLine12 = _slicedToArray(_quill$getLine11, 1),
          line = _quill$getLine12[0];

      var formats = {};
      if (context.offset === 0) {
        var _quill$getLine13 = this.quill.getLine(range.index - 1),
            _quill$getLine14 = _slicedToArray(_quill$getLine13, 1),
            prev = _quill$getLine14[0];

        if (prev != null && prev.length() > 1) {
          var curFormats = line.formats();
          var prevFormats = this.quill.getFormat(range.index - 1, 1);
          formats = _op2.default.attributes.diff(curFormats, prevFormats) || {};
        }
      }
      // Check for astral symbols
      var length = /[\uD800-\uDBFF][\uDC00-\uDFFF]$/.test(context.prefix) ? 2 : 1;
      this.quill.deleteText(range.index - length, length, _quill2.default.sources.USER);
      if (Object.keys(formats).length > 0) {
        this.quill.formatLine(range.index - length, length, formats, _quill2.default.sources.USER);
      }
      this.quill.focus();
    }

    function handleDelete(range, context) {
      // Check for astral symbols
      var length = /^[\uD800-\uDBFF][\uDC00-\uDFFF]/.test(context.suffix) ? 2 : 1;
      if (range.index >= this.quill.getLength() - length) return;
      var formats = {},
          nextLength = 0;

      var _quill$getLine15 = this.quill.getLine(range.index),
          _quill$getLine16 = _slicedToArray(_quill$getLine15, 1),
          line = _quill$getLine16[0];

      if (context.offset >= line.length() - 1) {
        var _quill$getLine17 = this.quill.getLine(range.index + 1),
            _quill$getLine18 = _slicedToArray(_quill$getLine17, 1),
            next = _quill$getLine18[0];

        if (next) {
          var curFormats = line.formats();
          var nextFormats = this.quill.getFormat(range.index, 1);
          formats = _op2.default.attributes.diff(curFormats, nextFormats) || {};
          nextLength = next.length();
        }
      }
      this.quill.deleteText(range.index, length, _quill2.default.sources.USER);
      if (Object.keys(formats).length > 0) {
        this.quill.formatLine(range.index + nextLength - 1, length, formats, _quill2.default.sources.USER);
      }
    }

    function handleDeleteRange(range) {
      var lines = this.quill.getLines(range);
      var formats = {};
      if (lines.length > 1) {
        var firstFormats = lines[0].formats();
        var lastFormats = lines[lines.length - 1].formats();
        formats = _op2.default.attributes.diff(lastFormats, firstFormats) || {};
      }
      this.quill.deleteText(range, _quill2.default.sources.USER);
      if (Object.keys(formats).length > 0) {
        this.quill.formatLine(range.index, 1, formats, _quill2.default.sources.USER);
      }
      this.quill.setSelection(range.index, _quill2.default.sources.SILENT);
      this.quill.focus();
    }

    function handleEnter(range, context) {
      var _this3 = this;

      if (range.length > 0) {
        this.quill.scroll.deleteAt(range.index, range.length); // So we do not trigger text-change
      }
      var lineFormats = Object.keys(context.format).reduce(function (lineFormats, format) {
        if (_parchment2.default.query(format, _parchment2.default.Scope.BLOCK) && !Array.isArray(context.format[format])) {
          lineFormats[format] = context.format[format];
        }
        return lineFormats;
      }, {});
      this.quill.insertText(range.index, '\n', lineFormats, _quill2.default.sources.USER);
      // Earlier scroll.deleteAt might have messed up our selection,
      // so insertText's built in selection preservation is not reliable
      this.quill.setSelection(range.index + 1, _quill2.default.sources.SILENT);
      this.quill.focus();
      Object.keys(context.format).forEach(function (name) {
        if (lineFormats[name] != null) return;
        if (Array.isArray(context.format[name])) return;
        if (name === 'link') return;
        _this3.quill.format(name, context.format[name], _quill2.default.sources.USER);
      });
    }

    function makeCodeBlockHandler(indent) {
      return {
        key: Keyboard.keys.TAB,
        shiftKey: !indent,
        format: { 'code-block': true },
        handler: function handler(range) {
          var CodeBlock = _parchment2.default.query('code-block');
          var index = range.index,
              length = range.length;

          var _quill$scroll$descend = this.quill.scroll.descendant(CodeBlock, index),
              _quill$scroll$descend2 = _slicedToArray(_quill$scroll$descend, 2),
              block = _quill$scroll$descend2[0],
              offset = _quill$scroll$descend2[1];

          if (block == null) return;
          var scrollIndex = this.quill.getIndex(block);
          var start = block.newlineIndex(offset, true) + 1;
          var end = block.newlineIndex(scrollIndex + offset + length);
          var lines = block.domNode.textContent.slice(start, end).split('\n');
          offset = 0;
          lines.forEach(function (line, i) {
            if (indent) {
              block.insertAt(start + offset, CodeBlock.TAB);
              offset += CodeBlock.TAB.length;
              if (i === 0) {
                index += CodeBlock.TAB.length;
              } else {
                length += CodeBlock.TAB.length;
              }
            } else if (line.startsWith(CodeBlock.TAB)) {
              block.deleteAt(start + offset, CodeBlock.TAB.length);
              offset -= CodeBlock.TAB.length;
              if (i === 0) {
                index -= CodeBlock.TAB.length;
              } else {
                length -= CodeBlock.TAB.length;
              }
            }
            offset += line.length + 1;
          });
          this.quill.update(_quill2.default.sources.USER);
          this.quill.setSelection(index, length, _quill2.default.sources.SILENT);
        }
      };
    }

    function makeFormatHandler(format) {
      return {
        key: format[0].toUpperCase(),
        shortKey: true,
        handler: function handler(range, context) {
          this.quill.format(format, !context.format[format], _quill2.default.sources.USER);
        }
      };
    }

    function normalize(binding) {
      if (typeof binding === 'string' || typeof binding === 'number') {
        return normalize({ key: binding });
      }
      if ((typeof binding === 'undefined' ? 'undefined' : _typeof(binding)) === 'object') {
        binding = (0, _clone2.default)(binding, false);
      }
      if (typeof binding.key === 'string') {
        if (Keyboard.keys[binding.key.toUpperCase()] != null) {
          binding.key = Keyboard.keys[binding.key.toUpperCase()];
        } else if (binding.key.length === 1) {
          binding.key = binding.key.toUpperCase().charCodeAt(0);
        } else {
          return null;
        }
      }
      if (binding.shortKey) {
        binding[SHORTKEY] = binding.shortKey;
        delete binding.shortKey;
      }
      return binding;
    }

    exports.default = Keyboard;
    exports.SHORTKEY = SHORTKEY;

    /***/ }),
    /* 24 */
    /***/ (function(module, exports, __webpack_require__) {


    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

    var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

    var _parchment = __webpack_require__(0);

    var _parchment2 = _interopRequireDefault(_parchment);

    var _text = __webpack_require__(7);

    var _text2 = _interopRequireDefault(_text);

    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    var Cursor = function (_Parchment$Embed) {
      _inherits(Cursor, _Parchment$Embed);

      _createClass(Cursor, null, [{
        key: 'value',
        value: function value() {
          return undefined;
        }
      }]);

      function Cursor(domNode, selection) {
        _classCallCheck(this, Cursor);

        var _this = _possibleConstructorReturn(this, (Cursor.__proto__ || Object.getPrototypeOf(Cursor)).call(this, domNode));

        _this.selection = selection;
        _this.textNode = document.createTextNode(Cursor.CONTENTS);
        _this.domNode.appendChild(_this.textNode);
        _this._length = 0;
        return _this;
      }

      _createClass(Cursor, [{
        key: 'detach',
        value: function detach() {
          // super.detach() will also clear domNode.__blot
          if (this.parent != null) this.parent.removeChild(this);
        }
      }, {
        key: 'format',
        value: function format(name, value) {
          if (this._length !== 0) {
            return _get(Cursor.prototype.__proto__ || Object.getPrototypeOf(Cursor.prototype), 'format', this).call(this, name, value);
          }
          var target = this,
              index = 0;
          while (target != null && target.statics.scope !== _parchment2.default.Scope.BLOCK_BLOT) {
            index += target.offset(target.parent);
            target = target.parent;
          }
          if (target != null) {
            this._length = Cursor.CONTENTS.length;
            target.optimize();
            target.formatAt(index, Cursor.CONTENTS.length, name, value);
            this._length = 0;
          }
        }
      }, {
        key: 'index',
        value: function index(node, offset) {
          if (node === this.textNode) return 0;
          return _get(Cursor.prototype.__proto__ || Object.getPrototypeOf(Cursor.prototype), 'index', this).call(this, node, offset);
        }
      }, {
        key: 'length',
        value: function length() {
          return this._length;
        }
      }, {
        key: 'position',
        value: function position() {
          return [this.textNode, this.textNode.data.length];
        }
      }, {
        key: 'remove',
        value: function remove() {
          _get(Cursor.prototype.__proto__ || Object.getPrototypeOf(Cursor.prototype), 'remove', this).call(this);
          this.parent = null;
        }
      }, {
        key: 'restore',
        value: function restore() {
          if (this.selection.composing || this.parent == null) return;
          var textNode = this.textNode;
          var range = this.selection.getNativeRange();
          var restoreText = void 0,
              start = void 0,
              end = void 0;
          if (range != null && range.start.node === textNode && range.end.node === textNode) {
            var _ref = [textNode, range.start.offset, range.end.offset];
            restoreText = _ref[0];
            start = _ref[1];
            end = _ref[2];
          }
          // Link format will insert text outside of anchor tag
          while (this.domNode.lastChild != null && this.domNode.lastChild !== this.textNode) {
            this.domNode.parentNode.insertBefore(this.domNode.lastChild, this.domNode);
          }
          if (this.textNode.data !== Cursor.CONTENTS) {
            var text = this.textNode.data.split(Cursor.CONTENTS).join('');
            if (this.next instanceof _text2.default) {
              restoreText = this.next.domNode;
              this.next.insertAt(0, text);
              this.textNode.data = Cursor.CONTENTS;
            } else {
              this.textNode.data = text;
              this.parent.insertBefore(_parchment2.default.create(this.textNode), this);
              this.textNode = document.createTextNode(Cursor.CONTENTS);
              this.domNode.appendChild(this.textNode);
            }
          }
          this.remove();
          if (start != null) {
            var _map = [start, end].map(function (offset) {
              return Math.max(0, Math.min(restoreText.data.length, offset - 1));
            });

            var _map2 = _slicedToArray(_map, 2);

            start = _map2[0];
            end = _map2[1];

            return {
              startNode: restoreText,
              startOffset: start,
              endNode: restoreText,
              endOffset: end
            };
          }
        }
      }, {
        key: 'update',
        value: function update(mutations, context) {
          var _this2 = this;

          if (mutations.some(function (mutation) {
            return mutation.type === 'characterData' && mutation.target === _this2.textNode;
          })) {
            var range = this.restore();
            if (range) context.range = range;
          }
        }
      }, {
        key: 'value',
        value: function value() {
          return '';
        }
      }]);

      return Cursor;
    }(_parchment2.default.Embed);

    Cursor.blotName = 'cursor';
    Cursor.className = 'ql-cursor';
    Cursor.tagName = 'span';
    Cursor.CONTENTS = '\uFEFF'; // Zero width no break space


    exports.default = Cursor;

    /***/ }),
    /* 25 */
    /***/ (function(module, exports, __webpack_require__) {


    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    var _parchment = __webpack_require__(0);

    var _parchment2 = _interopRequireDefault(_parchment);

    var _block = __webpack_require__(4);

    var _block2 = _interopRequireDefault(_block);

    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    var Container = function (_Parchment$Container) {
      _inherits(Container, _Parchment$Container);

      function Container() {
        _classCallCheck(this, Container);

        return _possibleConstructorReturn(this, (Container.__proto__ || Object.getPrototypeOf(Container)).apply(this, arguments));
      }

      return Container;
    }(_parchment2.default.Container);

    Container.allowedChildren = [_block2.default, _block.BlockEmbed, Container];

    exports.default = Container;

    /***/ }),
    /* 26 */
    /***/ (function(module, exports, __webpack_require__) {


    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.ColorStyle = exports.ColorClass = exports.ColorAttributor = undefined;

    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

    var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

    var _parchment = __webpack_require__(0);

    var _parchment2 = _interopRequireDefault(_parchment);

    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    var ColorAttributor = function (_Parchment$Attributor) {
      _inherits(ColorAttributor, _Parchment$Attributor);

      function ColorAttributor() {
        _classCallCheck(this, ColorAttributor);

        return _possibleConstructorReturn(this, (ColorAttributor.__proto__ || Object.getPrototypeOf(ColorAttributor)).apply(this, arguments));
      }

      _createClass(ColorAttributor, [{
        key: 'value',
        value: function value(domNode) {
          var value = _get(ColorAttributor.prototype.__proto__ || Object.getPrototypeOf(ColorAttributor.prototype), 'value', this).call(this, domNode);
          if (!value.startsWith('rgb(')) return value;
          value = value.replace(/^[^\d]+/, '').replace(/[^\d]+$/, '');
          return '#' + value.split(',').map(function (component) {
            return ('00' + parseInt(component).toString(16)).slice(-2);
          }).join('');
        }
      }]);

      return ColorAttributor;
    }(_parchment2.default.Attributor.Style);

    var ColorClass = new _parchment2.default.Attributor.Class('color', 'ql-color', {
      scope: _parchment2.default.Scope.INLINE
    });
    var ColorStyle = new ColorAttributor('color', 'color', {
      scope: _parchment2.default.Scope.INLINE
    });

    exports.ColorAttributor = ColorAttributor;
    exports.ColorClass = ColorClass;
    exports.ColorStyle = ColorStyle;

    /***/ }),
    /* 27 */
    /***/ (function(module, exports, __webpack_require__) {


    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.sanitize = exports.default = undefined;

    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

    var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

    var _inline = __webpack_require__(6);

    var _inline2 = _interopRequireDefault(_inline);

    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    var Link = function (_Inline) {
      _inherits(Link, _Inline);

      function Link() {
        _classCallCheck(this, Link);

        return _possibleConstructorReturn(this, (Link.__proto__ || Object.getPrototypeOf(Link)).apply(this, arguments));
      }

      _createClass(Link, [{
        key: 'format',
        value: function format(name, value) {
          if (name !== this.statics.blotName || !value) return _get(Link.prototype.__proto__ || Object.getPrototypeOf(Link.prototype), 'format', this).call(this, name, value);
          value = this.constructor.sanitize(value);
          this.domNode.setAttribute('href', value);
        }
      }], [{
        key: 'create',
        value: function create(value) {
          var node = _get(Link.__proto__ || Object.getPrototypeOf(Link), 'create', this).call(this, value);
          value = this.sanitize(value);
          node.setAttribute('href', value);
          node.setAttribute('rel', 'noopener noreferrer');
          node.setAttribute('target', '_blank');
          return node;
        }
      }, {
        key: 'formats',
        value: function formats(domNode) {
          return domNode.getAttribute('href');
        }
      }, {
        key: 'sanitize',
        value: function sanitize(url) {
          return _sanitize(url, this.PROTOCOL_WHITELIST) ? url : this.SANITIZED_URL;
        }
      }]);

      return Link;
    }(_inline2.default);

    Link.blotName = 'link';
    Link.tagName = 'A';
    Link.SANITIZED_URL = 'about:blank';
    Link.PROTOCOL_WHITELIST = ['http', 'https', 'mailto', 'tel'];

    function _sanitize(url, protocols) {
      var anchor = document.createElement('a');
      anchor.href = url;
      var protocol = anchor.href.slice(0, anchor.href.indexOf(':'));
      return protocols.indexOf(protocol) > -1;
    }

    exports.default = Link;
    exports.sanitize = _sanitize;

    /***/ }),
    /* 28 */
    /***/ (function(module, exports, __webpack_require__) {


    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

    var _keyboard = __webpack_require__(23);

    var _keyboard2 = _interopRequireDefault(_keyboard);

    var _dropdown = __webpack_require__(107);

    var _dropdown2 = _interopRequireDefault(_dropdown);

    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    var optionsCounter = 0;

    function toggleAriaAttribute(element, attribute) {
      element.setAttribute(attribute, !(element.getAttribute(attribute) === 'true'));
    }

    var Picker = function () {
      function Picker(select) {
        var _this = this;

        _classCallCheck(this, Picker);

        this.select = select;
        this.container = document.createElement('span');
        this.buildPicker();
        this.select.style.display = 'none';
        this.select.parentNode.insertBefore(this.container, this.select);

        this.label.addEventListener('mousedown', function () {
          _this.togglePicker();
        });
        this.label.addEventListener('keydown', function (event) {
          switch (event.keyCode) {
            // Allows the "Enter" key to open the picker
            case _keyboard2.default.keys.ENTER:
              _this.togglePicker();
              break;

            // Allows the "Escape" key to close the picker
            case _keyboard2.default.keys.ESCAPE:
              _this.escape();
              event.preventDefault();
              break;
          }
        });
        this.select.addEventListener('change', this.update.bind(this));
      }

      _createClass(Picker, [{
        key: 'togglePicker',
        value: function togglePicker() {
          this.container.classList.toggle('ql-expanded');
          // Toggle aria-expanded and aria-hidden to make the picker accessible
          toggleAriaAttribute(this.label, 'aria-expanded');
          toggleAriaAttribute(this.options, 'aria-hidden');
        }
      }, {
        key: 'buildItem',
        value: function buildItem(option) {
          var _this2 = this;

          var item = document.createElement('span');
          item.tabIndex = '0';
          item.setAttribute('role', 'button');

          item.classList.add('ql-picker-item');
          if (option.hasAttribute('value')) {
            item.setAttribute('data-value', option.getAttribute('value'));
          }
          if (option.textContent) {
            item.setAttribute('data-label', option.textContent);
          }
          item.addEventListener('click', function () {
            _this2.selectItem(item, true);
          });
          item.addEventListener('keydown', function (event) {
            switch (event.keyCode) {
              // Allows the "Enter" key to select an item
              case _keyboard2.default.keys.ENTER:
                _this2.selectItem(item, true);
                event.preventDefault();
                break;

              // Allows the "Escape" key to close the picker
              case _keyboard2.default.keys.ESCAPE:
                _this2.escape();
                event.preventDefault();
                break;
            }
          });

          return item;
        }
      }, {
        key: 'buildLabel',
        value: function buildLabel() {
          var label = document.createElement('span');
          label.classList.add('ql-picker-label');
          label.innerHTML = _dropdown2.default;
          label.tabIndex = '0';
          label.setAttribute('role', 'button');
          label.setAttribute('aria-expanded', 'false');
          this.container.appendChild(label);
          return label;
        }
      }, {
        key: 'buildOptions',
        value: function buildOptions() {
          var _this3 = this;

          var options = document.createElement('span');
          options.classList.add('ql-picker-options');

          // Don't want screen readers to read this until options are visible
          options.setAttribute('aria-hidden', 'true');
          options.tabIndex = '-1';

          // Need a unique id for aria-controls
          options.id = 'ql-picker-options-' + optionsCounter;
          optionsCounter += 1;
          this.label.setAttribute('aria-controls', options.id);

          this.options = options;

          [].slice.call(this.select.options).forEach(function (option) {
            var item = _this3.buildItem(option);
            options.appendChild(item);
            if (option.selected === true) {
              _this3.selectItem(item);
            }
          });
          this.container.appendChild(options);
        }
      }, {
        key: 'buildPicker',
        value: function buildPicker() {
          var _this4 = this;

          [].slice.call(this.select.attributes).forEach(function (item) {
            _this4.container.setAttribute(item.name, item.value);
          });
          this.container.classList.add('ql-picker');
          this.label = this.buildLabel();
          this.buildOptions();
        }
      }, {
        key: 'escape',
        value: function escape() {
          var _this5 = this;

          // Close menu and return focus to trigger label
          this.close();
          // Need setTimeout for accessibility to ensure that the browser executes
          // focus on the next process thread and after any DOM content changes
          setTimeout(function () {
            return _this5.label.focus();
          }, 1);
        }
      }, {
        key: 'close',
        value: function close() {
          this.container.classList.remove('ql-expanded');
          this.label.setAttribute('aria-expanded', 'false');
          this.options.setAttribute('aria-hidden', 'true');
        }
      }, {
        key: 'selectItem',
        value: function selectItem(item) {
          var trigger = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

          var selected = this.container.querySelector('.ql-selected');
          if (item === selected) return;
          if (selected != null) {
            selected.classList.remove('ql-selected');
          }
          if (item == null) return;
          item.classList.add('ql-selected');
          this.select.selectedIndex = [].indexOf.call(item.parentNode.children, item);
          if (item.hasAttribute('data-value')) {
            this.label.setAttribute('data-value', item.getAttribute('data-value'));
          } else {
            this.label.removeAttribute('data-value');
          }
          if (item.hasAttribute('data-label')) {
            this.label.setAttribute('data-label', item.getAttribute('data-label'));
          } else {
            this.label.removeAttribute('data-label');
          }
          if (trigger) {
            if (typeof Event === 'function') {
              this.select.dispatchEvent(new Event('change'));
            } else if ((typeof Event === 'undefined' ? 'undefined' : _typeof(Event)) === 'object') {
              // IE11
              var event = document.createEvent('Event');
              event.initEvent('change', true, true);
              this.select.dispatchEvent(event);
            }
            this.close();
          }
        }
      }, {
        key: 'update',
        value: function update() {
          var option = void 0;
          if (this.select.selectedIndex > -1) {
            var item = this.container.querySelector('.ql-picker-options').children[this.select.selectedIndex];
            option = this.select.options[this.select.selectedIndex];
            this.selectItem(item);
          } else {
            this.selectItem(null);
          }
          var isActive = option != null && option !== this.select.querySelector('option[selected]');
          this.label.classList.toggle('ql-active', isActive);
        }
      }]);

      return Picker;
    }();

    exports.default = Picker;

    /***/ }),
    /* 29 */
    /***/ (function(module, exports, __webpack_require__) {


    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    var _parchment = __webpack_require__(0);

    var _parchment2 = _interopRequireDefault(_parchment);

    var _quill = __webpack_require__(5);

    var _quill2 = _interopRequireDefault(_quill);

    var _block = __webpack_require__(4);

    var _block2 = _interopRequireDefault(_block);

    var _break = __webpack_require__(16);

    var _break2 = _interopRequireDefault(_break);

    var _container = __webpack_require__(25);

    var _container2 = _interopRequireDefault(_container);

    var _cursor = __webpack_require__(24);

    var _cursor2 = _interopRequireDefault(_cursor);

    var _embed = __webpack_require__(35);

    var _embed2 = _interopRequireDefault(_embed);

    var _inline = __webpack_require__(6);

    var _inline2 = _interopRequireDefault(_inline);

    var _scroll = __webpack_require__(22);

    var _scroll2 = _interopRequireDefault(_scroll);

    var _text = __webpack_require__(7);

    var _text2 = _interopRequireDefault(_text);

    var _clipboard = __webpack_require__(55);

    var _clipboard2 = _interopRequireDefault(_clipboard);

    var _history = __webpack_require__(42);

    var _history2 = _interopRequireDefault(_history);

    var _keyboard = __webpack_require__(23);

    var _keyboard2 = _interopRequireDefault(_keyboard);

    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    _quill2.default.register({
      'blots/block': _block2.default,
      'blots/block/embed': _block.BlockEmbed,
      'blots/break': _break2.default,
      'blots/container': _container2.default,
      'blots/cursor': _cursor2.default,
      'blots/embed': _embed2.default,
      'blots/inline': _inline2.default,
      'blots/scroll': _scroll2.default,
      'blots/text': _text2.default,

      'modules/clipboard': _clipboard2.default,
      'modules/history': _history2.default,
      'modules/keyboard': _keyboard2.default
    });

    _parchment2.default.register(_block2.default, _break2.default, _cursor2.default, _inline2.default, _scroll2.default, _text2.default);

    exports.default = _quill2.default;

    /***/ }),
    /* 30 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    var Registry = __webpack_require__(1);
    var ShadowBlot = /** @class */ (function () {
        function ShadowBlot(domNode) {
            this.domNode = domNode;
            // @ts-ignore
            this.domNode[Registry.DATA_KEY] = { blot: this };
        }
        Object.defineProperty(ShadowBlot.prototype, "statics", {
            // Hack for accessing inherited static methods
            get: function () {
                return this.constructor;
            },
            enumerable: true,
            configurable: true
        });
        ShadowBlot.create = function (value) {
            if (this.tagName == null) {
                throw new Registry.ParchmentError('Blot definition missing tagName');
            }
            var node;
            if (Array.isArray(this.tagName)) {
                if (typeof value === 'string') {
                    value = value.toUpperCase();
                    if (parseInt(value).toString() === value) {
                        value = parseInt(value);
                    }
                }
                if (typeof value === 'number') {
                    node = document.createElement(this.tagName[value - 1]);
                }
                else if (this.tagName.indexOf(value) > -1) {
                    node = document.createElement(value);
                }
                else {
                    node = document.createElement(this.tagName[0]);
                }
            }
            else {
                node = document.createElement(this.tagName);
            }
            if (this.className) {
                node.classList.add(this.className);
            }
            return node;
        };
        ShadowBlot.prototype.attach = function () {
            if (this.parent != null) {
                this.scroll = this.parent.scroll;
            }
        };
        ShadowBlot.prototype.clone = function () {
            var domNode = this.domNode.cloneNode(false);
            return Registry.create(domNode);
        };
        ShadowBlot.prototype.detach = function () {
            if (this.parent != null)
                this.parent.removeChild(this);
            // @ts-ignore
            delete this.domNode[Registry.DATA_KEY];
        };
        ShadowBlot.prototype.deleteAt = function (index, length) {
            var blot = this.isolate(index, length);
            blot.remove();
        };
        ShadowBlot.prototype.formatAt = function (index, length, name, value) {
            var blot = this.isolate(index, length);
            if (Registry.query(name, Registry.Scope.BLOT) != null && value) {
                blot.wrap(name, value);
            }
            else if (Registry.query(name, Registry.Scope.ATTRIBUTE) != null) {
                var parent = Registry.create(this.statics.scope);
                blot.wrap(parent);
                parent.format(name, value);
            }
        };
        ShadowBlot.prototype.insertAt = function (index, value, def) {
            var blot = def == null ? Registry.create('text', value) : Registry.create(value, def);
            var ref = this.split(index);
            this.parent.insertBefore(blot, ref);
        };
        ShadowBlot.prototype.insertInto = function (parentBlot, refBlot) {
            if (refBlot === void 0) { refBlot = null; }
            if (this.parent != null) {
                this.parent.children.remove(this);
            }
            var refDomNode = null;
            parentBlot.children.insertBefore(this, refBlot);
            if (refBlot != null) {
                refDomNode = refBlot.domNode;
            }
            if (this.domNode.parentNode != parentBlot.domNode ||
                this.domNode.nextSibling != refDomNode) {
                parentBlot.domNode.insertBefore(this.domNode, refDomNode);
            }
            this.parent = parentBlot;
            this.attach();
        };
        ShadowBlot.prototype.isolate = function (index, length) {
            var target = this.split(index);
            target.split(length);
            return target;
        };
        ShadowBlot.prototype.length = function () {
            return 1;
        };
        ShadowBlot.prototype.offset = function (root) {
            if (root === void 0) { root = this.parent; }
            if (this.parent == null || this == root)
                return 0;
            return this.parent.children.offset(this) + this.parent.offset(root);
        };
        ShadowBlot.prototype.optimize = function (context) {
            // TODO clean up once we use WeakMap
            // @ts-ignore
            if (this.domNode[Registry.DATA_KEY] != null) {
                // @ts-ignore
                delete this.domNode[Registry.DATA_KEY].mutations;
            }
        };
        ShadowBlot.prototype.remove = function () {
            if (this.domNode.parentNode != null) {
                this.domNode.parentNode.removeChild(this.domNode);
            }
            this.detach();
        };
        ShadowBlot.prototype.replace = function (target) {
            if (target.parent == null)
                return;
            target.parent.insertBefore(this, target.next);
            target.remove();
        };
        ShadowBlot.prototype.replaceWith = function (name, value) {
            var replacement = typeof name === 'string' ? Registry.create(name, value) : name;
            replacement.replace(this);
            return replacement;
        };
        ShadowBlot.prototype.split = function (index, force) {
            return index === 0 ? this : this.next;
        };
        ShadowBlot.prototype.update = function (mutations, context) {
            // Nothing to do by default
        };
        ShadowBlot.prototype.wrap = function (name, value) {
            var wrapper = typeof name === 'string' ? Registry.create(name, value) : name;
            if (this.parent != null) {
                this.parent.insertBefore(wrapper, this.next);
            }
            wrapper.appendChild(this);
            return wrapper;
        };
        ShadowBlot.blotName = 'abstract';
        return ShadowBlot;
    }());
    exports.default = ShadowBlot;


    /***/ }),
    /* 31 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    var attributor_1 = __webpack_require__(12);
    var class_1 = __webpack_require__(32);
    var style_1 = __webpack_require__(33);
    var Registry = __webpack_require__(1);
    var AttributorStore = /** @class */ (function () {
        function AttributorStore(domNode) {
            this.attributes = {};
            this.domNode = domNode;
            this.build();
        }
        AttributorStore.prototype.attribute = function (attribute, value) {
            // verb
            if (value) {
                if (attribute.add(this.domNode, value)) {
                    if (attribute.value(this.domNode) != null) {
                        this.attributes[attribute.attrName] = attribute;
                    }
                    else {
                        delete this.attributes[attribute.attrName];
                    }
                }
            }
            else {
                attribute.remove(this.domNode);
                delete this.attributes[attribute.attrName];
            }
        };
        AttributorStore.prototype.build = function () {
            var _this = this;
            this.attributes = {};
            var attributes = attributor_1.default.keys(this.domNode);
            var classes = class_1.default.keys(this.domNode);
            var styles = style_1.default.keys(this.domNode);
            attributes
                .concat(classes)
                .concat(styles)
                .forEach(function (name) {
                var attr = Registry.query(name, Registry.Scope.ATTRIBUTE);
                if (attr instanceof attributor_1.default) {
                    _this.attributes[attr.attrName] = attr;
                }
            });
        };
        AttributorStore.prototype.copy = function (target) {
            var _this = this;
            Object.keys(this.attributes).forEach(function (key) {
                var value = _this.attributes[key].value(_this.domNode);
                target.format(key, value);
            });
        };
        AttributorStore.prototype.move = function (target) {
            var _this = this;
            this.copy(target);
            Object.keys(this.attributes).forEach(function (key) {
                _this.attributes[key].remove(_this.domNode);
            });
            this.attributes = {};
        };
        AttributorStore.prototype.values = function () {
            var _this = this;
            return Object.keys(this.attributes).reduce(function (attributes, name) {
                attributes[name] = _this.attributes[name].value(_this.domNode);
                return attributes;
            }, {});
        };
        return AttributorStore;
    }());
    exports.default = AttributorStore;


    /***/ }),
    /* 32 */
    /***/ (function(module, exports, __webpack_require__) {

    var __extends = (this && this.__extends) || (function () {
        var extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    Object.defineProperty(exports, "__esModule", { value: true });
    var attributor_1 = __webpack_require__(12);
    function match(node, prefix) {
        var className = node.getAttribute('class') || '';
        return className.split(/\s+/).filter(function (name) {
            return name.indexOf(prefix + "-") === 0;
        });
    }
    var ClassAttributor = /** @class */ (function (_super) {
        __extends(ClassAttributor, _super);
        function ClassAttributor() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        ClassAttributor.keys = function (node) {
            return (node.getAttribute('class') || '').split(/\s+/).map(function (name) {
                return name
                    .split('-')
                    .slice(0, -1)
                    .join('-');
            });
        };
        ClassAttributor.prototype.add = function (node, value) {
            if (!this.canAdd(node, value))
                return false;
            this.remove(node);
            node.classList.add(this.keyName + "-" + value);
            return true;
        };
        ClassAttributor.prototype.remove = function (node) {
            var matches = match(node, this.keyName);
            matches.forEach(function (name) {
                node.classList.remove(name);
            });
            if (node.classList.length === 0) {
                node.removeAttribute('class');
            }
        };
        ClassAttributor.prototype.value = function (node) {
            var result = match(node, this.keyName)[0] || '';
            var value = result.slice(this.keyName.length + 1); // +1 for hyphen
            return this.canAdd(node, value) ? value : '';
        };
        return ClassAttributor;
    }(attributor_1.default));
    exports.default = ClassAttributor;


    /***/ }),
    /* 33 */
    /***/ (function(module, exports, __webpack_require__) {

    var __extends = (this && this.__extends) || (function () {
        var extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    Object.defineProperty(exports, "__esModule", { value: true });
    var attributor_1 = __webpack_require__(12);
    function camelize(name) {
        var parts = name.split('-');
        var rest = parts
            .slice(1)
            .map(function (part) {
            return part[0].toUpperCase() + part.slice(1);
        })
            .join('');
        return parts[0] + rest;
    }
    var StyleAttributor = /** @class */ (function (_super) {
        __extends(StyleAttributor, _super);
        function StyleAttributor() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        StyleAttributor.keys = function (node) {
            return (node.getAttribute('style') || '').split(';').map(function (value) {
                var arr = value.split(':');
                return arr[0].trim();
            });
        };
        StyleAttributor.prototype.add = function (node, value) {
            if (!this.canAdd(node, value))
                return false;
            // @ts-ignore
            node.style[camelize(this.keyName)] = value;
            return true;
        };
        StyleAttributor.prototype.remove = function (node) {
            // @ts-ignore
            node.style[camelize(this.keyName)] = '';
            if (!node.getAttribute('style')) {
                node.removeAttribute('style');
            }
        };
        StyleAttributor.prototype.value = function (node) {
            // @ts-ignore
            var value = node.style[camelize(this.keyName)];
            return this.canAdd(node, value) ? value : '';
        };
        return StyleAttributor;
    }(attributor_1.default));
    exports.default = StyleAttributor;


    /***/ }),
    /* 34 */
    /***/ (function(module, exports, __webpack_require__) {


    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    var Theme = function () {
      function Theme(quill, options) {
        _classCallCheck(this, Theme);

        this.quill = quill;
        this.options = options;
        this.modules = {};
      }

      _createClass(Theme, [{
        key: 'init',
        value: function init() {
          var _this = this;

          Object.keys(this.options.modules).forEach(function (name) {
            if (_this.modules[name] == null) {
              _this.addModule(name);
            }
          });
        }
      }, {
        key: 'addModule',
        value: function addModule(name) {
          var moduleClass = this.quill.constructor.import('modules/' + name);
          this.modules[name] = new moduleClass(this.quill, this.options.modules[name] || {});
          return this.modules[name];
        }
      }]);

      return Theme;
    }();

    Theme.DEFAULTS = {
      modules: {}
    };
    Theme.themes = {
      'default': Theme
    };

    exports.default = Theme;

    /***/ }),
    /* 35 */
    /***/ (function(module, exports, __webpack_require__) {


    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

    var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

    var _parchment = __webpack_require__(0);

    var _parchment2 = _interopRequireDefault(_parchment);

    var _text = __webpack_require__(7);

    var _text2 = _interopRequireDefault(_text);

    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    var GUARD_TEXT = '\uFEFF';

    var Embed = function (_Parchment$Embed) {
      _inherits(Embed, _Parchment$Embed);

      function Embed(node) {
        _classCallCheck(this, Embed);

        var _this = _possibleConstructorReturn(this, (Embed.__proto__ || Object.getPrototypeOf(Embed)).call(this, node));

        _this.contentNode = document.createElement('span');
        _this.contentNode.setAttribute('contenteditable', false);
        [].slice.call(_this.domNode.childNodes).forEach(function (childNode) {
          _this.contentNode.appendChild(childNode);
        });
        _this.leftGuard = document.createTextNode(GUARD_TEXT);
        _this.rightGuard = document.createTextNode(GUARD_TEXT);
        _this.domNode.appendChild(_this.leftGuard);
        _this.domNode.appendChild(_this.contentNode);
        _this.domNode.appendChild(_this.rightGuard);
        return _this;
      }

      _createClass(Embed, [{
        key: 'index',
        value: function index(node, offset) {
          if (node === this.leftGuard) return 0;
          if (node === this.rightGuard) return 1;
          return _get(Embed.prototype.__proto__ || Object.getPrototypeOf(Embed.prototype), 'index', this).call(this, node, offset);
        }
      }, {
        key: 'restore',
        value: function restore(node) {
          var range = void 0,
              textNode = void 0;
          var text = node.data.split(GUARD_TEXT).join('');
          if (node === this.leftGuard) {
            if (this.prev instanceof _text2.default) {
              var prevLength = this.prev.length();
              this.prev.insertAt(prevLength, text);
              range = {
                startNode: this.prev.domNode,
                startOffset: prevLength + text.length
              };
            } else {
              textNode = document.createTextNode(text);
              this.parent.insertBefore(_parchment2.default.create(textNode), this);
              range = {
                startNode: textNode,
                startOffset: text.length
              };
            }
          } else if (node === this.rightGuard) {
            if (this.next instanceof _text2.default) {
              this.next.insertAt(0, text);
              range = {
                startNode: this.next.domNode,
                startOffset: text.length
              };
            } else {
              textNode = document.createTextNode(text);
              this.parent.insertBefore(_parchment2.default.create(textNode), this.next);
              range = {
                startNode: textNode,
                startOffset: text.length
              };
            }
          }
          node.data = GUARD_TEXT;
          return range;
        }
      }, {
        key: 'update',
        value: function update(mutations, context) {
          var _this2 = this;

          mutations.forEach(function (mutation) {
            if (mutation.type === 'characterData' && (mutation.target === _this2.leftGuard || mutation.target === _this2.rightGuard)) {
              var range = _this2.restore(mutation.target);
              if (range) context.range = range;
            }
          });
        }
      }]);

      return Embed;
    }(_parchment2.default.Embed);

    exports.default = Embed;

    /***/ }),
    /* 36 */
    /***/ (function(module, exports, __webpack_require__) {


    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.AlignStyle = exports.AlignClass = exports.AlignAttribute = undefined;

    var _parchment = __webpack_require__(0);

    var _parchment2 = _interopRequireDefault(_parchment);

    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    var config = {
      scope: _parchment2.default.Scope.BLOCK,
      whitelist: ['right', 'center', 'justify']
    };

    var AlignAttribute = new _parchment2.default.Attributor.Attribute('align', 'align', config);
    var AlignClass = new _parchment2.default.Attributor.Class('align', 'ql-align', config);
    var AlignStyle = new _parchment2.default.Attributor.Style('align', 'text-align', config);

    exports.AlignAttribute = AlignAttribute;
    exports.AlignClass = AlignClass;
    exports.AlignStyle = AlignStyle;

    /***/ }),
    /* 37 */
    /***/ (function(module, exports, __webpack_require__) {


    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.BackgroundStyle = exports.BackgroundClass = undefined;

    var _parchment = __webpack_require__(0);

    var _parchment2 = _interopRequireDefault(_parchment);

    var _color = __webpack_require__(26);

    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    var BackgroundClass = new _parchment2.default.Attributor.Class('background', 'ql-bg', {
      scope: _parchment2.default.Scope.INLINE
    });
    var BackgroundStyle = new _color.ColorAttributor('background', 'background-color', {
      scope: _parchment2.default.Scope.INLINE
    });

    exports.BackgroundClass = BackgroundClass;
    exports.BackgroundStyle = BackgroundStyle;

    /***/ }),
    /* 38 */
    /***/ (function(module, exports, __webpack_require__) {


    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.DirectionStyle = exports.DirectionClass = exports.DirectionAttribute = undefined;

    var _parchment = __webpack_require__(0);

    var _parchment2 = _interopRequireDefault(_parchment);

    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    var config = {
      scope: _parchment2.default.Scope.BLOCK,
      whitelist: ['rtl']
    };

    var DirectionAttribute = new _parchment2.default.Attributor.Attribute('direction', 'dir', config);
    var DirectionClass = new _parchment2.default.Attributor.Class('direction', 'ql-direction', config);
    var DirectionStyle = new _parchment2.default.Attributor.Style('direction', 'direction', config);

    exports.DirectionAttribute = DirectionAttribute;
    exports.DirectionClass = DirectionClass;
    exports.DirectionStyle = DirectionStyle;

    /***/ }),
    /* 39 */
    /***/ (function(module, exports, __webpack_require__) {


    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.FontClass = exports.FontStyle = undefined;

    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

    var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

    var _parchment = __webpack_require__(0);

    var _parchment2 = _interopRequireDefault(_parchment);

    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    var config = {
      scope: _parchment2.default.Scope.INLINE,
      whitelist: ['serif', 'monospace']
    };

    var FontClass = new _parchment2.default.Attributor.Class('font', 'ql-font', config);

    var FontStyleAttributor = function (_Parchment$Attributor) {
      _inherits(FontStyleAttributor, _Parchment$Attributor);

      function FontStyleAttributor() {
        _classCallCheck(this, FontStyleAttributor);

        return _possibleConstructorReturn(this, (FontStyleAttributor.__proto__ || Object.getPrototypeOf(FontStyleAttributor)).apply(this, arguments));
      }

      _createClass(FontStyleAttributor, [{
        key: 'value',
        value: function value(node) {
          return _get(FontStyleAttributor.prototype.__proto__ || Object.getPrototypeOf(FontStyleAttributor.prototype), 'value', this).call(this, node).replace(/["']/g, '');
        }
      }]);

      return FontStyleAttributor;
    }(_parchment2.default.Attributor.Style);

    var FontStyle = new FontStyleAttributor('font', 'font-family', config);

    exports.FontStyle = FontStyle;
    exports.FontClass = FontClass;

    /***/ }),
    /* 40 */
    /***/ (function(module, exports, __webpack_require__) {


    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.SizeStyle = exports.SizeClass = undefined;

    var _parchment = __webpack_require__(0);

    var _parchment2 = _interopRequireDefault(_parchment);

    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    var SizeClass = new _parchment2.default.Attributor.Class('size', 'ql-size', {
      scope: _parchment2.default.Scope.INLINE,
      whitelist: ['small', 'large', 'huge']
    });
    var SizeStyle = new _parchment2.default.Attributor.Style('size', 'font-size', {
      scope: _parchment2.default.Scope.INLINE,
      whitelist: ['10px', '18px', '32px']
    });

    exports.SizeClass = SizeClass;
    exports.SizeStyle = SizeStyle;

    /***/ }),
    /* 41 */
    /***/ (function(module, exports, __webpack_require__) {


    module.exports = {
      'align': {
        '': __webpack_require__(76),
        'center': __webpack_require__(77),
        'right': __webpack_require__(78),
        'justify': __webpack_require__(79)
      },
      'background': __webpack_require__(80),
      'blockquote': __webpack_require__(81),
      'bold': __webpack_require__(82),
      'clean': __webpack_require__(83),
      'code': __webpack_require__(58),
      'code-block': __webpack_require__(58),
      'color': __webpack_require__(84),
      'direction': {
        '': __webpack_require__(85),
        'rtl': __webpack_require__(86)
      },
      'float': {
        'center': __webpack_require__(87),
        'full': __webpack_require__(88),
        'left': __webpack_require__(89),
        'right': __webpack_require__(90)
      },
      'formula': __webpack_require__(91),
      'header': {
        '1': __webpack_require__(92),
        '2': __webpack_require__(93)
      },
      'italic': __webpack_require__(94),
      'image': __webpack_require__(95),
      'indent': {
        '+1': __webpack_require__(96),
        '-1': __webpack_require__(97)
      },
      'link': __webpack_require__(98),
      'list': {
        'ordered': __webpack_require__(99),
        'bullet': __webpack_require__(100),
        'check': __webpack_require__(101)
      },
      'script': {
        'sub': __webpack_require__(102),
        'super': __webpack_require__(103)
      },
      'strike': __webpack_require__(104),
      'underline': __webpack_require__(105),
      'video': __webpack_require__(106)
    };

    /***/ }),
    /* 42 */
    /***/ (function(module, exports, __webpack_require__) {


    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.getLastChangeIndex = exports.default = undefined;

    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

    var _parchment = __webpack_require__(0);

    var _parchment2 = _interopRequireDefault(_parchment);

    var _quill = __webpack_require__(5);

    var _quill2 = _interopRequireDefault(_quill);

    var _module = __webpack_require__(9);

    var _module2 = _interopRequireDefault(_module);

    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    var History = function (_Module) {
      _inherits(History, _Module);

      function History(quill, options) {
        _classCallCheck(this, History);

        var _this = _possibleConstructorReturn(this, (History.__proto__ || Object.getPrototypeOf(History)).call(this, quill, options));

        _this.lastRecorded = 0;
        _this.ignoreChange = false;
        _this.clear();
        _this.quill.on(_quill2.default.events.EDITOR_CHANGE, function (eventName, delta, oldDelta, source) {
          if (eventName !== _quill2.default.events.TEXT_CHANGE || _this.ignoreChange) return;
          if (!_this.options.userOnly || source === _quill2.default.sources.USER) {
            _this.record(delta, oldDelta);
          } else {
            _this.transform(delta);
          }
        });
        _this.quill.keyboard.addBinding({ key: 'Z', shortKey: true }, _this.undo.bind(_this));
        _this.quill.keyboard.addBinding({ key: 'Z', shortKey: true, shiftKey: true }, _this.redo.bind(_this));
        if (/Win/i.test(navigator.platform)) {
          _this.quill.keyboard.addBinding({ key: 'Y', shortKey: true }, _this.redo.bind(_this));
        }
        return _this;
      }

      _createClass(History, [{
        key: 'change',
        value: function change(source, dest) {
          if (this.stack[source].length === 0) return;
          var delta = this.stack[source].pop();
          this.stack[dest].push(delta);
          this.lastRecorded = 0;
          this.ignoreChange = true;
          this.quill.updateContents(delta[source], _quill2.default.sources.USER);
          this.ignoreChange = false;
          var index = getLastChangeIndex(delta[source]);
          this.quill.setSelection(index);
        }
      }, {
        key: 'clear',
        value: function clear() {
          this.stack = { undo: [], redo: [] };
        }
      }, {
        key: 'cutoff',
        value: function cutoff() {
          this.lastRecorded = 0;
        }
      }, {
        key: 'record',
        value: function record(changeDelta, oldDelta) {
          if (changeDelta.ops.length === 0) return;
          this.stack.redo = [];
          var undoDelta = this.quill.getContents().diff(oldDelta);
          var timestamp = Date.now();
          if (this.lastRecorded + this.options.delay > timestamp && this.stack.undo.length > 0) {
            var delta = this.stack.undo.pop();
            undoDelta = undoDelta.compose(delta.undo);
            changeDelta = delta.redo.compose(changeDelta);
          } else {
            this.lastRecorded = timestamp;
          }
          this.stack.undo.push({
            redo: changeDelta,
            undo: undoDelta
          });
          if (this.stack.undo.length > this.options.maxStack) {
            this.stack.undo.shift();
          }
        }
      }, {
        key: 'redo',
        value: function redo() {
          this.change('redo', 'undo');
        }
      }, {
        key: 'transform',
        value: function transform(delta) {
          this.stack.undo.forEach(function (change) {
            change.undo = delta.transform(change.undo, true);
            change.redo = delta.transform(change.redo, true);
          });
          this.stack.redo.forEach(function (change) {
            change.undo = delta.transform(change.undo, true);
            change.redo = delta.transform(change.redo, true);
          });
        }
      }, {
        key: 'undo',
        value: function undo() {
          this.change('undo', 'redo');
        }
      }]);

      return History;
    }(_module2.default);

    History.DEFAULTS = {
      delay: 1000,
      maxStack: 100,
      userOnly: false
    };

    function endsWithNewlineChange(delta) {
      var lastOp = delta.ops[delta.ops.length - 1];
      if (lastOp == null) return false;
      if (lastOp.insert != null) {
        return typeof lastOp.insert === 'string' && lastOp.insert.endsWith('\n');
      }
      if (lastOp.attributes != null) {
        return Object.keys(lastOp.attributes).some(function (attr) {
          return _parchment2.default.query(attr, _parchment2.default.Scope.BLOCK) != null;
        });
      }
      return false;
    }

    function getLastChangeIndex(delta) {
      var deleteLength = delta.reduce(function (length, op) {
        length += op.delete || 0;
        return length;
      }, 0);
      var changeIndex = delta.length() - deleteLength;
      if (endsWithNewlineChange(delta)) {
        changeIndex -= 1;
      }
      return changeIndex;
    }

    exports.default = History;
    exports.getLastChangeIndex = getLastChangeIndex;

    /***/ }),
    /* 43 */
    /***/ (function(module, exports, __webpack_require__) {


    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = exports.BaseTooltip = undefined;

    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

    var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

    var _extend = __webpack_require__(3);

    var _extend2 = _interopRequireDefault(_extend);

    var _quillDelta = __webpack_require__(2);

    var _quillDelta2 = _interopRequireDefault(_quillDelta);

    var _emitter = __webpack_require__(8);

    var _emitter2 = _interopRequireDefault(_emitter);

    var _keyboard = __webpack_require__(23);

    var _keyboard2 = _interopRequireDefault(_keyboard);

    var _theme = __webpack_require__(34);

    var _theme2 = _interopRequireDefault(_theme);

    var _colorPicker = __webpack_require__(59);

    var _colorPicker2 = _interopRequireDefault(_colorPicker);

    var _iconPicker = __webpack_require__(60);

    var _iconPicker2 = _interopRequireDefault(_iconPicker);

    var _picker = __webpack_require__(28);

    var _picker2 = _interopRequireDefault(_picker);

    var _tooltip = __webpack_require__(61);

    var _tooltip2 = _interopRequireDefault(_tooltip);

    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    var ALIGNS = [false, 'center', 'right', 'justify'];

    var COLORS = ["#000000", "#e60000", "#ff9900", "#ffff00", "#008a00", "#0066cc", "#9933ff", "#ffffff", "#facccc", "#ffebcc", "#ffffcc", "#cce8cc", "#cce0f5", "#ebd6ff", "#bbbbbb", "#f06666", "#ffc266", "#ffff66", "#66b966", "#66a3e0", "#c285ff", "#888888", "#a10000", "#b26b00", "#b2b200", "#006100", "#0047b2", "#6b24b2", "#444444", "#5c0000", "#663d00", "#666600", "#003700", "#002966", "#3d1466"];

    var FONTS = [false, 'serif', 'monospace'];

    var HEADERS = ['1', '2', '3', false];

    var SIZES = ['small', false, 'large', 'huge'];

    var BaseTheme = function (_Theme) {
      _inherits(BaseTheme, _Theme);

      function BaseTheme(quill, options) {
        _classCallCheck(this, BaseTheme);

        var _this = _possibleConstructorReturn(this, (BaseTheme.__proto__ || Object.getPrototypeOf(BaseTheme)).call(this, quill, options));

        var listener = function listener(e) {
          if (!document.body.contains(quill.root)) {
            return document.body.removeEventListener('click', listener);
          }
          if (_this.tooltip != null && !_this.tooltip.root.contains(e.target) && document.activeElement !== _this.tooltip.textbox && !_this.quill.hasFocus()) {
            _this.tooltip.hide();
          }
          if (_this.pickers != null) {
            _this.pickers.forEach(function (picker) {
              if (!picker.container.contains(e.target)) {
                picker.close();
              }
            });
          }
        };
        quill.emitter.listenDOM('click', document.body, listener);
        return _this;
      }

      _createClass(BaseTheme, [{
        key: 'addModule',
        value: function addModule(name) {
          var module = _get(BaseTheme.prototype.__proto__ || Object.getPrototypeOf(BaseTheme.prototype), 'addModule', this).call(this, name);
          if (name === 'toolbar') {
            this.extendToolbar(module);
          }
          return module;
        }
      }, {
        key: 'buildButtons',
        value: function buildButtons(buttons, icons) {
          buttons.forEach(function (button) {
            var className = button.getAttribute('class') || '';
            className.split(/\s+/).forEach(function (name) {
              if (!name.startsWith('ql-')) return;
              name = name.slice('ql-'.length);
              if (icons[name] == null) return;
              if (name === 'direction') {
                button.innerHTML = icons[name][''] + icons[name]['rtl'];
              } else if (typeof icons[name] === 'string') {
                button.innerHTML = icons[name];
              } else {
                var value = button.value || '';
                if (value != null && icons[name][value]) {
                  button.innerHTML = icons[name][value];
                }
              }
            });
          });
        }
      }, {
        key: 'buildPickers',
        value: function buildPickers(selects, icons) {
          var _this2 = this;

          this.pickers = selects.map(function (select) {
            if (select.classList.contains('ql-align')) {
              if (select.querySelector('option') == null) {
                fillSelect(select, ALIGNS);
              }
              return new _iconPicker2.default(select, icons.align);
            } else if (select.classList.contains('ql-background') || select.classList.contains('ql-color')) {
              var format = select.classList.contains('ql-background') ? 'background' : 'color';
              if (select.querySelector('option') == null) {
                fillSelect(select, COLORS, format === 'background' ? '#ffffff' : '#000000');
              }
              return new _colorPicker2.default(select, icons[format]);
            } else {
              if (select.querySelector('option') == null) {
                if (select.classList.contains('ql-font')) {
                  fillSelect(select, FONTS);
                } else if (select.classList.contains('ql-header')) {
                  fillSelect(select, HEADERS);
                } else if (select.classList.contains('ql-size')) {
                  fillSelect(select, SIZES);
                }
              }
              return new _picker2.default(select);
            }
          });
          var update = function update() {
            _this2.pickers.forEach(function (picker) {
              picker.update();
            });
          };
          this.quill.on(_emitter2.default.events.EDITOR_CHANGE, update);
        }
      }]);

      return BaseTheme;
    }(_theme2.default);

    BaseTheme.DEFAULTS = (0, _extend2.default)(true, {}, _theme2.default.DEFAULTS, {
      modules: {
        toolbar: {
          handlers: {
            formula: function formula() {
              this.quill.theme.tooltip.edit('formula');
            },
            image: function image() {
              var _this3 = this;

              var fileInput = this.container.querySelector('input.ql-image[type=file]');
              if (fileInput == null) {
                fileInput = document.createElement('input');
                fileInput.setAttribute('type', 'file');
                fileInput.setAttribute('accept', 'image/png, image/gif, image/jpeg, image/bmp, image/x-icon');
                fileInput.classList.add('ql-image');
                fileInput.addEventListener('change', function () {
                  if (fileInput.files != null && fileInput.files[0] != null) {
                    var reader = new FileReader();
                    reader.onload = function (e) {
                      var range = _this3.quill.getSelection(true);
                      _this3.quill.updateContents(new _quillDelta2.default().retain(range.index).delete(range.length).insert({ image: e.target.result }), _emitter2.default.sources.USER);
                      _this3.quill.setSelection(range.index + 1, _emitter2.default.sources.SILENT);
                      fileInput.value = "";
                    };
                    reader.readAsDataURL(fileInput.files[0]);
                  }
                });
                this.container.appendChild(fileInput);
              }
              fileInput.click();
            },
            video: function video() {
              this.quill.theme.tooltip.edit('video');
            }
          }
        }
      }
    });

    var BaseTooltip = function (_Tooltip) {
      _inherits(BaseTooltip, _Tooltip);

      function BaseTooltip(quill, boundsContainer) {
        _classCallCheck(this, BaseTooltip);

        var _this4 = _possibleConstructorReturn(this, (BaseTooltip.__proto__ || Object.getPrototypeOf(BaseTooltip)).call(this, quill, boundsContainer));

        _this4.textbox = _this4.root.querySelector('input[type="text"]');
        _this4.listen();
        return _this4;
      }

      _createClass(BaseTooltip, [{
        key: 'listen',
        value: function listen() {
          var _this5 = this;

          this.textbox.addEventListener('keydown', function (event) {
            if (_keyboard2.default.match(event, 'enter')) {
              _this5.save();
              event.preventDefault();
            } else if (_keyboard2.default.match(event, 'escape')) {
              _this5.cancel();
              event.preventDefault();
            }
          });
        }
      }, {
        key: 'cancel',
        value: function cancel() {
          this.hide();
        }
      }, {
        key: 'edit',
        value: function edit() {
          var mode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'link';
          var preview = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

          this.root.classList.remove('ql-hidden');
          this.root.classList.add('ql-editing');
          if (preview != null) {
            this.textbox.value = preview;
          } else if (mode !== this.root.getAttribute('data-mode')) {
            this.textbox.value = '';
          }
          this.position(this.quill.getBounds(this.quill.selection.savedRange));
          this.textbox.select();
          this.textbox.setAttribute('placeholder', this.textbox.getAttribute('data-' + mode) || '');
          this.root.setAttribute('data-mode', mode);
        }
      }, {
        key: 'restoreFocus',
        value: function restoreFocus() {
          var scrollTop = this.quill.scrollingContainer.scrollTop;
          this.quill.focus();
          this.quill.scrollingContainer.scrollTop = scrollTop;
        }
      }, {
        key: 'save',
        value: function save() {
          var value = this.textbox.value;
          switch (this.root.getAttribute('data-mode')) {
            case 'link':
              {
                var scrollTop = this.quill.root.scrollTop;
                if (this.linkRange) {
                  this.quill.formatText(this.linkRange, 'link', value, _emitter2.default.sources.USER);
                  delete this.linkRange;
                } else {
                  this.restoreFocus();
                  this.quill.format('link', value, _emitter2.default.sources.USER);
                }
                this.quill.root.scrollTop = scrollTop;
                break;
              }
            case 'video':
              {
                value = extractVideoUrl(value);
              } // eslint-disable-next-line no-fallthrough
            case 'formula':
              {
                if (!value) break;
                var range = this.quill.getSelection(true);
                if (range != null) {
                  var index = range.index + range.length;
                  this.quill.insertEmbed(index, this.root.getAttribute('data-mode'), value, _emitter2.default.sources.USER);
                  if (this.root.getAttribute('data-mode') === 'formula') {
                    this.quill.insertText(index + 1, ' ', _emitter2.default.sources.USER);
                  }
                  this.quill.setSelection(index + 2, _emitter2.default.sources.USER);
                }
                break;
              }
          }
          this.textbox.value = '';
          this.hide();
        }
      }]);

      return BaseTooltip;
    }(_tooltip2.default);

    function extractVideoUrl(url) {
      var match = url.match(/^(?:(https?):\/\/)?(?:(?:www|m)\.)?youtube\.com\/watch.*v=([a-zA-Z0-9_-]+)/) || url.match(/^(?:(https?):\/\/)?(?:(?:www|m)\.)?youtu\.be\/([a-zA-Z0-9_-]+)/);
      if (match) {
        return (match[1] || 'https') + '://www.youtube.com/embed/' + match[2] + '?showinfo=0';
      }
      if (match = url.match(/^(?:(https?):\/\/)?(?:www\.)?vimeo\.com\/(\d+)/)) {
        // eslint-disable-line no-cond-assign
        return (match[1] || 'https') + '://player.vimeo.com/video/' + match[2] + '/';
      }
      return url;
    }

    function fillSelect(select, values) {
      var defaultValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

      values.forEach(function (value) {
        var option = document.createElement('option');
        if (value === defaultValue) {
          option.setAttribute('selected', 'selected');
        } else {
          option.setAttribute('value', value);
        }
        select.appendChild(option);
      });
    }

    exports.BaseTooltip = BaseTooltip;
    exports.default = BaseTheme;

    /***/ }),
    /* 44 */
    /***/ (function(module, exports, __webpack_require__) {

    Object.defineProperty(exports, "__esModule", { value: true });
    var LinkedList = /** @class */ (function () {
        function LinkedList() {
            this.head = this.tail = null;
            this.length = 0;
        }
        LinkedList.prototype.append = function () {
            var nodes = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                nodes[_i] = arguments[_i];
            }
            this.insertBefore(nodes[0], null);
            if (nodes.length > 1) {
                this.append.apply(this, nodes.slice(1));
            }
        };
        LinkedList.prototype.contains = function (node) {
            var cur, next = this.iterator();
            while ((cur = next())) {
                if (cur === node)
                    return true;
            }
            return false;
        };
        LinkedList.prototype.insertBefore = function (node, refNode) {
            if (!node)
                return;
            node.next = refNode;
            if (refNode != null) {
                node.prev = refNode.prev;
                if (refNode.prev != null) {
                    refNode.prev.next = node;
                }
                refNode.prev = node;
                if (refNode === this.head) {
                    this.head = node;
                }
            }
            else if (this.tail != null) {
                this.tail.next = node;
                node.prev = this.tail;
                this.tail = node;
            }
            else {
                node.prev = null;
                this.head = this.tail = node;
            }
            this.length += 1;
        };
        LinkedList.prototype.offset = function (target) {
            var index = 0, cur = this.head;
            while (cur != null) {
                if (cur === target)
                    return index;
                index += cur.length();
                cur = cur.next;
            }
            return -1;
        };
        LinkedList.prototype.remove = function (node) {
            if (!this.contains(node))
                return;
            if (node.prev != null)
                node.prev.next = node.next;
            if (node.next != null)
                node.next.prev = node.prev;
            if (node === this.head)
                this.head = node.next;
            if (node === this.tail)
                this.tail = node.prev;
            this.length -= 1;
        };
        LinkedList.prototype.iterator = function (curNode) {
            if (curNode === void 0) { curNode = this.head; }
            // TODO use yield when we can
            return function () {
                var ret = curNode;
                if (curNode != null)
                    curNode = curNode.next;
                return ret;
            };
        };
        LinkedList.prototype.find = function (index, inclusive) {
            if (inclusive === void 0) { inclusive = false; }
            var cur, next = this.iterator();
            while ((cur = next())) {
                var length = cur.length();
                if (index < length ||
                    (inclusive && index === length && (cur.next == null || cur.next.length() !== 0))) {
                    return [cur, index];
                }
                index -= length;
            }
            return [null, 0];
        };
        LinkedList.prototype.forEach = function (callback) {
            var cur, next = this.iterator();
            while ((cur = next())) {
                callback(cur);
            }
        };
        LinkedList.prototype.forEachAt = function (index, length, callback) {
            if (length <= 0)
                return;
            var _a = this.find(index), startNode = _a[0], offset = _a[1];
            var cur, curIndex = index - offset, next = this.iterator(startNode);
            while ((cur = next()) && curIndex < index + length) {
                var curLength = cur.length();
                if (index > curIndex) {
                    callback(cur, index - curIndex, Math.min(length, curIndex + curLength - index));
                }
                else {
                    callback(cur, 0, Math.min(curLength, index + length - curIndex));
                }
                curIndex += curLength;
            }
        };
        LinkedList.prototype.map = function (callback) {
            return this.reduce(function (memo, cur) {
                memo.push(callback(cur));
                return memo;
            }, []);
        };
        LinkedList.prototype.reduce = function (callback, memo) {
            var cur, next = this.iterator();
            while ((cur = next())) {
                memo = callback(memo, cur);
            }
            return memo;
        };
        return LinkedList;
    }());
    exports.default = LinkedList;


    /***/ }),
    /* 45 */
    /***/ (function(module, exports, __webpack_require__) {

    var __extends = (this && this.__extends) || (function () {
        var extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    Object.defineProperty(exports, "__esModule", { value: true });
    var container_1 = __webpack_require__(17);
    var Registry = __webpack_require__(1);
    var OBSERVER_CONFIG = {
        attributes: true,
        characterData: true,
        characterDataOldValue: true,
        childList: true,
        subtree: true,
    };
    var MAX_OPTIMIZE_ITERATIONS = 100;
    var ScrollBlot = /** @class */ (function (_super) {
        __extends(ScrollBlot, _super);
        function ScrollBlot(node) {
            var _this = _super.call(this, node) || this;
            _this.scroll = _this;
            _this.observer = new MutationObserver(function (mutations) {
                _this.update(mutations);
            });
            _this.observer.observe(_this.domNode, OBSERVER_CONFIG);
            _this.attach();
            return _this;
        }
        ScrollBlot.prototype.detach = function () {
            _super.prototype.detach.call(this);
            this.observer.disconnect();
        };
        ScrollBlot.prototype.deleteAt = function (index, length) {
            this.update();
            if (index === 0 && length === this.length()) {
                this.children.forEach(function (child) {
                    child.remove();
                });
            }
            else {
                _super.prototype.deleteAt.call(this, index, length);
            }
        };
        ScrollBlot.prototype.formatAt = function (index, length, name, value) {
            this.update();
            _super.prototype.formatAt.call(this, index, length, name, value);
        };
        ScrollBlot.prototype.insertAt = function (index, value, def) {
            this.update();
            _super.prototype.insertAt.call(this, index, value, def);
        };
        ScrollBlot.prototype.optimize = function (mutations, context) {
            var _this = this;
            if (mutations === void 0) { mutations = []; }
            if (context === void 0) { context = {}; }
            _super.prototype.optimize.call(this, context);
            // We must modify mutations directly, cannot make copy and then modify
            var records = [].slice.call(this.observer.takeRecords());
            // Array.push currently seems to be implemented by a non-tail recursive function
            // so we cannot just mutations.push.apply(mutations, this.observer.takeRecords());
            while (records.length > 0)
                mutations.push(records.pop());
            // TODO use WeakMap
            var mark = function (blot, markParent) {
                if (markParent === void 0) { markParent = true; }
                if (blot == null || blot === _this)
                    return;
                if (blot.domNode.parentNode == null)
                    return;
                // @ts-ignore
                if (blot.domNode[Registry.DATA_KEY].mutations == null) {
                    // @ts-ignore
                    blot.domNode[Registry.DATA_KEY].mutations = [];
                }
                if (markParent)
                    mark(blot.parent);
            };
            var optimize = function (blot) {
                // Post-order traversal
                if (
                // @ts-ignore
                blot.domNode[Registry.DATA_KEY] == null ||
                    // @ts-ignore
                    blot.domNode[Registry.DATA_KEY].mutations == null) {
                    return;
                }
                if (blot instanceof container_1.default) {
                    blot.children.forEach(optimize);
                }
                blot.optimize(context);
            };
            var remaining = mutations;
            for (var i = 0; remaining.length > 0; i += 1) {
                if (i >= MAX_OPTIMIZE_ITERATIONS) {
                    throw new Error('[Parchment] Maximum optimize iterations reached');
                }
                remaining.forEach(function (mutation) {
                    var blot = Registry.find(mutation.target, true);
                    if (blot == null)
                        return;
                    if (blot.domNode === mutation.target) {
                        if (mutation.type === 'childList') {
                            mark(Registry.find(mutation.previousSibling, false));
                            [].forEach.call(mutation.addedNodes, function (node) {
                                var child = Registry.find(node, false);
                                mark(child, false);
                                if (child instanceof container_1.default) {
                                    child.children.forEach(function (grandChild) {
                                        mark(grandChild, false);
                                    });
                                }
                            });
                        }
                        else if (mutation.type === 'attributes') {
                            mark(blot.prev);
                        }
                    }
                    mark(blot);
                });
                this.children.forEach(optimize);
                remaining = [].slice.call(this.observer.takeRecords());
                records = remaining.slice();
                while (records.length > 0)
                    mutations.push(records.pop());
            }
        };
        ScrollBlot.prototype.update = function (mutations, context) {
            var _this = this;
            if (context === void 0) { context = {}; }
            mutations = mutations || this.observer.takeRecords();
            // TODO use WeakMap
            mutations
                .map(function (mutation) {
                var blot = Registry.find(mutation.target, true);
                if (blot == null)
                    return null;
                // @ts-ignore
                if (blot.domNode[Registry.DATA_KEY].mutations == null) {
                    // @ts-ignore
                    blot.domNode[Registry.DATA_KEY].mutations = [mutation];
                    return blot;
                }
                else {
                    // @ts-ignore
                    blot.domNode[Registry.DATA_KEY].mutations.push(mutation);
                    return null;
                }
            })
                .forEach(function (blot) {
                if (blot == null ||
                    blot === _this ||
                    //@ts-ignore
                    blot.domNode[Registry.DATA_KEY] == null)
                    return;
                // @ts-ignore
                blot.update(blot.domNode[Registry.DATA_KEY].mutations || [], context);
            });
            // @ts-ignore
            if (this.domNode[Registry.DATA_KEY].mutations != null) {
                // @ts-ignore
                _super.prototype.update.call(this, this.domNode[Registry.DATA_KEY].mutations, context);
            }
            this.optimize(mutations, context);
        };
        ScrollBlot.blotName = 'scroll';
        ScrollBlot.defaultChild = 'block';
        ScrollBlot.scope = Registry.Scope.BLOCK_BLOT;
        ScrollBlot.tagName = 'DIV';
        return ScrollBlot;
    }(container_1.default));
    exports.default = ScrollBlot;


    /***/ }),
    /* 46 */
    /***/ (function(module, exports, __webpack_require__) {

    var __extends = (this && this.__extends) || (function () {
        var extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    Object.defineProperty(exports, "__esModule", { value: true });
    var format_1 = __webpack_require__(18);
    var Registry = __webpack_require__(1);
    // Shallow object comparison
    function isEqual(obj1, obj2) {
        if (Object.keys(obj1).length !== Object.keys(obj2).length)
            return false;
        // @ts-ignore
        for (var prop in obj1) {
            // @ts-ignore
            if (obj1[prop] !== obj2[prop])
                return false;
        }
        return true;
    }
    var InlineBlot = /** @class */ (function (_super) {
        __extends(InlineBlot, _super);
        function InlineBlot() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        InlineBlot.formats = function (domNode) {
            if (domNode.tagName === InlineBlot.tagName)
                return undefined;
            return _super.formats.call(this, domNode);
        };
        InlineBlot.prototype.format = function (name, value) {
            var _this = this;
            if (name === this.statics.blotName && !value) {
                this.children.forEach(function (child) {
                    if (!(child instanceof format_1.default)) {
                        child = child.wrap(InlineBlot.blotName, true);
                    }
                    _this.attributes.copy(child);
                });
                this.unwrap();
            }
            else {
                _super.prototype.format.call(this, name, value);
            }
        };
        InlineBlot.prototype.formatAt = function (index, length, name, value) {
            if (this.formats()[name] != null || Registry.query(name, Registry.Scope.ATTRIBUTE)) {
                var blot = this.isolate(index, length);
                blot.format(name, value);
            }
            else {
                _super.prototype.formatAt.call(this, index, length, name, value);
            }
        };
        InlineBlot.prototype.optimize = function (context) {
            _super.prototype.optimize.call(this, context);
            var formats = this.formats();
            if (Object.keys(formats).length === 0) {
                return this.unwrap(); // unformatted span
            }
            var next = this.next;
            if (next instanceof InlineBlot && next.prev === this && isEqual(formats, next.formats())) {
                next.moveChildren(this);
                next.remove();
            }
        };
        InlineBlot.blotName = 'inline';
        InlineBlot.scope = Registry.Scope.INLINE_BLOT;
        InlineBlot.tagName = 'SPAN';
        return InlineBlot;
    }(format_1.default));
    exports.default = InlineBlot;


    /***/ }),
    /* 47 */
    /***/ (function(module, exports, __webpack_require__) {

    var __extends = (this && this.__extends) || (function () {
        var extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    Object.defineProperty(exports, "__esModule", { value: true });
    var format_1 = __webpack_require__(18);
    var Registry = __webpack_require__(1);
    var BlockBlot = /** @class */ (function (_super) {
        __extends(BlockBlot, _super);
        function BlockBlot() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        BlockBlot.formats = function (domNode) {
            var tagName = Registry.query(BlockBlot.blotName).tagName;
            if (domNode.tagName === tagName)
                return undefined;
            return _super.formats.call(this, domNode);
        };
        BlockBlot.prototype.format = function (name, value) {
            if (Registry.query(name, Registry.Scope.BLOCK) == null) {
                return;
            }
            else if (name === this.statics.blotName && !value) {
                this.replaceWith(BlockBlot.blotName);
            }
            else {
                _super.prototype.format.call(this, name, value);
            }
        };
        BlockBlot.prototype.formatAt = function (index, length, name, value) {
            if (Registry.query(name, Registry.Scope.BLOCK) != null) {
                this.format(name, value);
            }
            else {
                _super.prototype.formatAt.call(this, index, length, name, value);
            }
        };
        BlockBlot.prototype.insertAt = function (index, value, def) {
            if (def == null || Registry.query(value, Registry.Scope.INLINE) != null) {
                // Insert text or inline
                _super.prototype.insertAt.call(this, index, value, def);
            }
            else {
                var after = this.split(index);
                var blot = Registry.create(value, def);
                after.parent.insertBefore(blot, after);
            }
        };
        BlockBlot.prototype.update = function (mutations, context) {
            if (navigator.userAgent.match(/Trident/)) {
                this.build();
            }
            else {
                _super.prototype.update.call(this, mutations, context);
            }
        };
        BlockBlot.blotName = 'block';
        BlockBlot.scope = Registry.Scope.BLOCK_BLOT;
        BlockBlot.tagName = 'P';
        return BlockBlot;
    }(format_1.default));
    exports.default = BlockBlot;


    /***/ }),
    /* 48 */
    /***/ (function(module, exports, __webpack_require__) {

    var __extends = (this && this.__extends) || (function () {
        var extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    Object.defineProperty(exports, "__esModule", { value: true });
    var leaf_1 = __webpack_require__(19);
    var EmbedBlot = /** @class */ (function (_super) {
        __extends(EmbedBlot, _super);
        function EmbedBlot() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        EmbedBlot.formats = function (domNode) {
            return undefined;
        };
        EmbedBlot.prototype.format = function (name, value) {
            // super.formatAt wraps, which is what we want in general,
            // but this allows subclasses to overwrite for formats
            // that just apply to particular embeds
            _super.prototype.formatAt.call(this, 0, this.length(), name, value);
        };
        EmbedBlot.prototype.formatAt = function (index, length, name, value) {
            if (index === 0 && length === this.length()) {
                this.format(name, value);
            }
            else {
                _super.prototype.formatAt.call(this, index, length, name, value);
            }
        };
        EmbedBlot.prototype.formats = function () {
            return this.statics.formats(this.domNode);
        };
        return EmbedBlot;
    }(leaf_1.default));
    exports.default = EmbedBlot;


    /***/ }),
    /* 49 */
    /***/ (function(module, exports, __webpack_require__) {

    var __extends = (this && this.__extends) || (function () {
        var extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    Object.defineProperty(exports, "__esModule", { value: true });
    var leaf_1 = __webpack_require__(19);
    var Registry = __webpack_require__(1);
    var TextBlot = /** @class */ (function (_super) {
        __extends(TextBlot, _super);
        function TextBlot(node) {
            var _this = _super.call(this, node) || this;
            _this.text = _this.statics.value(_this.domNode);
            return _this;
        }
        TextBlot.create = function (value) {
            return document.createTextNode(value);
        };
        TextBlot.value = function (domNode) {
            var text = domNode.data;
            // @ts-ignore
            if (text['normalize'])
                text = text['normalize']();
            return text;
        };
        TextBlot.prototype.deleteAt = function (index, length) {
            this.domNode.data = this.text = this.text.slice(0, index) + this.text.slice(index + length);
        };
        TextBlot.prototype.index = function (node, offset) {
            if (this.domNode === node) {
                return offset;
            }
            return -1;
        };
        TextBlot.prototype.insertAt = function (index, value, def) {
            if (def == null) {
                this.text = this.text.slice(0, index) + value + this.text.slice(index);
                this.domNode.data = this.text;
            }
            else {
                _super.prototype.insertAt.call(this, index, value, def);
            }
        };
        TextBlot.prototype.length = function () {
            return this.text.length;
        };
        TextBlot.prototype.optimize = function (context) {
            _super.prototype.optimize.call(this, context);
            this.text = this.statics.value(this.domNode);
            if (this.text.length === 0) {
                this.remove();
            }
            else if (this.next instanceof TextBlot && this.next.prev === this) {
                this.insertAt(this.length(), this.next.value());
                this.next.remove();
            }
        };
        TextBlot.prototype.position = function (index, inclusive) {
            return [this.domNode, index];
        };
        TextBlot.prototype.split = function (index, force) {
            if (force === void 0) { force = false; }
            if (!force) {
                if (index === 0)
                    return this;
                if (index === this.length())
                    return this.next;
            }
            var after = Registry.create(this.domNode.splitText(index));
            this.parent.insertBefore(after, this.next);
            this.text = this.statics.value(this.domNode);
            return after;
        };
        TextBlot.prototype.update = function (mutations, context) {
            var _this = this;
            if (mutations.some(function (mutation) {
                return mutation.type === 'characterData' && mutation.target === _this.domNode;
            })) {
                this.text = this.statics.value(this.domNode);
            }
        };
        TextBlot.prototype.value = function () {
            return this.text;
        };
        TextBlot.blotName = 'text';
        TextBlot.scope = Registry.Scope.INLINE_BLOT;
        return TextBlot;
    }(leaf_1.default));
    exports.default = TextBlot;


    /***/ }),
    /* 50 */
    /***/ (function(module, exports, __webpack_require__) {


    var elem = document.createElement('div');
    elem.classList.toggle('test-class', false);
    if (elem.classList.contains('test-class')) {
      var _toggle = DOMTokenList.prototype.toggle;
      DOMTokenList.prototype.toggle = function (token, force) {
        if (arguments.length > 1 && !this.contains(token) === !force) {
          return force;
        } else {
          return _toggle.call(this, token);
        }
      };
    }

    if (!String.prototype.startsWith) {
      String.prototype.startsWith = function (searchString, position) {
        position = position || 0;
        return this.substr(position, searchString.length) === searchString;
      };
    }

    if (!String.prototype.endsWith) {
      String.prototype.endsWith = function (searchString, position) {
        var subjectString = this.toString();
        if (typeof position !== 'number' || !isFinite(position) || Math.floor(position) !== position || position > subjectString.length) {
          position = subjectString.length;
        }
        position -= searchString.length;
        var lastIndex = subjectString.indexOf(searchString, position);
        return lastIndex !== -1 && lastIndex === position;
      };
    }

    if (!Array.prototype.find) {
      Object.defineProperty(Array.prototype, "find", {
        value: function value(predicate) {
          if (this === null) {
            throw new TypeError('Array.prototype.find called on null or undefined');
          }
          if (typeof predicate !== 'function') {
            throw new TypeError('predicate must be a function');
          }
          var list = Object(this);
          var length = list.length >>> 0;
          var thisArg = arguments[1];
          var value;

          for (var i = 0; i < length; i++) {
            value = list[i];
            if (predicate.call(thisArg, value, i, list)) {
              return value;
            }
          }
          return undefined;
        }
      });
    }

    document.addEventListener("DOMContentLoaded", function () {
      // Disable resizing in Firefox
      document.execCommand("enableObjectResizing", false, false);
      // Disable automatic linkifying in IE11
      document.execCommand("autoUrlDetect", false, false);
    });

    /***/ }),
    /* 51 */
    /***/ (function(module, exports) {

    /**
     * This library modifies the diff-patch-match library by Neil Fraser
     * by removing the patch and match functionality and certain advanced
     * options in the diff function. The original license is as follows:
     *
     * ===
     *
     * Diff Match and Patch
     *
     * Copyright 2006 Google Inc.
     * http://code.google.com/p/google-diff-match-patch/
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *   http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */


    /**
     * The data structure representing a diff is an array of tuples:
     * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]
     * which means: delete 'Hello', add 'Goodbye' and keep ' world.'
     */
    var DIFF_DELETE = -1;
    var DIFF_INSERT = 1;
    var DIFF_EQUAL = 0;


    /**
     * Find the differences between two texts.  Simplifies the problem by stripping
     * any common prefix or suffix off the texts before diffing.
     * @param {string} text1 Old string to be diffed.
     * @param {string} text2 New string to be diffed.
     * @param {Int} cursor_pos Expected edit position in text1 (optional)
     * @return {Array} Array of diff tuples.
     */
    function diff_main(text1, text2, cursor_pos) {
      // Check for equality (speedup).
      if (text1 == text2) {
        if (text1) {
          return [[DIFF_EQUAL, text1]];
        }
        return [];
      }

      // Check cursor_pos within bounds
      if (cursor_pos < 0 || text1.length < cursor_pos) {
        cursor_pos = null;
      }

      // Trim off common prefix (speedup).
      var commonlength = diff_commonPrefix(text1, text2);
      var commonprefix = text1.substring(0, commonlength);
      text1 = text1.substring(commonlength);
      text2 = text2.substring(commonlength);

      // Trim off common suffix (speedup).
      commonlength = diff_commonSuffix(text1, text2);
      var commonsuffix = text1.substring(text1.length - commonlength);
      text1 = text1.substring(0, text1.length - commonlength);
      text2 = text2.substring(0, text2.length - commonlength);

      // Compute the diff on the middle block.
      var diffs = diff_compute_(text1, text2);

      // Restore the prefix and suffix.
      if (commonprefix) {
        diffs.unshift([DIFF_EQUAL, commonprefix]);
      }
      if (commonsuffix) {
        diffs.push([DIFF_EQUAL, commonsuffix]);
      }
      diff_cleanupMerge(diffs);
      if (cursor_pos != null) {
        diffs = fix_cursor(diffs, cursor_pos);
      }
      diffs = fix_emoji(diffs);
      return diffs;
    }

    /**
     * Find the differences between two texts.  Assumes that the texts do not
     * have any common prefix or suffix.
     * @param {string} text1 Old string to be diffed.
     * @param {string} text2 New string to be diffed.
     * @return {Array} Array of diff tuples.
     */
    function diff_compute_(text1, text2) {
      var diffs;

      if (!text1) {
        // Just add some text (speedup).
        return [[DIFF_INSERT, text2]];
      }

      if (!text2) {
        // Just delete some text (speedup).
        return [[DIFF_DELETE, text1]];
      }

      var longtext = text1.length > text2.length ? text1 : text2;
      var shorttext = text1.length > text2.length ? text2 : text1;
      var i = longtext.indexOf(shorttext);
      if (i != -1) {
        // Shorter text is inside the longer text (speedup).
        diffs = [[DIFF_INSERT, longtext.substring(0, i)],
                 [DIFF_EQUAL, shorttext],
                 [DIFF_INSERT, longtext.substring(i + shorttext.length)]];
        // Swap insertions for deletions if diff is reversed.
        if (text1.length > text2.length) {
          diffs[0][0] = diffs[2][0] = DIFF_DELETE;
        }
        return diffs;
      }

      if (shorttext.length == 1) {
        // Single character string.
        // After the previous speedup, the character can't be an equality.
        return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];
      }

      // Check to see if the problem can be split in two.
      var hm = diff_halfMatch_(text1, text2);
      if (hm) {
        // A half-match was found, sort out the return data.
        var text1_a = hm[0];
        var text1_b = hm[1];
        var text2_a = hm[2];
        var text2_b = hm[3];
        var mid_common = hm[4];
        // Send both pairs off for separate processing.
        var diffs_a = diff_main(text1_a, text2_a);
        var diffs_b = diff_main(text1_b, text2_b);
        // Merge the results.
        return diffs_a.concat([[DIFF_EQUAL, mid_common]], diffs_b);
      }

      return diff_bisect_(text1, text2);
    }

    /**
     * Find the 'middle snake' of a diff, split the problem in two
     * and return the recursively constructed diff.
     * See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.
     * @param {string} text1 Old string to be diffed.
     * @param {string} text2 New string to be diffed.
     * @return {Array} Array of diff tuples.
     * @private
     */
    function diff_bisect_(text1, text2) {
      // Cache the text lengths to prevent multiple calls.
      var text1_length = text1.length;
      var text2_length = text2.length;
      var max_d = Math.ceil((text1_length + text2_length) / 2);
      var v_offset = max_d;
      var v_length = 2 * max_d;
      var v1 = new Array(v_length);
      var v2 = new Array(v_length);
      // Setting all elements to -1 is faster in Chrome & Firefox than mixing
      // integers and undefined.
      for (var x = 0; x < v_length; x++) {
        v1[x] = -1;
        v2[x] = -1;
      }
      v1[v_offset + 1] = 0;
      v2[v_offset + 1] = 0;
      var delta = text1_length - text2_length;
      // If the total number of characters is odd, then the front path will collide
      // with the reverse path.
      var front = (delta % 2 != 0);
      // Offsets for start and end of k loop.
      // Prevents mapping of space beyond the grid.
      var k1start = 0;
      var k1end = 0;
      var k2start = 0;
      var k2end = 0;
      for (var d = 0; d < max_d; d++) {
        // Walk the front path one step.
        for (var k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {
          var k1_offset = v_offset + k1;
          var x1;
          if (k1 == -d || (k1 != d && v1[k1_offset - 1] < v1[k1_offset + 1])) {
            x1 = v1[k1_offset + 1];
          } else {
            x1 = v1[k1_offset - 1] + 1;
          }
          var y1 = x1 - k1;
          while (x1 < text1_length && y1 < text2_length &&
                 text1.charAt(x1) == text2.charAt(y1)) {
            x1++;
            y1++;
          }
          v1[k1_offset] = x1;
          if (x1 > text1_length) {
            // Ran off the right of the graph.
            k1end += 2;
          } else if (y1 > text2_length) {
            // Ran off the bottom of the graph.
            k1start += 2;
          } else if (front) {
            var k2_offset = v_offset + delta - k1;
            if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] != -1) {
              // Mirror x2 onto top-left coordinate system.
              var x2 = text1_length - v2[k2_offset];
              if (x1 >= x2) {
                // Overlap detected.
                return diff_bisectSplit_(text1, text2, x1, y1);
              }
            }
          }
        }

        // Walk the reverse path one step.
        for (var k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {
          var k2_offset = v_offset + k2;
          var x2;
          if (k2 == -d || (k2 != d && v2[k2_offset - 1] < v2[k2_offset + 1])) {
            x2 = v2[k2_offset + 1];
          } else {
            x2 = v2[k2_offset - 1] + 1;
          }
          var y2 = x2 - k2;
          while (x2 < text1_length && y2 < text2_length &&
                 text1.charAt(text1_length - x2 - 1) ==
                 text2.charAt(text2_length - y2 - 1)) {
            x2++;
            y2++;
          }
          v2[k2_offset] = x2;
          if (x2 > text1_length) {
            // Ran off the left of the graph.
            k2end += 2;
          } else if (y2 > text2_length) {
            // Ran off the top of the graph.
            k2start += 2;
          } else if (!front) {
            var k1_offset = v_offset + delta - k2;
            if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] != -1) {
              var x1 = v1[k1_offset];
              var y1 = v_offset + x1 - k1_offset;
              // Mirror x2 onto top-left coordinate system.
              x2 = text1_length - x2;
              if (x1 >= x2) {
                // Overlap detected.
                return diff_bisectSplit_(text1, text2, x1, y1);
              }
            }
          }
        }
      }
      // Diff took too long and hit the deadline or
      // number of diffs equals number of characters, no commonality at all.
      return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];
    }

    /**
     * Given the location of the 'middle snake', split the diff in two parts
     * and recurse.
     * @param {string} text1 Old string to be diffed.
     * @param {string} text2 New string to be diffed.
     * @param {number} x Index of split point in text1.
     * @param {number} y Index of split point in text2.
     * @return {Array} Array of diff tuples.
     */
    function diff_bisectSplit_(text1, text2, x, y) {
      var text1a = text1.substring(0, x);
      var text2a = text2.substring(0, y);
      var text1b = text1.substring(x);
      var text2b = text2.substring(y);

      // Compute both diffs serially.
      var diffs = diff_main(text1a, text2a);
      var diffsb = diff_main(text1b, text2b);

      return diffs.concat(diffsb);
    }

    /**
     * Determine the common prefix of two strings.
     * @param {string} text1 First string.
     * @param {string} text2 Second string.
     * @return {number} The number of characters common to the start of each
     *     string.
     */
    function diff_commonPrefix(text1, text2) {
      // Quick check for common null cases.
      if (!text1 || !text2 || text1.charAt(0) != text2.charAt(0)) {
        return 0;
      }
      // Binary search.
      // Performance analysis: http://neil.fraser.name/news/2007/10/09/
      var pointermin = 0;
      var pointermax = Math.min(text1.length, text2.length);
      var pointermid = pointermax;
      var pointerstart = 0;
      while (pointermin < pointermid) {
        if (text1.substring(pointerstart, pointermid) ==
            text2.substring(pointerstart, pointermid)) {
          pointermin = pointermid;
          pointerstart = pointermin;
        } else {
          pointermax = pointermid;
        }
        pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
      }
      return pointermid;
    }

    /**
     * Determine the common suffix of two strings.
     * @param {string} text1 First string.
     * @param {string} text2 Second string.
     * @return {number} The number of characters common to the end of each string.
     */
    function diff_commonSuffix(text1, text2) {
      // Quick check for common null cases.
      if (!text1 || !text2 ||
          text1.charAt(text1.length - 1) != text2.charAt(text2.length - 1)) {
        return 0;
      }
      // Binary search.
      // Performance analysis: http://neil.fraser.name/news/2007/10/09/
      var pointermin = 0;
      var pointermax = Math.min(text1.length, text2.length);
      var pointermid = pointermax;
      var pointerend = 0;
      while (pointermin < pointermid) {
        if (text1.substring(text1.length - pointermid, text1.length - pointerend) ==
            text2.substring(text2.length - pointermid, text2.length - pointerend)) {
          pointermin = pointermid;
          pointerend = pointermin;
        } else {
          pointermax = pointermid;
        }
        pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
      }
      return pointermid;
    }

    /**
     * Do the two texts share a substring which is at least half the length of the
     * longer text?
     * This speedup can produce non-minimal diffs.
     * @param {string} text1 First string.
     * @param {string} text2 Second string.
     * @return {Array.<string>} Five element Array, containing the prefix of
     *     text1, the suffix of text1, the prefix of text2, the suffix of
     *     text2 and the common middle.  Or null if there was no match.
     */
    function diff_halfMatch_(text1, text2) {
      var longtext = text1.length > text2.length ? text1 : text2;
      var shorttext = text1.length > text2.length ? text2 : text1;
      if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {
        return null;  // Pointless.
      }

      /**
       * Does a substring of shorttext exist within longtext such that the substring
       * is at least half the length of longtext?
       * Closure, but does not reference any external variables.
       * @param {string} longtext Longer string.
       * @param {string} shorttext Shorter string.
       * @param {number} i Start index of quarter length substring within longtext.
       * @return {Array.<string>} Five element Array, containing the prefix of
       *     longtext, the suffix of longtext, the prefix of shorttext, the suffix
       *     of shorttext and the common middle.  Or null if there was no match.
       * @private
       */
      function diff_halfMatchI_(longtext, shorttext, i) {
        // Start with a 1/4 length substring at position i as a seed.
        var seed = longtext.substring(i, i + Math.floor(longtext.length / 4));
        var j = -1;
        var best_common = '';
        var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;
        while ((j = shorttext.indexOf(seed, j + 1)) != -1) {
          var prefixLength = diff_commonPrefix(longtext.substring(i),
                                               shorttext.substring(j));
          var suffixLength = diff_commonSuffix(longtext.substring(0, i),
                                               shorttext.substring(0, j));
          if (best_common.length < suffixLength + prefixLength) {
            best_common = shorttext.substring(j - suffixLength, j) +
                shorttext.substring(j, j + prefixLength);
            best_longtext_a = longtext.substring(0, i - suffixLength);
            best_longtext_b = longtext.substring(i + prefixLength);
            best_shorttext_a = shorttext.substring(0, j - suffixLength);
            best_shorttext_b = shorttext.substring(j + prefixLength);
          }
        }
        if (best_common.length * 2 >= longtext.length) {
          return [best_longtext_a, best_longtext_b,
                  best_shorttext_a, best_shorttext_b, best_common];
        } else {
          return null;
        }
      }

      // First check if the second quarter is the seed for a half-match.
      var hm1 = diff_halfMatchI_(longtext, shorttext,
                                 Math.ceil(longtext.length / 4));
      // Check again based on the third quarter.
      var hm2 = diff_halfMatchI_(longtext, shorttext,
                                 Math.ceil(longtext.length / 2));
      var hm;
      if (!hm1 && !hm2) {
        return null;
      } else if (!hm2) {
        hm = hm1;
      } else if (!hm1) {
        hm = hm2;
      } else {
        // Both matched.  Select the longest.
        hm = hm1[4].length > hm2[4].length ? hm1 : hm2;
      }

      // A half-match was found, sort out the return data.
      var text1_a, text1_b, text2_a, text2_b;
      if (text1.length > text2.length) {
        text1_a = hm[0];
        text1_b = hm[1];
        text2_a = hm[2];
        text2_b = hm[3];
      } else {
        text2_a = hm[0];
        text2_b = hm[1];
        text1_a = hm[2];
        text1_b = hm[3];
      }
      var mid_common = hm[4];
      return [text1_a, text1_b, text2_a, text2_b, mid_common];
    }

    /**
     * Reorder and merge like edit sections.  Merge equalities.
     * Any edit section can move as long as it doesn't cross an equality.
     * @param {Array} diffs Array of diff tuples.
     */
    function diff_cleanupMerge(diffs) {
      diffs.push([DIFF_EQUAL, '']);  // Add a dummy entry at the end.
      var pointer = 0;
      var count_delete = 0;
      var count_insert = 0;
      var text_delete = '';
      var text_insert = '';
      var commonlength;
      while (pointer < diffs.length) {
        switch (diffs[pointer][0]) {
          case DIFF_INSERT:
            count_insert++;
            text_insert += diffs[pointer][1];
            pointer++;
            break;
          case DIFF_DELETE:
            count_delete++;
            text_delete += diffs[pointer][1];
            pointer++;
            break;
          case DIFF_EQUAL:
            // Upon reaching an equality, check for prior redundancies.
            if (count_delete + count_insert > 1) {
              if (count_delete !== 0 && count_insert !== 0) {
                // Factor out any common prefixies.
                commonlength = diff_commonPrefix(text_insert, text_delete);
                if (commonlength !== 0) {
                  if ((pointer - count_delete - count_insert) > 0 &&
                      diffs[pointer - count_delete - count_insert - 1][0] ==
                      DIFF_EQUAL) {
                    diffs[pointer - count_delete - count_insert - 1][1] +=
                        text_insert.substring(0, commonlength);
                  } else {
                    diffs.splice(0, 0, [DIFF_EQUAL,
                                        text_insert.substring(0, commonlength)]);
                    pointer++;
                  }
                  text_insert = text_insert.substring(commonlength);
                  text_delete = text_delete.substring(commonlength);
                }
                // Factor out any common suffixies.
                commonlength = diff_commonSuffix(text_insert, text_delete);
                if (commonlength !== 0) {
                  diffs[pointer][1] = text_insert.substring(text_insert.length -
                      commonlength) + diffs[pointer][1];
                  text_insert = text_insert.substring(0, text_insert.length -
                      commonlength);
                  text_delete = text_delete.substring(0, text_delete.length -
                      commonlength);
                }
              }
              // Delete the offending records and add the merged ones.
              if (count_delete === 0) {
                diffs.splice(pointer - count_insert,
                    count_delete + count_insert, [DIFF_INSERT, text_insert]);
              } else if (count_insert === 0) {
                diffs.splice(pointer - count_delete,
                    count_delete + count_insert, [DIFF_DELETE, text_delete]);
              } else {
                diffs.splice(pointer - count_delete - count_insert,
                    count_delete + count_insert, [DIFF_DELETE, text_delete],
                    [DIFF_INSERT, text_insert]);
              }
              pointer = pointer - count_delete - count_insert +
                        (count_delete ? 1 : 0) + (count_insert ? 1 : 0) + 1;
            } else if (pointer !== 0 && diffs[pointer - 1][0] == DIFF_EQUAL) {
              // Merge this equality with the previous one.
              diffs[pointer - 1][1] += diffs[pointer][1];
              diffs.splice(pointer, 1);
            } else {
              pointer++;
            }
            count_insert = 0;
            count_delete = 0;
            text_delete = '';
            text_insert = '';
            break;
        }
      }
      if (diffs[diffs.length - 1][1] === '') {
        diffs.pop();  // Remove the dummy entry at the end.
      }

      // Second pass: look for single edits surrounded on both sides by equalities
      // which can be shifted sideways to eliminate an equality.
      // e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC
      var changes = false;
      pointer = 1;
      // Intentionally ignore the first and last element (don't need checking).
      while (pointer < diffs.length - 1) {
        if (diffs[pointer - 1][0] == DIFF_EQUAL &&
            diffs[pointer + 1][0] == DIFF_EQUAL) {
          // This is a single edit surrounded by equalities.
          if (diffs[pointer][1].substring(diffs[pointer][1].length -
              diffs[pointer - 1][1].length) == diffs[pointer - 1][1]) {
            // Shift the edit over the previous equality.
            diffs[pointer][1] = diffs[pointer - 1][1] +
                diffs[pointer][1].substring(0, diffs[pointer][1].length -
                                            diffs[pointer - 1][1].length);
            diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];
            diffs.splice(pointer - 1, 1);
            changes = true;
          } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) ==
              diffs[pointer + 1][1]) {
            // Shift the edit over the next equality.
            diffs[pointer - 1][1] += diffs[pointer + 1][1];
            diffs[pointer][1] =
                diffs[pointer][1].substring(diffs[pointer + 1][1].length) +
                diffs[pointer + 1][1];
            diffs.splice(pointer + 1, 1);
            changes = true;
          }
        }
        pointer++;
      }
      // If shifts were made, the diff needs reordering and another shift sweep.
      if (changes) {
        diff_cleanupMerge(diffs);
      }
    }

    var diff = diff_main;
    diff.INSERT = DIFF_INSERT;
    diff.DELETE = DIFF_DELETE;
    diff.EQUAL = DIFF_EQUAL;

    module.exports = diff;

    /*
     * Modify a diff such that the cursor position points to the start of a change:
     * E.g.
     *   cursor_normalize_diff([[DIFF_EQUAL, 'abc']], 1)
     *     => [1, [[DIFF_EQUAL, 'a'], [DIFF_EQUAL, 'bc']]]
     *   cursor_normalize_diff([[DIFF_INSERT, 'new'], [DIFF_DELETE, 'xyz']], 2)
     *     => [2, [[DIFF_INSERT, 'new'], [DIFF_DELETE, 'xy'], [DIFF_DELETE, 'z']]]
     *
     * @param {Array} diffs Array of diff tuples
     * @param {Int} cursor_pos Suggested edit position. Must not be out of bounds!
     * @return {Array} A tuple [cursor location in the modified diff, modified diff]
     */
    function cursor_normalize_diff (diffs, cursor_pos) {
      if (cursor_pos === 0) {
        return [DIFF_EQUAL, diffs];
      }
      for (var current_pos = 0, i = 0; i < diffs.length; i++) {
        var d = diffs[i];
        if (d[0] === DIFF_DELETE || d[0] === DIFF_EQUAL) {
          var next_pos = current_pos + d[1].length;
          if (cursor_pos === next_pos) {
            return [i + 1, diffs];
          } else if (cursor_pos < next_pos) {
            // copy to prevent side effects
            diffs = diffs.slice();
            // split d into two diff changes
            var split_pos = cursor_pos - current_pos;
            var d_left = [d[0], d[1].slice(0, split_pos)];
            var d_right = [d[0], d[1].slice(split_pos)];
            diffs.splice(i, 1, d_left, d_right);
            return [i + 1, diffs];
          } else {
            current_pos = next_pos;
          }
        }
      }
      throw new Error('cursor_pos is out of bounds!')
    }

    /*
     * Modify a diff such that the edit position is "shifted" to the proposed edit location (cursor_position).
     *
     * Case 1)
     *   Check if a naive shift is possible:
     *     [0, X], [ 1, Y] -> [ 1, Y], [0, X]    (if X + Y === Y + X)
     *     [0, X], [-1, Y] -> [-1, Y], [0, X]    (if X + Y === Y + X) - holds same result
     * Case 2)
     *   Check if the following shifts are possible:
     *     [0, 'pre'], [ 1, 'prefix'] -> [ 1, 'pre'], [0, 'pre'], [ 1, 'fix']
     *     [0, 'pre'], [-1, 'prefix'] -> [-1, 'pre'], [0, 'pre'], [-1, 'fix']
     *         ^            ^
     *         d          d_next
     *
     * @param {Array} diffs Array of diff tuples
     * @param {Int} cursor_pos Suggested edit position. Must not be out of bounds!
     * @return {Array} Array of diff tuples
     */
    function fix_cursor (diffs, cursor_pos) {
      var norm = cursor_normalize_diff(diffs, cursor_pos);
      var ndiffs = norm[1];
      var cursor_pointer = norm[0];
      var d = ndiffs[cursor_pointer];
      var d_next = ndiffs[cursor_pointer + 1];

      if (d == null) {
        // Text was deleted from end of original string,
        // cursor is now out of bounds in new string
        return diffs;
      } else if (d[0] !== DIFF_EQUAL) {
        // A modification happened at the cursor location.
        // This is the expected outcome, so we can return the original diff.
        return diffs;
      } else {
        if (d_next != null && d[1] + d_next[1] === d_next[1] + d[1]) {
          // Case 1)
          // It is possible to perform a naive shift
          ndiffs.splice(cursor_pointer, 2, d_next, d);
          return merge_tuples(ndiffs, cursor_pointer, 2)
        } else if (d_next != null && d_next[1].indexOf(d[1]) === 0) {
          // Case 2)
          // d[1] is a prefix of d_next[1]
          // We can assume that d_next[0] !== 0, since d[0] === 0
          // Shift edit locations..
          ndiffs.splice(cursor_pointer, 2, [d_next[0], d[1]], [0, d[1]]);
          var suffix = d_next[1].slice(d[1].length);
          if (suffix.length > 0) {
            ndiffs.splice(cursor_pointer + 2, 0, [d_next[0], suffix]);
          }
          return merge_tuples(ndiffs, cursor_pointer, 3)
        } else {
          // Not possible to perform any modification
          return diffs;
        }
      }
    }

    /*
     * Check diff did not split surrogate pairs.
     * Ex. [0, '\uD83D'], [-1, '\uDC36'], [1, '\uDC2F'] -> [-1, '\uD83D\uDC36'], [1, '\uD83D\uDC2F']
     *     '\uD83D\uDC36' === '🐶', '\uD83D\uDC2F' === '🐯'
     *
     * @param {Array} diffs Array of diff tuples
     * @return {Array} Array of diff tuples
     */
    function fix_emoji (diffs) {
      var compact = false;
      var starts_with_pair_end = function(str) {
        return str.charCodeAt(0) >= 0xDC00 && str.charCodeAt(0) <= 0xDFFF;
      };
      var ends_with_pair_start = function(str) {
        return str.charCodeAt(str.length-1) >= 0xD800 && str.charCodeAt(str.length-1) <= 0xDBFF;
      };
      for (var i = 2; i < diffs.length; i += 1) {
        if (diffs[i-2][0] === DIFF_EQUAL && ends_with_pair_start(diffs[i-2][1]) &&
            diffs[i-1][0] === DIFF_DELETE && starts_with_pair_end(diffs[i-1][1]) &&
            diffs[i][0] === DIFF_INSERT && starts_with_pair_end(diffs[i][1])) {
          compact = true;

          diffs[i-1][1] = diffs[i-2][1].slice(-1) + diffs[i-1][1];
          diffs[i][1] = diffs[i-2][1].slice(-1) + diffs[i][1];

          diffs[i-2][1] = diffs[i-2][1].slice(0, -1);
        }
      }
      if (!compact) {
        return diffs;
      }
      var fixed_diffs = [];
      for (var i = 0; i < diffs.length; i += 1) {
        if (diffs[i][1].length > 0) {
          fixed_diffs.push(diffs[i]);
        }
      }
      return fixed_diffs;
    }

    /*
     * Try to merge tuples with their neigbors in a given range.
     * E.g. [0, 'a'], [0, 'b'] -> [0, 'ab']
     *
     * @param {Array} diffs Array of diff tuples.
     * @param {Int} start Position of the first element to merge (diffs[start] is also merged with diffs[start - 1]).
     * @param {Int} length Number of consecutive elements to check.
     * @return {Array} Array of merged diff tuples.
     */
    function merge_tuples (diffs, start, length) {
      // Check from (start-1) to (start+length).
      for (var i = start + length - 1; i >= 0 && i >= start - 1; i--) {
        if (i + 1 < diffs.length) {
          var left_d = diffs[i];
          var right_d = diffs[i+1];
          if (left_d[0] === right_d[1]) {
            diffs.splice(i, 2, [left_d[0], left_d[1] + right_d[1]]);
          }
        }
      }
      return diffs;
    }


    /***/ }),
    /* 52 */
    /***/ (function(module, exports) {

    exports = module.exports = typeof Object.keys === 'function'
      ? Object.keys : shim;

    exports.shim = shim;
    function shim (obj) {
      var keys = [];
      for (var key in obj) keys.push(key);
      return keys;
    }


    /***/ }),
    /* 53 */
    /***/ (function(module, exports) {

    var supportsArgumentsClass = (function(){
      return Object.prototype.toString.call(arguments)
    })() == '[object Arguments]';

    exports = module.exports = supportsArgumentsClass ? supported : unsupported;

    exports.supported = supported;
    function supported(object) {
      return Object.prototype.toString.call(object) == '[object Arguments]';
    }
    exports.unsupported = unsupported;
    function unsupported(object){
      return object &&
        typeof object == 'object' &&
        typeof object.length == 'number' &&
        Object.prototype.hasOwnProperty.call(object, 'callee') &&
        !Object.prototype.propertyIsEnumerable.call(object, 'callee') ||
        false;
    }

    /***/ }),
    /* 54 */
    /***/ (function(module, exports) {

    var has = Object.prototype.hasOwnProperty
      , prefix = '~';

    /**
     * Constructor to create a storage for our `EE` objects.
     * An `Events` instance is a plain object whose properties are event names.
     *
     * @constructor
     * @api private
     */
    function Events() {}

    //
    // We try to not inherit from `Object.prototype`. In some engines creating an
    // instance in this way is faster than calling `Object.create(null)` directly.
    // If `Object.create(null)` is not supported we prefix the event names with a
    // character to make sure that the built-in object properties are not
    // overridden or used as an attack vector.
    //
    if (Object.create) {
      Events.prototype = Object.create(null);

      //
      // This hack is needed because the `__proto__` property is still inherited in
      // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.
      //
      if (!new Events().__proto__) prefix = false;
    }

    /**
     * Representation of a single event listener.
     *
     * @param {Function} fn The listener function.
     * @param {Mixed} context The context to invoke the listener with.
     * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
     * @constructor
     * @api private
     */
    function EE(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }

    /**
     * Minimal `EventEmitter` interface that is molded against the Node.js
     * `EventEmitter` interface.
     *
     * @constructor
     * @api public
     */
    function EventEmitter() {
      this._events = new Events();
      this._eventsCount = 0;
    }

    /**
     * Return an array listing the events for which the emitter has registered
     * listeners.
     *
     * @returns {Array}
     * @api public
     */
    EventEmitter.prototype.eventNames = function eventNames() {
      var names = []
        , events
        , name;

      if (this._eventsCount === 0) return names;

      for (name in (events = this._events)) {
        if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
      }

      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }

      return names;
    };

    /**
     * Return the listeners registered for a given event.
     *
     * @param {String|Symbol} event The event name.
     * @param {Boolean} exists Only check if there are listeners.
     * @returns {Array|Boolean}
     * @api public
     */
    EventEmitter.prototype.listeners = function listeners(event, exists) {
      var evt = prefix ? prefix + event : event
        , available = this._events[evt];

      if (exists) return !!available;
      if (!available) return [];
      if (available.fn) return [available.fn];

      for (var i = 0, l = available.length, ee = new Array(l); i < l; i++) {
        ee[i] = available[i].fn;
      }

      return ee;
    };

    /**
     * Calls each of the listeners registered for a given event.
     *
     * @param {String|Symbol} event The event name.
     * @returns {Boolean} `true` if the event had listeners, else `false`.
     * @api public
     */
    EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;

      if (!this._events[evt]) return false;

      var listeners = this._events[evt]
        , len = arguments.length
        , args
        , i;

      if (listeners.fn) {
        if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);

        switch (len) {
          case 1: return listeners.fn.call(listeners.context), true;
          case 2: return listeners.fn.call(listeners.context, a1), true;
          case 3: return listeners.fn.call(listeners.context, a1, a2), true;
          case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }

        for (i = 1, args = new Array(len -1); i < len; i++) {
          args[i - 1] = arguments[i];
        }

        listeners.fn.apply(listeners.context, args);
      } else {
        var length = listeners.length
          , j;

        for (i = 0; i < length; i++) {
          if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);

          switch (len) {
            case 1: listeners[i].fn.call(listeners[i].context); break;
            case 2: listeners[i].fn.call(listeners[i].context, a1); break;
            case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;
            case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;
            default:
              if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {
                args[j - 1] = arguments[j];
              }

              listeners[i].fn.apply(listeners[i].context, args);
          }
        }
      }

      return true;
    };

    /**
     * Add a listener for a given event.
     *
     * @param {String|Symbol} event The event name.
     * @param {Function} fn The listener function.
     * @param {Mixed} [context=this] The context to invoke the listener with.
     * @returns {EventEmitter} `this`.
     * @api public
     */
    EventEmitter.prototype.on = function on(event, fn, context) {
      var listener = new EE(fn, context || this)
        , evt = prefix ? prefix + event : event;

      if (!this._events[evt]) this._events[evt] = listener, this._eventsCount++;
      else if (!this._events[evt].fn) this._events[evt].push(listener);
      else this._events[evt] = [this._events[evt], listener];

      return this;
    };

    /**
     * Add a one-time listener for a given event.
     *
     * @param {String|Symbol} event The event name.
     * @param {Function} fn The listener function.
     * @param {Mixed} [context=this] The context to invoke the listener with.
     * @returns {EventEmitter} `this`.
     * @api public
     */
    EventEmitter.prototype.once = function once(event, fn, context) {
      var listener = new EE(fn, context || this, true)
        , evt = prefix ? prefix + event : event;

      if (!this._events[evt]) this._events[evt] = listener, this._eventsCount++;
      else if (!this._events[evt].fn) this._events[evt].push(listener);
      else this._events[evt] = [this._events[evt], listener];

      return this;
    };

    /**
     * Remove the listeners of a given event.
     *
     * @param {String|Symbol} event The event name.
     * @param {Function} fn Only remove the listeners that match this function.
     * @param {Mixed} context Only remove the listeners that have this context.
     * @param {Boolean} once Only remove one-time listeners.
     * @returns {EventEmitter} `this`.
     * @api public
     */
    EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
      var evt = prefix ? prefix + event : event;

      if (!this._events[evt]) return this;
      if (!fn) {
        if (--this._eventsCount === 0) this._events = new Events();
        else delete this._events[evt];
        return this;
      }

      var listeners = this._events[evt];

      if (listeners.fn) {
        if (
             listeners.fn === fn
          && (!once || listeners.once)
          && (!context || listeners.context === context)
        ) {
          if (--this._eventsCount === 0) this._events = new Events();
          else delete this._events[evt];
        }
      } else {
        for (var i = 0, events = [], length = listeners.length; i < length; i++) {
          if (
               listeners[i].fn !== fn
            || (once && !listeners[i].once)
            || (context && listeners[i].context !== context)
          ) {
            events.push(listeners[i]);
          }
        }

        //
        // Reset the array, or remove it completely if we have no more listeners.
        //
        if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
        else if (--this._eventsCount === 0) this._events = new Events();
        else delete this._events[evt];
      }

      return this;
    };

    /**
     * Remove all listeners, or those of the specified event.
     *
     * @param {String|Symbol} [event] The event name.
     * @returns {EventEmitter} `this`.
     * @api public
     */
    EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;

      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt]) {
          if (--this._eventsCount === 0) this._events = new Events();
          else delete this._events[evt];
        }
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }

      return this;
    };

    //
    // Alias methods names because people roll like that.
    //
    EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
    EventEmitter.prototype.addListener = EventEmitter.prototype.on;

    //
    // This function doesn't apply anymore.
    //
    EventEmitter.prototype.setMaxListeners = function setMaxListeners() {
      return this;
    };

    //
    // Expose the prefix.
    //
    EventEmitter.prefixed = prefix;

    //
    // Allow `EventEmitter` to be imported as module namespace.
    //
    EventEmitter.EventEmitter = EventEmitter;

    //
    // Expose the module.
    //
    if ('undefined' !== typeof module) {
      module.exports = EventEmitter;
    }


    /***/ }),
    /* 55 */
    /***/ (function(module, exports, __webpack_require__) {


    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.matchText = exports.matchSpacing = exports.matchNewline = exports.matchBlot = exports.matchAttributor = exports.default = undefined;

    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

    var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

    var _extend2 = __webpack_require__(3);

    var _extend3 = _interopRequireDefault(_extend2);

    var _quillDelta = __webpack_require__(2);

    var _quillDelta2 = _interopRequireDefault(_quillDelta);

    var _parchment = __webpack_require__(0);

    var _parchment2 = _interopRequireDefault(_parchment);

    var _quill = __webpack_require__(5);

    var _quill2 = _interopRequireDefault(_quill);

    var _logger = __webpack_require__(10);

    var _logger2 = _interopRequireDefault(_logger);

    var _module = __webpack_require__(9);

    var _module2 = _interopRequireDefault(_module);

    var _align = __webpack_require__(36);

    var _background = __webpack_require__(37);

    var _code = __webpack_require__(13);

    var _code2 = _interopRequireDefault(_code);

    var _color = __webpack_require__(26);

    var _direction = __webpack_require__(38);

    var _font = __webpack_require__(39);

    var _size = __webpack_require__(40);

    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    var debug = (0, _logger2.default)('quill:clipboard');

    var DOM_KEY = '__ql-matcher';

    var CLIPBOARD_CONFIG = [[Node.TEXT_NODE, matchText], [Node.TEXT_NODE, matchNewline], ['br', matchBreak], [Node.ELEMENT_NODE, matchNewline], [Node.ELEMENT_NODE, matchBlot], [Node.ELEMENT_NODE, matchSpacing], [Node.ELEMENT_NODE, matchAttributor], [Node.ELEMENT_NODE, matchStyles], ['li', matchIndent], ['b', matchAlias.bind(matchAlias, 'bold')], ['i', matchAlias.bind(matchAlias, 'italic')], ['style', matchIgnore]];

    var ATTRIBUTE_ATTRIBUTORS = [_align.AlignAttribute, _direction.DirectionAttribute].reduce(function (memo, attr) {
      memo[attr.keyName] = attr;
      return memo;
    }, {});

    var STYLE_ATTRIBUTORS = [_align.AlignStyle, _background.BackgroundStyle, _color.ColorStyle, _direction.DirectionStyle, _font.FontStyle, _size.SizeStyle].reduce(function (memo, attr) {
      memo[attr.keyName] = attr;
      return memo;
    }, {});

    var Clipboard = function (_Module) {
      _inherits(Clipboard, _Module);

      function Clipboard(quill, options) {
        _classCallCheck(this, Clipboard);

        var _this = _possibleConstructorReturn(this, (Clipboard.__proto__ || Object.getPrototypeOf(Clipboard)).call(this, quill, options));

        _this.quill.root.addEventListener('paste', _this.onPaste.bind(_this));
        _this.container = _this.quill.addContainer('ql-clipboard');
        _this.container.setAttribute('contenteditable', true);
        _this.container.setAttribute('tabindex', -1);
        _this.matchers = [];
        CLIPBOARD_CONFIG.concat(_this.options.matchers).forEach(function (_ref) {
          var _ref2 = _slicedToArray(_ref, 2),
              selector = _ref2[0],
              matcher = _ref2[1];

          if (!options.matchVisual && matcher === matchSpacing) return;
          _this.addMatcher(selector, matcher);
        });
        return _this;
      }

      _createClass(Clipboard, [{
        key: 'addMatcher',
        value: function addMatcher(selector, matcher) {
          this.matchers.push([selector, matcher]);
        }
      }, {
        key: 'convert',
        value: function convert(html) {
          if (typeof html === 'string') {
            this.container.innerHTML = html.replace(/\>\r?\n +\</g, '><'); // Remove spaces between tags
            return this.convert();
          }
          var formats = this.quill.getFormat(this.quill.selection.savedRange.index);
          if (formats[_code2.default.blotName]) {
            var text = this.container.innerText;
            this.container.innerHTML = '';
            return new _quillDelta2.default().insert(text, _defineProperty({}, _code2.default.blotName, formats[_code2.default.blotName]));
          }

          var _prepareMatching = this.prepareMatching(),
              _prepareMatching2 = _slicedToArray(_prepareMatching, 2),
              elementMatchers = _prepareMatching2[0],
              textMatchers = _prepareMatching2[1];

          var delta = traverse(this.container, elementMatchers, textMatchers);
          // Remove trailing newline
          if (deltaEndsWith(delta, '\n') && delta.ops[delta.ops.length - 1].attributes == null) {
            delta = delta.compose(new _quillDelta2.default().retain(delta.length() - 1).delete(1));
          }
          debug.log('convert', this.container.innerHTML, delta);
          this.container.innerHTML = '';
          return delta;
        }
      }, {
        key: 'dangerouslyPasteHTML',
        value: function dangerouslyPasteHTML(index, html) {
          var source = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _quill2.default.sources.API;

          if (typeof index === 'string') {
            this.quill.setContents(this.convert(index), html);
            this.quill.setSelection(0, _quill2.default.sources.SILENT);
          } else {
            var paste = this.convert(html);
            this.quill.updateContents(new _quillDelta2.default().retain(index).concat(paste), source);
            this.quill.setSelection(index + paste.length(), _quill2.default.sources.SILENT);
          }
        }
      }, {
        key: 'onPaste',
        value: function onPaste(e) {
          var _this2 = this;

          if (e.defaultPrevented || !this.quill.isEnabled()) return;
          var range = this.quill.getSelection();
          var delta = new _quillDelta2.default().retain(range.index);
          var scrollTop = this.quill.scrollingContainer.scrollTop;
          this.container.focus();
          this.quill.selection.update(_quill2.default.sources.SILENT);
          setTimeout(function () {
            delta = delta.concat(_this2.convert()).delete(range.length);
            _this2.quill.updateContents(delta, _quill2.default.sources.USER);
            // range.length contributes to delta.length()
            _this2.quill.setSelection(delta.length() - range.length, _quill2.default.sources.SILENT);
            _this2.quill.scrollingContainer.scrollTop = scrollTop;
            _this2.quill.focus();
          }, 1);
        }
      }, {
        key: 'prepareMatching',
        value: function prepareMatching() {
          var _this3 = this;

          var elementMatchers = [],
              textMatchers = [];
          this.matchers.forEach(function (pair) {
            var _pair = _slicedToArray(pair, 2),
                selector = _pair[0],
                matcher = _pair[1];

            switch (selector) {
              case Node.TEXT_NODE:
                textMatchers.push(matcher);
                break;
              case Node.ELEMENT_NODE:
                elementMatchers.push(matcher);
                break;
              default:
                [].forEach.call(_this3.container.querySelectorAll(selector), function (node) {
                  // TODO use weakmap
                  node[DOM_KEY] = node[DOM_KEY] || [];
                  node[DOM_KEY].push(matcher);
                });
                break;
            }
          });
          return [elementMatchers, textMatchers];
        }
      }]);

      return Clipboard;
    }(_module2.default);

    Clipboard.DEFAULTS = {
      matchers: [],
      matchVisual: true
    };

    function applyFormat(delta, format, value) {
      if ((typeof format === 'undefined' ? 'undefined' : _typeof(format)) === 'object') {
        return Object.keys(format).reduce(function (delta, key) {
          return applyFormat(delta, key, format[key]);
        }, delta);
      } else {
        return delta.reduce(function (delta, op) {
          if (op.attributes && op.attributes[format]) {
            return delta.push(op);
          } else {
            return delta.insert(op.insert, (0, _extend3.default)({}, _defineProperty({}, format, value), op.attributes));
          }
        }, new _quillDelta2.default());
      }
    }

    function computeStyle(node) {
      if (node.nodeType !== Node.ELEMENT_NODE) return {};
      var DOM_KEY = '__ql-computed-style';
      return node[DOM_KEY] || (node[DOM_KEY] = window.getComputedStyle(node));
    }

    function deltaEndsWith(delta, text) {
      var endText = "";
      for (var i = delta.ops.length - 1; i >= 0 && endText.length < text.length; --i) {
        var op = delta.ops[i];
        if (typeof op.insert !== 'string') break;
        endText = op.insert + endText;
      }
      return endText.slice(-1 * text.length) === text;
    }

    function isLine(node) {
      if (node.childNodes.length === 0) return false; // Exclude embed blocks
      var style = computeStyle(node);
      return ['block', 'list-item'].indexOf(style.display) > -1;
    }

    function traverse(node, elementMatchers, textMatchers) {
      // Post-order
      if (node.nodeType === node.TEXT_NODE) {
        return textMatchers.reduce(function (delta, matcher) {
          return matcher(node, delta);
        }, new _quillDelta2.default());
      } else if (node.nodeType === node.ELEMENT_NODE) {
        return [].reduce.call(node.childNodes || [], function (delta, childNode) {
          var childrenDelta = traverse(childNode, elementMatchers, textMatchers);
          if (childNode.nodeType === node.ELEMENT_NODE) {
            childrenDelta = elementMatchers.reduce(function (childrenDelta, matcher) {
              return matcher(childNode, childrenDelta);
            }, childrenDelta);
            childrenDelta = (childNode[DOM_KEY] || []).reduce(function (childrenDelta, matcher) {
              return matcher(childNode, childrenDelta);
            }, childrenDelta);
          }
          return delta.concat(childrenDelta);
        }, new _quillDelta2.default());
      } else {
        return new _quillDelta2.default();
      }
    }

    function matchAlias(format, node, delta) {
      return applyFormat(delta, format, true);
    }

    function matchAttributor(node, delta) {
      var attributes = _parchment2.default.Attributor.Attribute.keys(node);
      var classes = _parchment2.default.Attributor.Class.keys(node);
      var styles = _parchment2.default.Attributor.Style.keys(node);
      var formats = {};
      attributes.concat(classes).concat(styles).forEach(function (name) {
        var attr = _parchment2.default.query(name, _parchment2.default.Scope.ATTRIBUTE);
        if (attr != null) {
          formats[attr.attrName] = attr.value(node);
          if (formats[attr.attrName]) return;
        }
        attr = ATTRIBUTE_ATTRIBUTORS[name];
        if (attr != null && (attr.attrName === name || attr.keyName === name)) {
          formats[attr.attrName] = attr.value(node) || undefined;
        }
        attr = STYLE_ATTRIBUTORS[name];
        if (attr != null && (attr.attrName === name || attr.keyName === name)) {
          attr = STYLE_ATTRIBUTORS[name];
          formats[attr.attrName] = attr.value(node) || undefined;
        }
      });
      if (Object.keys(formats).length > 0) {
        delta = applyFormat(delta, formats);
      }
      return delta;
    }

    function matchBlot(node, delta) {
      var match = _parchment2.default.query(node);
      if (match == null) return delta;
      if (match.prototype instanceof _parchment2.default.Embed) {
        var embed = {};
        var value = match.value(node);
        if (value != null) {
          embed[match.blotName] = value;
          delta = new _quillDelta2.default().insert(embed, match.formats(node));
        }
      } else if (typeof match.formats === 'function') {
        delta = applyFormat(delta, match.blotName, match.formats(node));
      }
      return delta;
    }

    function matchBreak(node, delta) {
      if (!deltaEndsWith(delta, '\n')) {
        delta.insert('\n');
      }
      return delta;
    }

    function matchIgnore() {
      return new _quillDelta2.default();
    }

    function matchIndent(node, delta) {
      var match = _parchment2.default.query(node);
      if (match == null || match.blotName !== 'list-item' || !deltaEndsWith(delta, '\n')) {
        return delta;
      }
      var indent = -1,
          parent = node.parentNode;
      while (!parent.classList.contains('ql-clipboard')) {
        if ((_parchment2.default.query(parent) || {}).blotName === 'list') {
          indent += 1;
        }
        parent = parent.parentNode;
      }
      if (indent <= 0) return delta;
      return delta.compose(new _quillDelta2.default().retain(delta.length() - 1).retain(1, { indent: indent }));
    }

    function matchNewline(node, delta) {
      if (!deltaEndsWith(delta, '\n')) {
        if (isLine(node) || delta.length() > 0 && node.nextSibling && isLine(node.nextSibling)) {
          delta.insert('\n');
        }
      }
      return delta;
    }

    function matchSpacing(node, delta) {
      if (isLine(node) && node.nextElementSibling != null && !deltaEndsWith(delta, '\n\n')) {
        var nodeHeight = node.offsetHeight + parseFloat(computeStyle(node).marginTop) + parseFloat(computeStyle(node).marginBottom);
        if (node.nextElementSibling.offsetTop > node.offsetTop + nodeHeight * 1.5) {
          delta.insert('\n');
        }
      }
      return delta;
    }

    function matchStyles(node, delta) {
      var formats = {};
      var style = node.style || {};
      if (style.fontStyle && computeStyle(node).fontStyle === 'italic') {
        formats.italic = true;
      }
      if (style.fontWeight && (computeStyle(node).fontWeight.startsWith('bold') || parseInt(computeStyle(node).fontWeight) >= 700)) {
        formats.bold = true;
      }
      if (Object.keys(formats).length > 0) {
        delta = applyFormat(delta, formats);
      }
      if (parseFloat(style.textIndent || 0) > 0) {
        // Could be 0.5in
        delta = new _quillDelta2.default().insert('\t').concat(delta);
      }
      return delta;
    }

    function matchText(node, delta) {
      var text = node.data;
      // Word represents empty line with <o:p>&nbsp;</o:p>
      if (node.parentNode.tagName === 'O:P') {
        return delta.insert(text.trim());
      }
      if (text.trim().length === 0 && node.parentNode.classList.contains('ql-clipboard')) {
        return delta;
      }
      if (!computeStyle(node.parentNode).whiteSpace.startsWith('pre')) {
        // eslint-disable-next-line func-style
        var replacer = function replacer(collapse, match) {
          match = match.replace(/[^\u00a0]/g, ''); // \u00a0 is nbsp;
          return match.length < 1 && collapse ? ' ' : match;
        };
        text = text.replace(/\r\n/g, ' ').replace(/\n/g, ' ');
        text = text.replace(/\s\s+/g, replacer.bind(replacer, true)); // collapse whitespace
        if (node.previousSibling == null && isLine(node.parentNode) || node.previousSibling != null && isLine(node.previousSibling)) {
          text = text.replace(/^\s+/, replacer.bind(replacer, false));
        }
        if (node.nextSibling == null && isLine(node.parentNode) || node.nextSibling != null && isLine(node.nextSibling)) {
          text = text.replace(/\s+$/, replacer.bind(replacer, false));
        }
      }
      return delta.insert(text);
    }

    exports.default = Clipboard;
    exports.matchAttributor = matchAttributor;
    exports.matchBlot = matchBlot;
    exports.matchNewline = matchNewline;
    exports.matchSpacing = matchSpacing;
    exports.matchText = matchText;

    /***/ }),
    /* 56 */
    /***/ (function(module, exports, __webpack_require__) {


    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

    var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

    var _inline = __webpack_require__(6);

    var _inline2 = _interopRequireDefault(_inline);

    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    var Bold = function (_Inline) {
      _inherits(Bold, _Inline);

      function Bold() {
        _classCallCheck(this, Bold);

        return _possibleConstructorReturn(this, (Bold.__proto__ || Object.getPrototypeOf(Bold)).apply(this, arguments));
      }

      _createClass(Bold, [{
        key: 'optimize',
        value: function optimize(context) {
          _get(Bold.prototype.__proto__ || Object.getPrototypeOf(Bold.prototype), 'optimize', this).call(this, context);
          if (this.domNode.tagName !== this.statics.tagName[0]) {
            this.replaceWith(this.statics.blotName);
          }
        }
      }], [{
        key: 'create',
        value: function create() {
          return _get(Bold.__proto__ || Object.getPrototypeOf(Bold), 'create', this).call(this);
        }
      }, {
        key: 'formats',
        value: function formats() {
          return true;
        }
      }]);

      return Bold;
    }(_inline2.default);

    Bold.blotName = 'bold';
    Bold.tagName = ['STRONG', 'B'];

    exports.default = Bold;

    /***/ }),
    /* 57 */
    /***/ (function(module, exports, __webpack_require__) {


    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.addControls = exports.default = undefined;

    var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

    var _quillDelta = __webpack_require__(2);

    var _quillDelta2 = _interopRequireDefault(_quillDelta);

    var _parchment = __webpack_require__(0);

    var _parchment2 = _interopRequireDefault(_parchment);

    var _quill = __webpack_require__(5);

    var _quill2 = _interopRequireDefault(_quill);

    var _logger = __webpack_require__(10);

    var _logger2 = _interopRequireDefault(_logger);

    var _module = __webpack_require__(9);

    var _module2 = _interopRequireDefault(_module);

    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    var debug = (0, _logger2.default)('quill:toolbar');

    var Toolbar = function (_Module) {
      _inherits(Toolbar, _Module);

      function Toolbar(quill, options) {
        _classCallCheck(this, Toolbar);

        var _this = _possibleConstructorReturn(this, (Toolbar.__proto__ || Object.getPrototypeOf(Toolbar)).call(this, quill, options));

        if (Array.isArray(_this.options.container)) {
          var container = document.createElement('div');
          addControls(container, _this.options.container);
          quill.container.parentNode.insertBefore(container, quill.container);
          _this.container = container;
        } else if (typeof _this.options.container === 'string') {
          _this.container = document.querySelector(_this.options.container);
        } else {
          _this.container = _this.options.container;
        }
        if (!(_this.container instanceof HTMLElement)) {
          var _ret;

          return _ret = debug.error('Container required for toolbar', _this.options), _possibleConstructorReturn(_this, _ret);
        }
        _this.container.classList.add('ql-toolbar');
        _this.controls = [];
        _this.handlers = {};
        Object.keys(_this.options.handlers).forEach(function (format) {
          _this.addHandler(format, _this.options.handlers[format]);
        });
        [].forEach.call(_this.container.querySelectorAll('button, select'), function (input) {
          _this.attach(input);
        });
        _this.quill.on(_quill2.default.events.EDITOR_CHANGE, function (type, range) {
          if (type === _quill2.default.events.SELECTION_CHANGE) {
            _this.update(range);
          }
        });
        _this.quill.on(_quill2.default.events.SCROLL_OPTIMIZE, function () {
          var _this$quill$selection = _this.quill.selection.getRange(),
              _this$quill$selection2 = _slicedToArray(_this$quill$selection, 1),
              range = _this$quill$selection2[0]; // quill.getSelection triggers update


          _this.update(range);
        });
        return _this;
      }

      _createClass(Toolbar, [{
        key: 'addHandler',
        value: function addHandler(format, handler) {
          this.handlers[format] = handler;
        }
      }, {
        key: 'attach',
        value: function attach(input) {
          var _this2 = this;

          var format = [].find.call(input.classList, function (className) {
            return className.indexOf('ql-') === 0;
          });
          if (!format) return;
          format = format.slice('ql-'.length);
          if (input.tagName === 'BUTTON') {
            input.setAttribute('type', 'button');
          }
          if (this.handlers[format] == null) {
            if (this.quill.scroll.whitelist != null && this.quill.scroll.whitelist[format] == null) {
              debug.warn('ignoring attaching to disabled format', format, input);
              return;
            }
            if (_parchment2.default.query(format) == null) {
              debug.warn('ignoring attaching to nonexistent format', format, input);
              return;
            }
          }
          var eventName = input.tagName === 'SELECT' ? 'change' : 'click';
          input.addEventListener(eventName, function (e) {
            var value = void 0;
            if (input.tagName === 'SELECT') {
              if (input.selectedIndex < 0) return;
              var selected = input.options[input.selectedIndex];
              if (selected.hasAttribute('selected')) {
                value = false;
              } else {
                value = selected.value || false;
              }
            } else {
              if (input.classList.contains('ql-active')) {
                value = false;
              } else {
                value = input.value || !input.hasAttribute('value');
              }
              e.preventDefault();
            }
            _this2.quill.focus();

            var _quill$selection$getR = _this2.quill.selection.getRange(),
                _quill$selection$getR2 = _slicedToArray(_quill$selection$getR, 1),
                range = _quill$selection$getR2[0];

            if (_this2.handlers[format] != null) {
              _this2.handlers[format].call(_this2, value);
            } else if (_parchment2.default.query(format).prototype instanceof _parchment2.default.Embed) {
              value = prompt('Enter ' + format);
              if (!value) return;
              _this2.quill.updateContents(new _quillDelta2.default().retain(range.index).delete(range.length).insert(_defineProperty({}, format, value)), _quill2.default.sources.USER);
            } else {
              _this2.quill.format(format, value, _quill2.default.sources.USER);
            }
            _this2.update(range);
          });
          // TODO use weakmap
          this.controls.push([format, input]);
        }
      }, {
        key: 'update',
        value: function update(range) {
          var formats = range == null ? {} : this.quill.getFormat(range);
          this.controls.forEach(function (pair) {
            var _pair = _slicedToArray(pair, 2),
                format = _pair[0],
                input = _pair[1];

            if (input.tagName === 'SELECT') {
              var option = void 0;
              if (range == null) {
                option = null;
              } else if (formats[format] == null) {
                option = input.querySelector('option[selected]');
              } else if (!Array.isArray(formats[format])) {
                var value = formats[format];
                if (typeof value === 'string') {
                  value = value.replace(/\"/g, '\\"');
                }
                option = input.querySelector('option[value="' + value + '"]');
              }
              if (option == null) {
                input.value = ''; // TODO make configurable?
                input.selectedIndex = -1;
              } else {
                option.selected = true;
              }
            } else {
              if (range == null) {
                input.classList.remove('ql-active');
              } else if (input.hasAttribute('value')) {
                // both being null should match (default values)
                // '1' should match with 1 (headers)
                var isActive = formats[format] === input.getAttribute('value') || formats[format] != null && formats[format].toString() === input.getAttribute('value') || formats[format] == null && !input.getAttribute('value');
                input.classList.toggle('ql-active', isActive);
              } else {
                input.classList.toggle('ql-active', formats[format] != null);
              }
            }
          });
        }
      }]);

      return Toolbar;
    }(_module2.default);

    Toolbar.DEFAULTS = {};

    function addButton(container, format, value) {
      var input = document.createElement('button');
      input.setAttribute('type', 'button');
      input.classList.add('ql-' + format);
      if (value != null) {
        input.value = value;
      }
      container.appendChild(input);
    }

    function addControls(container, groups) {
      if (!Array.isArray(groups[0])) {
        groups = [groups];
      }
      groups.forEach(function (controls) {
        var group = document.createElement('span');
        group.classList.add('ql-formats');
        controls.forEach(function (control) {
          if (typeof control === 'string') {
            addButton(group, control);
          } else {
            var format = Object.keys(control)[0];
            var value = control[format];
            if (Array.isArray(value)) {
              addSelect(group, format, value);
            } else {
              addButton(group, format, value);
            }
          }
        });
        container.appendChild(group);
      });
    }

    function addSelect(container, format, values) {
      var input = document.createElement('select');
      input.classList.add('ql-' + format);
      values.forEach(function (value) {
        var option = document.createElement('option');
        if (value !== false) {
          option.setAttribute('value', value);
        } else {
          option.setAttribute('selected', 'selected');
        }
        input.appendChild(option);
      });
      container.appendChild(input);
    }

    Toolbar.DEFAULTS = {
      container: null,
      handlers: {
        clean: function clean() {
          var _this3 = this;

          var range = this.quill.getSelection();
          if (range == null) return;
          if (range.length == 0) {
            var formats = this.quill.getFormat();
            Object.keys(formats).forEach(function (name) {
              // Clean functionality in existing apps only clean inline formats
              if (_parchment2.default.query(name, _parchment2.default.Scope.INLINE) != null) {
                _this3.quill.format(name, false);
              }
            });
          } else {
            this.quill.removeFormat(range, _quill2.default.sources.USER);
          }
        },
        direction: function direction(value) {
          var align = this.quill.getFormat()['align'];
          if (value === 'rtl' && align == null) {
            this.quill.format('align', 'right', _quill2.default.sources.USER);
          } else if (!value && align === 'right') {
            this.quill.format('align', false, _quill2.default.sources.USER);
          }
          this.quill.format('direction', value, _quill2.default.sources.USER);
        },
        indent: function indent(value) {
          var range = this.quill.getSelection();
          var formats = this.quill.getFormat(range);
          var indent = parseInt(formats.indent || 0);
          if (value === '+1' || value === '-1') {
            var modifier = value === '+1' ? 1 : -1;
            if (formats.direction === 'rtl') modifier *= -1;
            this.quill.format('indent', indent + modifier, _quill2.default.sources.USER);
          }
        },
        link: function link(value) {
          if (value === true) {
            value = prompt('Enter link URL:');
          }
          this.quill.format('link', value, _quill2.default.sources.USER);
        },
        list: function list(value) {
          var range = this.quill.getSelection();
          var formats = this.quill.getFormat(range);
          if (value === 'check') {
            if (formats['list'] === 'checked' || formats['list'] === 'unchecked') {
              this.quill.format('list', false, _quill2.default.sources.USER);
            } else {
              this.quill.format('list', 'unchecked', _quill2.default.sources.USER);
            }
          } else {
            this.quill.format('list', value, _quill2.default.sources.USER);
          }
        }
      }
    };

    exports.default = Toolbar;
    exports.addControls = addControls;

    /***/ }),
    /* 58 */
    /***/ (function(module, exports) {

    module.exports = "<svg viewbox=\"0 0 18 18\"> <polyline class=\"ql-even ql-stroke\" points=\"5 7 3 9 5 11\"></polyline> <polyline class=\"ql-even ql-stroke\" points=\"13 7 15 9 13 11\"></polyline> <line class=ql-stroke x1=10 x2=8 y1=5 y2=13></line> </svg>";

    /***/ }),
    /* 59 */
    /***/ (function(module, exports, __webpack_require__) {


    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

    var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

    var _picker = __webpack_require__(28);

    var _picker2 = _interopRequireDefault(_picker);

    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    var ColorPicker = function (_Picker) {
      _inherits(ColorPicker, _Picker);

      function ColorPicker(select, label) {
        _classCallCheck(this, ColorPicker);

        var _this = _possibleConstructorReturn(this, (ColorPicker.__proto__ || Object.getPrototypeOf(ColorPicker)).call(this, select));

        _this.label.innerHTML = label;
        _this.container.classList.add('ql-color-picker');
        [].slice.call(_this.container.querySelectorAll('.ql-picker-item'), 0, 7).forEach(function (item) {
          item.classList.add('ql-primary');
        });
        return _this;
      }

      _createClass(ColorPicker, [{
        key: 'buildItem',
        value: function buildItem(option) {
          var item = _get(ColorPicker.prototype.__proto__ || Object.getPrototypeOf(ColorPicker.prototype), 'buildItem', this).call(this, option);
          item.style.backgroundColor = option.getAttribute('value') || '';
          return item;
        }
      }, {
        key: 'selectItem',
        value: function selectItem(item, trigger) {
          _get(ColorPicker.prototype.__proto__ || Object.getPrototypeOf(ColorPicker.prototype), 'selectItem', this).call(this, item, trigger);
          var colorLabel = this.label.querySelector('.ql-color-label');
          var value = item ? item.getAttribute('data-value') || '' : '';
          if (colorLabel) {
            if (colorLabel.tagName === 'line') {
              colorLabel.style.stroke = value;
            } else {
              colorLabel.style.fill = value;
            }
          }
        }
      }]);

      return ColorPicker;
    }(_picker2.default);

    exports.default = ColorPicker;

    /***/ }),
    /* 60 */
    /***/ (function(module, exports, __webpack_require__) {


    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

    var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

    var _picker = __webpack_require__(28);

    var _picker2 = _interopRequireDefault(_picker);

    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    var IconPicker = function (_Picker) {
      _inherits(IconPicker, _Picker);

      function IconPicker(select, icons) {
        _classCallCheck(this, IconPicker);

        var _this = _possibleConstructorReturn(this, (IconPicker.__proto__ || Object.getPrototypeOf(IconPicker)).call(this, select));

        _this.container.classList.add('ql-icon-picker');
        [].forEach.call(_this.container.querySelectorAll('.ql-picker-item'), function (item) {
          item.innerHTML = icons[item.getAttribute('data-value') || ''];
        });
        _this.defaultItem = _this.container.querySelector('.ql-selected');
        _this.selectItem(_this.defaultItem);
        return _this;
      }

      _createClass(IconPicker, [{
        key: 'selectItem',
        value: function selectItem(item, trigger) {
          _get(IconPicker.prototype.__proto__ || Object.getPrototypeOf(IconPicker.prototype), 'selectItem', this).call(this, item, trigger);
          item = item || this.defaultItem;
          this.label.innerHTML = item.innerHTML;
        }
      }]);

      return IconPicker;
    }(_picker2.default);

    exports.default = IconPicker;

    /***/ }),
    /* 61 */
    /***/ (function(module, exports, __webpack_require__) {


    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    var Tooltip = function () {
      function Tooltip(quill, boundsContainer) {
        var _this = this;

        _classCallCheck(this, Tooltip);

        this.quill = quill;
        this.boundsContainer = boundsContainer || document.body;
        this.root = quill.addContainer('ql-tooltip');
        this.root.innerHTML = this.constructor.TEMPLATE;
        if (this.quill.root === this.quill.scrollingContainer) {
          this.quill.root.addEventListener('scroll', function () {
            _this.root.style.marginTop = -1 * _this.quill.root.scrollTop + 'px';
          });
        }
        this.hide();
      }

      _createClass(Tooltip, [{
        key: 'hide',
        value: function hide() {
          this.root.classList.add('ql-hidden');
        }
      }, {
        key: 'position',
        value: function position(reference) {
          var left = reference.left + reference.width / 2 - this.root.offsetWidth / 2;
          // root.scrollTop should be 0 if scrollContainer !== root
          var top = reference.bottom + this.quill.root.scrollTop;
          this.root.style.left = left + 'px';
          this.root.style.top = top + 'px';
          this.root.classList.remove('ql-flip');
          var containerBounds = this.boundsContainer.getBoundingClientRect();
          var rootBounds = this.root.getBoundingClientRect();
          var shift = 0;
          if (rootBounds.right > containerBounds.right) {
            shift = containerBounds.right - rootBounds.right;
            this.root.style.left = left + shift + 'px';
          }
          if (rootBounds.left < containerBounds.left) {
            shift = containerBounds.left - rootBounds.left;
            this.root.style.left = left + shift + 'px';
          }
          if (rootBounds.bottom > containerBounds.bottom) {
            var height = rootBounds.bottom - rootBounds.top;
            var verticalShift = reference.bottom - reference.top + height;
            this.root.style.top = top - verticalShift + 'px';
            this.root.classList.add('ql-flip');
          }
          return shift;
        }
      }, {
        key: 'show',
        value: function show() {
          this.root.classList.remove('ql-editing');
          this.root.classList.remove('ql-hidden');
        }
      }]);

      return Tooltip;
    }();

    exports.default = Tooltip;

    /***/ }),
    /* 62 */
    /***/ (function(module, exports, __webpack_require__) {


    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

    var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

    var _extend = __webpack_require__(3);

    var _extend2 = _interopRequireDefault(_extend);

    var _emitter = __webpack_require__(8);

    var _emitter2 = _interopRequireDefault(_emitter);

    var _base = __webpack_require__(43);

    var _base2 = _interopRequireDefault(_base);

    var _link = __webpack_require__(27);

    var _link2 = _interopRequireDefault(_link);

    var _selection = __webpack_require__(15);

    var _icons = __webpack_require__(41);

    var _icons2 = _interopRequireDefault(_icons);

    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    var TOOLBAR_CONFIG = [[{ header: ['1', '2', '3', false] }], ['bold', 'italic', 'underline', 'link'], [{ list: 'ordered' }, { list: 'bullet' }], ['clean']];

    var SnowTheme = function (_BaseTheme) {
      _inherits(SnowTheme, _BaseTheme);

      function SnowTheme(quill, options) {
        _classCallCheck(this, SnowTheme);

        if (options.modules.toolbar != null && options.modules.toolbar.container == null) {
          options.modules.toolbar.container = TOOLBAR_CONFIG;
        }

        var _this = _possibleConstructorReturn(this, (SnowTheme.__proto__ || Object.getPrototypeOf(SnowTheme)).call(this, quill, options));

        _this.quill.container.classList.add('ql-snow');
        return _this;
      }

      _createClass(SnowTheme, [{
        key: 'extendToolbar',
        value: function extendToolbar(toolbar) {
          toolbar.container.classList.add('ql-snow');
          this.buildButtons([].slice.call(toolbar.container.querySelectorAll('button')), _icons2.default);
          this.buildPickers([].slice.call(toolbar.container.querySelectorAll('select')), _icons2.default);
          this.tooltip = new SnowTooltip(this.quill, this.options.bounds);
          if (toolbar.container.querySelector('.ql-link')) {
            this.quill.keyboard.addBinding({ key: 'K', shortKey: true }, function (range, context) {
              toolbar.handlers['link'].call(toolbar, !context.format.link);
            });
          }
        }
      }]);

      return SnowTheme;
    }(_base2.default);

    SnowTheme.DEFAULTS = (0, _extend2.default)(true, {}, _base2.default.DEFAULTS, {
      modules: {
        toolbar: {
          handlers: {
            link: function link(value) {
              if (value) {
                var range = this.quill.getSelection();
                if (range == null || range.length == 0) return;
                var preview = this.quill.getText(range);
                if (/^\S+@\S+\.\S+$/.test(preview) && preview.indexOf('mailto:') !== 0) {
                  preview = 'mailto:' + preview;
                }
                var tooltip = this.quill.theme.tooltip;
                tooltip.edit('link', preview);
              } else {
                this.quill.format('link', false);
              }
            }
          }
        }
      }
    });

    var SnowTooltip = function (_BaseTooltip) {
      _inherits(SnowTooltip, _BaseTooltip);

      function SnowTooltip(quill, bounds) {
        _classCallCheck(this, SnowTooltip);

        var _this2 = _possibleConstructorReturn(this, (SnowTooltip.__proto__ || Object.getPrototypeOf(SnowTooltip)).call(this, quill, bounds));

        _this2.preview = _this2.root.querySelector('a.ql-preview');
        return _this2;
      }

      _createClass(SnowTooltip, [{
        key: 'listen',
        value: function listen() {
          var _this3 = this;

          _get(SnowTooltip.prototype.__proto__ || Object.getPrototypeOf(SnowTooltip.prototype), 'listen', this).call(this);
          this.root.querySelector('a.ql-action').addEventListener('click', function (event) {
            if (_this3.root.classList.contains('ql-editing')) {
              _this3.save();
            } else {
              _this3.edit('link', _this3.preview.textContent);
            }
            event.preventDefault();
          });
          this.root.querySelector('a.ql-remove').addEventListener('click', function (event) {
            if (_this3.linkRange != null) {
              var range = _this3.linkRange;
              _this3.restoreFocus();
              _this3.quill.formatText(range, 'link', false, _emitter2.default.sources.USER);
              delete _this3.linkRange;
            }
            event.preventDefault();
            _this3.hide();
          });
          this.quill.on(_emitter2.default.events.SELECTION_CHANGE, function (range, oldRange, source) {
            if (range == null) return;
            if (range.length === 0 && source === _emitter2.default.sources.USER) {
              var _quill$scroll$descend = _this3.quill.scroll.descendant(_link2.default, range.index),
                  _quill$scroll$descend2 = _slicedToArray(_quill$scroll$descend, 2),
                  link = _quill$scroll$descend2[0],
                  offset = _quill$scroll$descend2[1];

              if (link != null) {
                _this3.linkRange = new _selection.Range(range.index - offset, link.length());
                var preview = _link2.default.formats(link.domNode);
                _this3.preview.textContent = preview;
                _this3.preview.setAttribute('href', preview);
                _this3.show();
                _this3.position(_this3.quill.getBounds(_this3.linkRange));
                return;
              }
            } else {
              delete _this3.linkRange;
            }
            _this3.hide();
          });
        }
      }, {
        key: 'show',
        value: function show() {
          _get(SnowTooltip.prototype.__proto__ || Object.getPrototypeOf(SnowTooltip.prototype), 'show', this).call(this);
          this.root.removeAttribute('data-mode');
        }
      }]);

      return SnowTooltip;
    }(_base.BaseTooltip);

    SnowTooltip.TEMPLATE = ['<a class="ql-preview" rel="noopener noreferrer" target="_blank" href="about:blank"></a>', '<input type="text" data-formula="e=mc^2" data-link="https://quilljs.com" data-video="Embed URL">', '<a class="ql-action"></a>', '<a class="ql-remove"></a>'].join('');

    exports.default = SnowTheme;

    /***/ }),
    /* 63 */
    /***/ (function(module, exports, __webpack_require__) {


    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    var _core = __webpack_require__(29);

    var _core2 = _interopRequireDefault(_core);

    var _align = __webpack_require__(36);

    var _direction = __webpack_require__(38);

    var _indent = __webpack_require__(64);

    var _blockquote = __webpack_require__(65);

    var _blockquote2 = _interopRequireDefault(_blockquote);

    var _header = __webpack_require__(66);

    var _header2 = _interopRequireDefault(_header);

    var _list = __webpack_require__(67);

    var _list2 = _interopRequireDefault(_list);

    var _background = __webpack_require__(37);

    var _color = __webpack_require__(26);

    var _font = __webpack_require__(39);

    var _size = __webpack_require__(40);

    var _bold = __webpack_require__(56);

    var _bold2 = _interopRequireDefault(_bold);

    var _italic = __webpack_require__(68);

    var _italic2 = _interopRequireDefault(_italic);

    var _link = __webpack_require__(27);

    var _link2 = _interopRequireDefault(_link);

    var _script = __webpack_require__(69);

    var _script2 = _interopRequireDefault(_script);

    var _strike = __webpack_require__(70);

    var _strike2 = _interopRequireDefault(_strike);

    var _underline = __webpack_require__(71);

    var _underline2 = _interopRequireDefault(_underline);

    var _image = __webpack_require__(72);

    var _image2 = _interopRequireDefault(_image);

    var _video = __webpack_require__(73);

    var _video2 = _interopRequireDefault(_video);

    var _code = __webpack_require__(13);

    var _code2 = _interopRequireDefault(_code);

    var _formula = __webpack_require__(74);

    var _formula2 = _interopRequireDefault(_formula);

    var _syntax = __webpack_require__(75);

    var _syntax2 = _interopRequireDefault(_syntax);

    var _toolbar = __webpack_require__(57);

    var _toolbar2 = _interopRequireDefault(_toolbar);

    var _icons = __webpack_require__(41);

    var _icons2 = _interopRequireDefault(_icons);

    var _picker = __webpack_require__(28);

    var _picker2 = _interopRequireDefault(_picker);

    var _colorPicker = __webpack_require__(59);

    var _colorPicker2 = _interopRequireDefault(_colorPicker);

    var _iconPicker = __webpack_require__(60);

    var _iconPicker2 = _interopRequireDefault(_iconPicker);

    var _tooltip = __webpack_require__(61);

    var _tooltip2 = _interopRequireDefault(_tooltip);

    var _bubble = __webpack_require__(108);

    var _bubble2 = _interopRequireDefault(_bubble);

    var _snow = __webpack_require__(62);

    var _snow2 = _interopRequireDefault(_snow);

    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    _core2.default.register({
      'attributors/attribute/direction': _direction.DirectionAttribute,

      'attributors/class/align': _align.AlignClass,
      'attributors/class/background': _background.BackgroundClass,
      'attributors/class/color': _color.ColorClass,
      'attributors/class/direction': _direction.DirectionClass,
      'attributors/class/font': _font.FontClass,
      'attributors/class/size': _size.SizeClass,

      'attributors/style/align': _align.AlignStyle,
      'attributors/style/background': _background.BackgroundStyle,
      'attributors/style/color': _color.ColorStyle,
      'attributors/style/direction': _direction.DirectionStyle,
      'attributors/style/font': _font.FontStyle,
      'attributors/style/size': _size.SizeStyle
    }, true);

    _core2.default.register({
      'formats/align': _align.AlignClass,
      'formats/direction': _direction.DirectionClass,
      'formats/indent': _indent.IndentClass,

      'formats/background': _background.BackgroundStyle,
      'formats/color': _color.ColorStyle,
      'formats/font': _font.FontClass,
      'formats/size': _size.SizeClass,

      'formats/blockquote': _blockquote2.default,
      'formats/code-block': _code2.default,
      'formats/header': _header2.default,
      'formats/list': _list2.default,

      'formats/bold': _bold2.default,
      'formats/code': _code.Code,
      'formats/italic': _italic2.default,
      'formats/link': _link2.default,
      'formats/script': _script2.default,
      'formats/strike': _strike2.default,
      'formats/underline': _underline2.default,

      'formats/image': _image2.default,
      'formats/video': _video2.default,

      'formats/list/item': _list.ListItem,

      'modules/formula': _formula2.default,
      'modules/syntax': _syntax2.default,
      'modules/toolbar': _toolbar2.default,

      'themes/bubble': _bubble2.default,
      'themes/snow': _snow2.default,

      'ui/icons': _icons2.default,
      'ui/picker': _picker2.default,
      'ui/icon-picker': _iconPicker2.default,
      'ui/color-picker': _colorPicker2.default,
      'ui/tooltip': _tooltip2.default
    }, true);

    exports.default = _core2.default;

    /***/ }),
    /* 64 */
    /***/ (function(module, exports, __webpack_require__) {


    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.IndentClass = undefined;

    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

    var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

    var _parchment = __webpack_require__(0);

    var _parchment2 = _interopRequireDefault(_parchment);

    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    var IdentAttributor = function (_Parchment$Attributor) {
      _inherits(IdentAttributor, _Parchment$Attributor);

      function IdentAttributor() {
        _classCallCheck(this, IdentAttributor);

        return _possibleConstructorReturn(this, (IdentAttributor.__proto__ || Object.getPrototypeOf(IdentAttributor)).apply(this, arguments));
      }

      _createClass(IdentAttributor, [{
        key: 'add',
        value: function add(node, value) {
          if (value === '+1' || value === '-1') {
            var indent = this.value(node) || 0;
            value = value === '+1' ? indent + 1 : indent - 1;
          }
          if (value === 0) {
            this.remove(node);
            return true;
          } else {
            return _get(IdentAttributor.prototype.__proto__ || Object.getPrototypeOf(IdentAttributor.prototype), 'add', this).call(this, node, value);
          }
        }
      }, {
        key: 'canAdd',
        value: function canAdd(node, value) {
          return _get(IdentAttributor.prototype.__proto__ || Object.getPrototypeOf(IdentAttributor.prototype), 'canAdd', this).call(this, node, value) || _get(IdentAttributor.prototype.__proto__ || Object.getPrototypeOf(IdentAttributor.prototype), 'canAdd', this).call(this, node, parseInt(value));
        }
      }, {
        key: 'value',
        value: function value(node) {
          return parseInt(_get(IdentAttributor.prototype.__proto__ || Object.getPrototypeOf(IdentAttributor.prototype), 'value', this).call(this, node)) || undefined; // Don't return NaN
        }
      }]);

      return IdentAttributor;
    }(_parchment2.default.Attributor.Class);

    var IndentClass = new IdentAttributor('indent', 'ql-indent', {
      scope: _parchment2.default.Scope.BLOCK,
      whitelist: [1, 2, 3, 4, 5, 6, 7, 8]
    });

    exports.IndentClass = IndentClass;

    /***/ }),
    /* 65 */
    /***/ (function(module, exports, __webpack_require__) {


    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    var _block = __webpack_require__(4);

    var _block2 = _interopRequireDefault(_block);

    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    var Blockquote = function (_Block) {
      _inherits(Blockquote, _Block);

      function Blockquote() {
        _classCallCheck(this, Blockquote);

        return _possibleConstructorReturn(this, (Blockquote.__proto__ || Object.getPrototypeOf(Blockquote)).apply(this, arguments));
      }

      return Blockquote;
    }(_block2.default);

    Blockquote.blotName = 'blockquote';
    Blockquote.tagName = 'blockquote';

    exports.default = Blockquote;

    /***/ }),
    /* 66 */
    /***/ (function(module, exports, __webpack_require__) {


    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

    var _block = __webpack_require__(4);

    var _block2 = _interopRequireDefault(_block);

    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    var Header = function (_Block) {
      _inherits(Header, _Block);

      function Header() {
        _classCallCheck(this, Header);

        return _possibleConstructorReturn(this, (Header.__proto__ || Object.getPrototypeOf(Header)).apply(this, arguments));
      }

      _createClass(Header, null, [{
        key: 'formats',
        value: function formats(domNode) {
          return this.tagName.indexOf(domNode.tagName) + 1;
        }
      }]);

      return Header;
    }(_block2.default);

    Header.blotName = 'header';
    Header.tagName = ['H1', 'H2', 'H3', 'H4', 'H5', 'H6'];

    exports.default = Header;

    /***/ }),
    /* 67 */
    /***/ (function(module, exports, __webpack_require__) {


    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = exports.ListItem = undefined;

    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

    var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

    var _parchment = __webpack_require__(0);

    var _parchment2 = _interopRequireDefault(_parchment);

    var _block = __webpack_require__(4);

    var _block2 = _interopRequireDefault(_block);

    var _container = __webpack_require__(25);

    var _container2 = _interopRequireDefault(_container);

    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    var ListItem = function (_Block) {
      _inherits(ListItem, _Block);

      function ListItem() {
        _classCallCheck(this, ListItem);

        return _possibleConstructorReturn(this, (ListItem.__proto__ || Object.getPrototypeOf(ListItem)).apply(this, arguments));
      }

      _createClass(ListItem, [{
        key: 'format',
        value: function format(name, value) {
          if (name === List.blotName && !value) {
            this.replaceWith(_parchment2.default.create(this.statics.scope));
          } else {
            _get(ListItem.prototype.__proto__ || Object.getPrototypeOf(ListItem.prototype), 'format', this).call(this, name, value);
          }
        }
      }, {
        key: 'remove',
        value: function remove() {
          if (this.prev == null && this.next == null) {
            this.parent.remove();
          } else {
            _get(ListItem.prototype.__proto__ || Object.getPrototypeOf(ListItem.prototype), 'remove', this).call(this);
          }
        }
      }, {
        key: 'replaceWith',
        value: function replaceWith(name, value) {
          this.parent.isolate(this.offset(this.parent), this.length());
          if (name === this.parent.statics.blotName) {
            this.parent.replaceWith(name, value);
            return this;
          } else {
            this.parent.unwrap();
            return _get(ListItem.prototype.__proto__ || Object.getPrototypeOf(ListItem.prototype), 'replaceWith', this).call(this, name, value);
          }
        }
      }], [{
        key: 'formats',
        value: function formats(domNode) {
          return domNode.tagName === this.tagName ? undefined : _get(ListItem.__proto__ || Object.getPrototypeOf(ListItem), 'formats', this).call(this, domNode);
        }
      }]);

      return ListItem;
    }(_block2.default);

    ListItem.blotName = 'list-item';
    ListItem.tagName = 'LI';

    var List = function (_Container) {
      _inherits(List, _Container);

      _createClass(List, null, [{
        key: 'create',
        value: function create(value) {
          var tagName = value === 'ordered' ? 'OL' : 'UL';
          var node = _get(List.__proto__ || Object.getPrototypeOf(List), 'create', this).call(this, tagName);
          if (value === 'checked' || value === 'unchecked') {
            node.setAttribute('data-checked', value === 'checked');
          }
          return node;
        }
      }, {
        key: 'formats',
        value: function formats(domNode) {
          if (domNode.tagName === 'OL') return 'ordered';
          if (domNode.tagName === 'UL') {
            if (domNode.hasAttribute('data-checked')) {
              return domNode.getAttribute('data-checked') === 'true' ? 'checked' : 'unchecked';
            } else {
              return 'bullet';
            }
          }
          return undefined;
        }
      }]);

      function List(domNode) {
        _classCallCheck(this, List);

        var _this2 = _possibleConstructorReturn(this, (List.__proto__ || Object.getPrototypeOf(List)).call(this, domNode));

        var listEventHandler = function listEventHandler(e) {
          if (e.target.parentNode !== domNode) return;
          var format = _this2.statics.formats(domNode);
          var blot = _parchment2.default.find(e.target);
          if (format === 'checked') {
            blot.format('list', 'unchecked');
          } else if (format === 'unchecked') {
            blot.format('list', 'checked');
          }
        };

        domNode.addEventListener('touchstart', listEventHandler);
        domNode.addEventListener('mousedown', listEventHandler);
        return _this2;
      }

      _createClass(List, [{
        key: 'format',
        value: function format(name, value) {
          if (this.children.length > 0) {
            this.children.tail.format(name, value);
          }
        }
      }, {
        key: 'formats',
        value: function formats() {
          // We don't inherit from FormatBlot
          return _defineProperty({}, this.statics.blotName, this.statics.formats(this.domNode));
        }
      }, {
        key: 'insertBefore',
        value: function insertBefore(blot, ref) {
          if (blot instanceof ListItem) {
            _get(List.prototype.__proto__ || Object.getPrototypeOf(List.prototype), 'insertBefore', this).call(this, blot, ref);
          } else {
            var index = ref == null ? this.length() : ref.offset(this);
            var after = this.split(index);
            after.parent.insertBefore(blot, after);
          }
        }
      }, {
        key: 'optimize',
        value: function optimize(context) {
          _get(List.prototype.__proto__ || Object.getPrototypeOf(List.prototype), 'optimize', this).call(this, context);
          var next = this.next;
          if (next != null && next.prev === this && next.statics.blotName === this.statics.blotName && next.domNode.tagName === this.domNode.tagName && next.domNode.getAttribute('data-checked') === this.domNode.getAttribute('data-checked')) {
            next.moveChildren(this);
            next.remove();
          }
        }
      }, {
        key: 'replace',
        value: function replace(target) {
          if (target.statics.blotName !== this.statics.blotName) {
            var item = _parchment2.default.create(this.statics.defaultChild);
            target.moveChildren(item);
            this.appendChild(item);
          }
          _get(List.prototype.__proto__ || Object.getPrototypeOf(List.prototype), 'replace', this).call(this, target);
        }
      }]);

      return List;
    }(_container2.default);

    List.blotName = 'list';
    List.scope = _parchment2.default.Scope.BLOCK_BLOT;
    List.tagName = ['OL', 'UL'];
    List.defaultChild = 'list-item';
    List.allowedChildren = [ListItem];

    exports.ListItem = ListItem;
    exports.default = List;

    /***/ }),
    /* 68 */
    /***/ (function(module, exports, __webpack_require__) {


    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    var _bold = __webpack_require__(56);

    var _bold2 = _interopRequireDefault(_bold);

    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    var Italic = function (_Bold) {
      _inherits(Italic, _Bold);

      function Italic() {
        _classCallCheck(this, Italic);

        return _possibleConstructorReturn(this, (Italic.__proto__ || Object.getPrototypeOf(Italic)).apply(this, arguments));
      }

      return Italic;
    }(_bold2.default);

    Italic.blotName = 'italic';
    Italic.tagName = ['EM', 'I'];

    exports.default = Italic;

    /***/ }),
    /* 69 */
    /***/ (function(module, exports, __webpack_require__) {


    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

    var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

    var _inline = __webpack_require__(6);

    var _inline2 = _interopRequireDefault(_inline);

    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    var Script = function (_Inline) {
      _inherits(Script, _Inline);

      function Script() {
        _classCallCheck(this, Script);

        return _possibleConstructorReturn(this, (Script.__proto__ || Object.getPrototypeOf(Script)).apply(this, arguments));
      }

      _createClass(Script, null, [{
        key: 'create',
        value: function create(value) {
          if (value === 'super') {
            return document.createElement('sup');
          } else if (value === 'sub') {
            return document.createElement('sub');
          } else {
            return _get(Script.__proto__ || Object.getPrototypeOf(Script), 'create', this).call(this, value);
          }
        }
      }, {
        key: 'formats',
        value: function formats(domNode) {
          if (domNode.tagName === 'SUB') return 'sub';
          if (domNode.tagName === 'SUP') return 'super';
          return undefined;
        }
      }]);

      return Script;
    }(_inline2.default);

    Script.blotName = 'script';
    Script.tagName = ['SUB', 'SUP'];

    exports.default = Script;

    /***/ }),
    /* 70 */
    /***/ (function(module, exports, __webpack_require__) {


    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    var _inline = __webpack_require__(6);

    var _inline2 = _interopRequireDefault(_inline);

    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    var Strike = function (_Inline) {
      _inherits(Strike, _Inline);

      function Strike() {
        _classCallCheck(this, Strike);

        return _possibleConstructorReturn(this, (Strike.__proto__ || Object.getPrototypeOf(Strike)).apply(this, arguments));
      }

      return Strike;
    }(_inline2.default);

    Strike.blotName = 'strike';
    Strike.tagName = 'S';

    exports.default = Strike;

    /***/ }),
    /* 71 */
    /***/ (function(module, exports, __webpack_require__) {


    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    var _inline = __webpack_require__(6);

    var _inline2 = _interopRequireDefault(_inline);

    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    var Underline = function (_Inline) {
      _inherits(Underline, _Inline);

      function Underline() {
        _classCallCheck(this, Underline);

        return _possibleConstructorReturn(this, (Underline.__proto__ || Object.getPrototypeOf(Underline)).apply(this, arguments));
      }

      return Underline;
    }(_inline2.default);

    Underline.blotName = 'underline';
    Underline.tagName = 'U';

    exports.default = Underline;

    /***/ }),
    /* 72 */
    /***/ (function(module, exports, __webpack_require__) {


    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

    var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

    var _parchment = __webpack_require__(0);

    var _parchment2 = _interopRequireDefault(_parchment);

    var _link = __webpack_require__(27);

    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    var ATTRIBUTES = ['alt', 'height', 'width'];

    var Image = function (_Parchment$Embed) {
      _inherits(Image, _Parchment$Embed);

      function Image() {
        _classCallCheck(this, Image);

        return _possibleConstructorReturn(this, (Image.__proto__ || Object.getPrototypeOf(Image)).apply(this, arguments));
      }

      _createClass(Image, [{
        key: 'format',
        value: function format(name, value) {
          if (ATTRIBUTES.indexOf(name) > -1) {
            if (value) {
              this.domNode.setAttribute(name, value);
            } else {
              this.domNode.removeAttribute(name);
            }
          } else {
            _get(Image.prototype.__proto__ || Object.getPrototypeOf(Image.prototype), 'format', this).call(this, name, value);
          }
        }
      }], [{
        key: 'create',
        value: function create(value) {
          var node = _get(Image.__proto__ || Object.getPrototypeOf(Image), 'create', this).call(this, value);
          if (typeof value === 'string') {
            node.setAttribute('src', this.sanitize(value));
          }
          return node;
        }
      }, {
        key: 'formats',
        value: function formats(domNode) {
          return ATTRIBUTES.reduce(function (formats, attribute) {
            if (domNode.hasAttribute(attribute)) {
              formats[attribute] = domNode.getAttribute(attribute);
            }
            return formats;
          }, {});
        }
      }, {
        key: 'match',
        value: function match(url) {
          return (/\.(jpe?g|gif|png)$/.test(url) || /^data:image\/.+;base64/.test(url)
          );
        }
      }, {
        key: 'sanitize',
        value: function sanitize(url) {
          return (0, _link.sanitize)(url, ['http', 'https', 'data']) ? url : '//:0';
        }
      }, {
        key: 'value',
        value: function value(domNode) {
          return domNode.getAttribute('src');
        }
      }]);

      return Image;
    }(_parchment2.default.Embed);

    Image.blotName = 'image';
    Image.tagName = 'IMG';

    exports.default = Image;

    /***/ }),
    /* 73 */
    /***/ (function(module, exports, __webpack_require__) {


    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

    var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

    var _block = __webpack_require__(4);

    var _link = __webpack_require__(27);

    var _link2 = _interopRequireDefault(_link);

    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    var ATTRIBUTES = ['height', 'width'];

    var Video = function (_BlockEmbed) {
      _inherits(Video, _BlockEmbed);

      function Video() {
        _classCallCheck(this, Video);

        return _possibleConstructorReturn(this, (Video.__proto__ || Object.getPrototypeOf(Video)).apply(this, arguments));
      }

      _createClass(Video, [{
        key: 'format',
        value: function format(name, value) {
          if (ATTRIBUTES.indexOf(name) > -1) {
            if (value) {
              this.domNode.setAttribute(name, value);
            } else {
              this.domNode.removeAttribute(name);
            }
          } else {
            _get(Video.prototype.__proto__ || Object.getPrototypeOf(Video.prototype), 'format', this).call(this, name, value);
          }
        }
      }], [{
        key: 'create',
        value: function create(value) {
          var node = _get(Video.__proto__ || Object.getPrototypeOf(Video), 'create', this).call(this, value);
          node.setAttribute('frameborder', '0');
          node.setAttribute('allowfullscreen', true);
          node.setAttribute('src', this.sanitize(value));
          return node;
        }
      }, {
        key: 'formats',
        value: function formats(domNode) {
          return ATTRIBUTES.reduce(function (formats, attribute) {
            if (domNode.hasAttribute(attribute)) {
              formats[attribute] = domNode.getAttribute(attribute);
            }
            return formats;
          }, {});
        }
      }, {
        key: 'sanitize',
        value: function sanitize(url) {
          return _link2.default.sanitize(url);
        }
      }, {
        key: 'value',
        value: function value(domNode) {
          return domNode.getAttribute('src');
        }
      }]);

      return Video;
    }(_block.BlockEmbed);

    Video.blotName = 'video';
    Video.className = 'ql-video';
    Video.tagName = 'IFRAME';

    exports.default = Video;

    /***/ }),
    /* 74 */
    /***/ (function(module, exports, __webpack_require__) {


    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = exports.FormulaBlot = undefined;

    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

    var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

    var _embed = __webpack_require__(35);

    var _embed2 = _interopRequireDefault(_embed);

    var _quill = __webpack_require__(5);

    var _quill2 = _interopRequireDefault(_quill);

    var _module = __webpack_require__(9);

    var _module2 = _interopRequireDefault(_module);

    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    var FormulaBlot = function (_Embed) {
      _inherits(FormulaBlot, _Embed);

      function FormulaBlot() {
        _classCallCheck(this, FormulaBlot);

        return _possibleConstructorReturn(this, (FormulaBlot.__proto__ || Object.getPrototypeOf(FormulaBlot)).apply(this, arguments));
      }

      _createClass(FormulaBlot, null, [{
        key: 'create',
        value: function create(value) {
          var node = _get(FormulaBlot.__proto__ || Object.getPrototypeOf(FormulaBlot), 'create', this).call(this, value);
          if (typeof value === 'string') {
            window.katex.render(value, node, {
              throwOnError: false,
              errorColor: '#f00'
            });
            node.setAttribute('data-value', value);
          }
          return node;
        }
      }, {
        key: 'value',
        value: function value(domNode) {
          return domNode.getAttribute('data-value');
        }
      }]);

      return FormulaBlot;
    }(_embed2.default);

    FormulaBlot.blotName = 'formula';
    FormulaBlot.className = 'ql-formula';
    FormulaBlot.tagName = 'SPAN';

    var Formula = function (_Module) {
      _inherits(Formula, _Module);

      _createClass(Formula, null, [{
        key: 'register',
        value: function register() {
          _quill2.default.register(FormulaBlot, true);
        }
      }]);

      function Formula() {
        _classCallCheck(this, Formula);

        var _this2 = _possibleConstructorReturn(this, (Formula.__proto__ || Object.getPrototypeOf(Formula)).call(this));

        if (window.katex == null) {
          throw new Error('Formula module requires KaTeX.');
        }
        return _this2;
      }

      return Formula;
    }(_module2.default);

    exports.FormulaBlot = FormulaBlot;
    exports.default = Formula;

    /***/ }),
    /* 75 */
    /***/ (function(module, exports, __webpack_require__) {


    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = exports.CodeToken = exports.CodeBlock = undefined;

    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

    var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

    var _parchment = __webpack_require__(0);

    var _parchment2 = _interopRequireDefault(_parchment);

    var _quill = __webpack_require__(5);

    var _quill2 = _interopRequireDefault(_quill);

    var _module = __webpack_require__(9);

    var _module2 = _interopRequireDefault(_module);

    var _code = __webpack_require__(13);

    var _code2 = _interopRequireDefault(_code);

    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    var SyntaxCodeBlock = function (_CodeBlock) {
      _inherits(SyntaxCodeBlock, _CodeBlock);

      function SyntaxCodeBlock() {
        _classCallCheck(this, SyntaxCodeBlock);

        return _possibleConstructorReturn(this, (SyntaxCodeBlock.__proto__ || Object.getPrototypeOf(SyntaxCodeBlock)).apply(this, arguments));
      }

      _createClass(SyntaxCodeBlock, [{
        key: 'replaceWith',
        value: function replaceWith(block) {
          this.domNode.textContent = this.domNode.textContent;
          this.attach();
          _get(SyntaxCodeBlock.prototype.__proto__ || Object.getPrototypeOf(SyntaxCodeBlock.prototype), 'replaceWith', this).call(this, block);
        }
      }, {
        key: 'highlight',
        value: function highlight(_highlight) {
          var text = this.domNode.textContent;
          if (this.cachedText !== text) {
            if (text.trim().length > 0 || this.cachedText == null) {
              this.domNode.innerHTML = _highlight(text);
              this.domNode.normalize();
              this.attach();
            }
            this.cachedText = text;
          }
        }
      }]);

      return SyntaxCodeBlock;
    }(_code2.default);

    SyntaxCodeBlock.className = 'ql-syntax';

    var CodeToken = new _parchment2.default.Attributor.Class('token', 'hljs', {
      scope: _parchment2.default.Scope.INLINE
    });

    var Syntax = function (_Module) {
      _inherits(Syntax, _Module);

      _createClass(Syntax, null, [{
        key: 'register',
        value: function register() {
          _quill2.default.register(CodeToken, true);
          _quill2.default.register(SyntaxCodeBlock, true);
        }
      }]);

      function Syntax(quill, options) {
        _classCallCheck(this, Syntax);

        var _this2 = _possibleConstructorReturn(this, (Syntax.__proto__ || Object.getPrototypeOf(Syntax)).call(this, quill, options));

        if (typeof _this2.options.highlight !== 'function') {
          throw new Error('Syntax module requires highlight.js. Please include the library on the page before Quill.');
        }
        var timer = null;
        _this2.quill.on(_quill2.default.events.SCROLL_OPTIMIZE, function () {
          clearTimeout(timer);
          timer = setTimeout(function () {
            _this2.highlight();
            timer = null;
          }, _this2.options.interval);
        });
        _this2.highlight();
        return _this2;
      }

      _createClass(Syntax, [{
        key: 'highlight',
        value: function highlight() {
          var _this3 = this;

          if (this.quill.selection.composing) return;
          this.quill.update(_quill2.default.sources.USER);
          var range = this.quill.getSelection();
          this.quill.scroll.descendants(SyntaxCodeBlock).forEach(function (code) {
            code.highlight(_this3.options.highlight);
          });
          this.quill.update(_quill2.default.sources.SILENT);
          if (range != null) {
            this.quill.setSelection(range, _quill2.default.sources.SILENT);
          }
        }
      }]);

      return Syntax;
    }(_module2.default);

    Syntax.DEFAULTS = {
      highlight: function () {
        if (window.hljs == null) return null;
        return function (text) {
          var result = window.hljs.highlightAuto(text);
          return result.value;
        };
      }(),
      interval: 1000
    };

    exports.CodeBlock = SyntaxCodeBlock;
    exports.CodeToken = CodeToken;
    exports.default = Syntax;

    /***/ }),
    /* 76 */
    /***/ (function(module, exports) {

    module.exports = "<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=3 x2=15 y1=9 y2=9></line> <line class=ql-stroke x1=3 x2=13 y1=14 y2=14></line> <line class=ql-stroke x1=3 x2=9 y1=4 y2=4></line> </svg>";

    /***/ }),
    /* 77 */
    /***/ (function(module, exports) {

    module.exports = "<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=15 x2=3 y1=9 y2=9></line> <line class=ql-stroke x1=14 x2=4 y1=14 y2=14></line> <line class=ql-stroke x1=12 x2=6 y1=4 y2=4></line> </svg>";

    /***/ }),
    /* 78 */
    /***/ (function(module, exports) {

    module.exports = "<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=15 x2=3 y1=9 y2=9></line> <line class=ql-stroke x1=15 x2=5 y1=14 y2=14></line> <line class=ql-stroke x1=15 x2=9 y1=4 y2=4></line> </svg>";

    /***/ }),
    /* 79 */
    /***/ (function(module, exports) {

    module.exports = "<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=15 x2=3 y1=9 y2=9></line> <line class=ql-stroke x1=15 x2=3 y1=14 y2=14></line> <line class=ql-stroke x1=15 x2=3 y1=4 y2=4></line> </svg>";

    /***/ }),
    /* 80 */
    /***/ (function(module, exports) {

    module.exports = "<svg viewbox=\"0 0 18 18\"> <g class=\"ql-fill ql-color-label\"> <polygon points=\"6 6.868 6 6 5 6 5 7 5.942 7 6 6.868\"></polygon> <rect height=1 width=1 x=4 y=4></rect> <polygon points=\"6.817 5 6 5 6 6 6.38 6 6.817 5\"></polygon> <rect height=1 width=1 x=2 y=6></rect> <rect height=1 width=1 x=3 y=5></rect> <rect height=1 width=1 x=4 y=7></rect> <polygon points=\"4 11.439 4 11 3 11 3 12 3.755 12 4 11.439\"></polygon> <rect height=1 width=1 x=2 y=12></rect> <rect height=1 width=1 x=2 y=9></rect> <rect height=1 width=1 x=2 y=15></rect> <polygon points=\"4.63 10 4 10 4 11 4.192 11 4.63 10\"></polygon> <rect height=1 width=1 x=3 y=8></rect> <path d=M10.832,4.2L11,4.582V4H10.708A1.948,1.948,0,0,1,10.832,4.2Z></path> <path d=M7,4.582L7.168,4.2A1.929,1.929,0,0,1,7.292,4H7V4.582Z></path> <path d=M8,13H7.683l-0.351.8a1.933,1.933,0,0,1-.124.2H8V13Z></path> <rect height=1 width=1 x=12 y=2></rect> <rect height=1 width=1 x=11 y=3></rect> <path d=M9,3H8V3.282A1.985,1.985,0,0,1,9,3Z></path> <rect height=1 width=1 x=2 y=3></rect> <rect height=1 width=1 x=6 y=2></rect> <rect height=1 width=1 x=3 y=2></rect> <rect height=1 width=1 x=5 y=3></rect> <rect height=1 width=1 x=9 y=2></rect> <rect height=1 width=1 x=15 y=14></rect> <polygon points=\"13.447 10.174 13.469 10.225 13.472 10.232 13.808 11 14 11 14 10 13.37 10 13.447 10.174\"></polygon> <rect height=1 width=1 x=13 y=7></rect> <rect height=1 width=1 x=15 y=5></rect> <rect height=1 width=1 x=14 y=6></rect> <rect height=1 width=1 x=15 y=8></rect> <rect height=1 width=1 x=14 y=9></rect> <path d=M3.775,14H3v1H4V14.314A1.97,1.97,0,0,1,3.775,14Z></path> <rect height=1 width=1 x=14 y=3></rect> <polygon points=\"12 6.868 12 6 11.62 6 12 6.868\"></polygon> <rect height=1 width=1 x=15 y=2></rect> <rect height=1 width=1 x=12 y=5></rect> <rect height=1 width=1 x=13 y=4></rect> <polygon points=\"12.933 9 13 9 13 8 12.495 8 12.933 9\"></polygon> <rect height=1 width=1 x=9 y=14></rect> <rect height=1 width=1 x=8 y=15></rect> <path d=M6,14.926V15H7V14.316A1.993,1.993,0,0,1,6,14.926Z></path> <rect height=1 width=1 x=5 y=15></rect> <path d=M10.668,13.8L10.317,13H10v1h0.792A1.947,1.947,0,0,1,10.668,13.8Z></path> <rect height=1 width=1 x=11 y=15></rect> <path d=M14.332,12.2a1.99,1.99,0,0,1,.166.8H15V12H14.245Z></path> <rect height=1 width=1 x=14 y=15></rect> <rect height=1 width=1 x=15 y=11></rect> </g> <polyline class=ql-stroke points=\"5.5 13 9 5 12.5 13\"></polyline> <line class=ql-stroke x1=11.63 x2=6.38 y1=11 y2=11></line> </svg>";

    /***/ }),
    /* 81 */
    /***/ (function(module, exports) {

    module.exports = "<svg viewbox=\"0 0 18 18\"> <rect class=\"ql-fill ql-stroke\" height=3 width=3 x=4 y=5></rect> <rect class=\"ql-fill ql-stroke\" height=3 width=3 x=11 y=5></rect> <path class=\"ql-even ql-fill ql-stroke\" d=M7,8c0,4.031-3,5-3,5></path> <path class=\"ql-even ql-fill ql-stroke\" d=M14,8c0,4.031-3,5-3,5></path> </svg>";

    /***/ }),
    /* 82 */
    /***/ (function(module, exports) {

    module.exports = "<svg viewbox=\"0 0 18 18\"> <path class=ql-stroke d=M5,4H9.5A2.5,2.5,0,0,1,12,6.5v0A2.5,2.5,0,0,1,9.5,9H5A0,0,0,0,1,5,9V4A0,0,0,0,1,5,4Z></path> <path class=ql-stroke d=M5,9h5.5A2.5,2.5,0,0,1,13,11.5v0A2.5,2.5,0,0,1,10.5,14H5a0,0,0,0,1,0,0V9A0,0,0,0,1,5,9Z></path> </svg>";

    /***/ }),
    /* 83 */
    /***/ (function(module, exports) {

    module.exports = "<svg class=\"\" viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=5 x2=13 y1=3 y2=3></line> <line class=ql-stroke x1=6 x2=9.35 y1=12 y2=3></line> <line class=ql-stroke x1=11 x2=15 y1=11 y2=15></line> <line class=ql-stroke x1=15 x2=11 y1=11 y2=15></line> <rect class=ql-fill height=1 rx=0.5 ry=0.5 width=7 x=2 y=14></rect> </svg>";

    /***/ }),
    /* 84 */
    /***/ (function(module, exports) {

    module.exports = "<svg viewbox=\"0 0 18 18\"> <line class=\"ql-color-label ql-stroke ql-transparent\" x1=3 x2=15 y1=15 y2=15></line> <polyline class=ql-stroke points=\"5.5 11 9 3 12.5 11\"></polyline> <line class=ql-stroke x1=11.63 x2=6.38 y1=9 y2=9></line> </svg>";

    /***/ }),
    /* 85 */
    /***/ (function(module, exports) {

    module.exports = "<svg viewbox=\"0 0 18 18\"> <polygon class=\"ql-stroke ql-fill\" points=\"3 11 5 9 3 7 3 11\"></polygon> <line class=\"ql-stroke ql-fill\" x1=15 x2=11 y1=4 y2=4></line> <path class=ql-fill d=M11,3a3,3,0,0,0,0,6h1V3H11Z></path> <rect class=ql-fill height=11 width=1 x=11 y=4></rect> <rect class=ql-fill height=11 width=1 x=13 y=4></rect> </svg>";

    /***/ }),
    /* 86 */
    /***/ (function(module, exports) {

    module.exports = "<svg viewbox=\"0 0 18 18\"> <polygon class=\"ql-stroke ql-fill\" points=\"15 12 13 10 15 8 15 12\"></polygon> <line class=\"ql-stroke ql-fill\" x1=9 x2=5 y1=4 y2=4></line> <path class=ql-fill d=M5,3A3,3,0,0,0,5,9H6V3H5Z></path> <rect class=ql-fill height=11 width=1 x=5 y=4></rect> <rect class=ql-fill height=11 width=1 x=7 y=4></rect> </svg>";

    /***/ }),
    /* 87 */
    /***/ (function(module, exports) {

    module.exports = "<svg viewbox=\"0 0 18 18\"> <path class=ql-fill d=M14,16H4a1,1,0,0,1,0-2H14A1,1,0,0,1,14,16Z /> <path class=ql-fill d=M14,4H4A1,1,0,0,1,4,2H14A1,1,0,0,1,14,4Z /> <rect class=ql-fill x=3 y=6 width=12 height=6 rx=1 ry=1 /> </svg>";

    /***/ }),
    /* 88 */
    /***/ (function(module, exports) {

    module.exports = "<svg viewbox=\"0 0 18 18\"> <path class=ql-fill d=M13,16H5a1,1,0,0,1,0-2h8A1,1,0,0,1,13,16Z /> <path class=ql-fill d=M13,4H5A1,1,0,0,1,5,2h8A1,1,0,0,1,13,4Z /> <rect class=ql-fill x=2 y=6 width=14 height=6 rx=1 ry=1 /> </svg>";

    /***/ }),
    /* 89 */
    /***/ (function(module, exports) {

    module.exports = "<svg viewbox=\"0 0 18 18\"> <path class=ql-fill d=M15,8H13a1,1,0,0,1,0-2h2A1,1,0,0,1,15,8Z /> <path class=ql-fill d=M15,12H13a1,1,0,0,1,0-2h2A1,1,0,0,1,15,12Z /> <path class=ql-fill d=M15,16H5a1,1,0,0,1,0-2H15A1,1,0,0,1,15,16Z /> <path class=ql-fill d=M15,4H5A1,1,0,0,1,5,2H15A1,1,0,0,1,15,4Z /> <rect class=ql-fill x=2 y=6 width=8 height=6 rx=1 ry=1 /> </svg>";

    /***/ }),
    /* 90 */
    /***/ (function(module, exports) {

    module.exports = "<svg viewbox=\"0 0 18 18\"> <path class=ql-fill d=M5,8H3A1,1,0,0,1,3,6H5A1,1,0,0,1,5,8Z /> <path class=ql-fill d=M5,12H3a1,1,0,0,1,0-2H5A1,1,0,0,1,5,12Z /> <path class=ql-fill d=M13,16H3a1,1,0,0,1,0-2H13A1,1,0,0,1,13,16Z /> <path class=ql-fill d=M13,4H3A1,1,0,0,1,3,2H13A1,1,0,0,1,13,4Z /> <rect class=ql-fill x=8 y=6 width=8 height=6 rx=1 ry=1 transform=\"translate(24 18) rotate(-180)\"/> </svg>";

    /***/ }),
    /* 91 */
    /***/ (function(module, exports) {

    module.exports = "<svg viewbox=\"0 0 18 18\"> <path class=ql-fill d=M11.759,2.482a2.561,2.561,0,0,0-3.53.607A7.656,7.656,0,0,0,6.8,6.2C6.109,9.188,5.275,14.677,4.15,14.927a1.545,1.545,0,0,0-1.3-.933A0.922,0.922,0,0,0,2,15.036S1.954,16,4.119,16s3.091-2.691,3.7-5.553c0.177-.826.36-1.726,0.554-2.6L8.775,6.2c0.381-1.421.807-2.521,1.306-2.676a1.014,1.014,0,0,0,1.02.56A0.966,0.966,0,0,0,11.759,2.482Z></path> <rect class=ql-fill height=1.6 rx=0.8 ry=0.8 width=5 x=5.15 y=6.2></rect> <path class=ql-fill d=M13.663,12.027a1.662,1.662,0,0,1,.266-0.276q0.193,0.069.456,0.138a2.1,2.1,0,0,0,.535.069,1.075,1.075,0,0,0,.767-0.3,1.044,1.044,0,0,0,.314-0.8,0.84,0.84,0,0,0-.238-0.619,0.8,0.8,0,0,0-.594-0.239,1.154,1.154,0,0,0-.781.3,4.607,4.607,0,0,0-.781,1q-0.091.15-.218,0.346l-0.246.38c-0.068-.288-0.137-0.582-0.212-0.885-0.459-1.847-2.494-.984-2.941-0.8-0.482.2-.353,0.647-0.094,0.529a0.869,0.869,0,0,1,1.281.585c0.217,0.751.377,1.436,0.527,2.038a5.688,5.688,0,0,1-.362.467,2.69,2.69,0,0,1-.264.271q-0.221-.08-0.471-0.147a2.029,2.029,0,0,0-.522-0.066,1.079,1.079,0,0,0-.768.3A1.058,1.058,0,0,0,9,15.131a0.82,0.82,0,0,0,.832.852,1.134,1.134,0,0,0,.787-0.3,5.11,5.11,0,0,0,.776-0.993q0.141-.219.215-0.34c0.046-.076.122-0.194,0.223-0.346a2.786,2.786,0,0,0,.918,1.726,2.582,2.582,0,0,0,2.376-.185c0.317-.181.212-0.565,0-0.494A0.807,0.807,0,0,1,14.176,15a5.159,5.159,0,0,1-.913-2.446l0,0Q13.487,12.24,13.663,12.027Z></path> </svg>";

    /***/ }),
    /* 92 */
    /***/ (function(module, exports) {

    module.exports = "<svg viewBox=\"0 0 18 18\"> <path class=ql-fill d=M10,4V14a1,1,0,0,1-2,0V10H3v4a1,1,0,0,1-2,0V4A1,1,0,0,1,3,4V8H8V4a1,1,0,0,1,2,0Zm6.06787,9.209H14.98975V7.59863a.54085.54085,0,0,0-.605-.60547h-.62744a1.01119,1.01119,0,0,0-.748.29688L11.645,8.56641a.5435.5435,0,0,0-.022.8584l.28613.30762a.53861.53861,0,0,0,.84717.0332l.09912-.08789a1.2137,1.2137,0,0,0,.2417-.35254h.02246s-.01123.30859-.01123.60547V13.209H12.041a.54085.54085,0,0,0-.605.60547v.43945a.54085.54085,0,0,0,.605.60547h4.02686a.54085.54085,0,0,0,.605-.60547v-.43945A.54085.54085,0,0,0,16.06787,13.209Z /> </svg>";

    /***/ }),
    /* 93 */
    /***/ (function(module, exports) {

    module.exports = "<svg viewBox=\"0 0 18 18\"> <path class=ql-fill d=M16.73975,13.81445v.43945a.54085.54085,0,0,1-.605.60547H11.855a.58392.58392,0,0,1-.64893-.60547V14.0127c0-2.90527,3.39941-3.42187,3.39941-4.55469a.77675.77675,0,0,0-.84717-.78125,1.17684,1.17684,0,0,0-.83594.38477c-.2749.26367-.561.374-.85791.13184l-.4292-.34082c-.30811-.24219-.38525-.51758-.1543-.81445a2.97155,2.97155,0,0,1,2.45361-1.17676,2.45393,2.45393,0,0,1,2.68408,2.40918c0,2.45312-3.1792,2.92676-3.27832,3.93848h2.79443A.54085.54085,0,0,1,16.73975,13.81445ZM9,3A.99974.99974,0,0,0,8,4V8H3V4A1,1,0,0,0,1,4V14a1,1,0,0,0,2,0V10H8v4a1,1,0,0,0,2,0V4A.99974.99974,0,0,0,9,3Z /> </svg>";

    /***/ }),
    /* 94 */
    /***/ (function(module, exports) {

    module.exports = "<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=7 x2=13 y1=4 y2=4></line> <line class=ql-stroke x1=5 x2=11 y1=14 y2=14></line> <line class=ql-stroke x1=8 x2=10 y1=14 y2=4></line> </svg>";

    /***/ }),
    /* 95 */
    /***/ (function(module, exports) {

    module.exports = "<svg viewbox=\"0 0 18 18\"> <rect class=ql-stroke height=10 width=12 x=3 y=4></rect> <circle class=ql-fill cx=6 cy=7 r=1></circle> <polyline class=\"ql-even ql-fill\" points=\"5 12 5 11 7 9 8 10 11 7 13 9 13 12 5 12\"></polyline> </svg>";

    /***/ }),
    /* 96 */
    /***/ (function(module, exports) {

    module.exports = "<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=3 x2=15 y1=14 y2=14></line> <line class=ql-stroke x1=3 x2=15 y1=4 y2=4></line> <line class=ql-stroke x1=9 x2=15 y1=9 y2=9></line> <polyline class=\"ql-fill ql-stroke\" points=\"3 7 3 11 5 9 3 7\"></polyline> </svg>";

    /***/ }),
    /* 97 */
    /***/ (function(module, exports) {

    module.exports = "<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=3 x2=15 y1=14 y2=14></line> <line class=ql-stroke x1=3 x2=15 y1=4 y2=4></line> <line class=ql-stroke x1=9 x2=15 y1=9 y2=9></line> <polyline class=ql-stroke points=\"5 7 5 11 3 9 5 7\"></polyline> </svg>";

    /***/ }),
    /* 98 */
    /***/ (function(module, exports) {

    module.exports = "<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=7 x2=11 y1=7 y2=11></line> <path class=\"ql-even ql-stroke\" d=M8.9,4.577a3.476,3.476,0,0,1,.36,4.679A3.476,3.476,0,0,1,4.577,8.9C3.185,7.5,2.035,6.4,4.217,4.217S7.5,3.185,8.9,4.577Z></path> <path class=\"ql-even ql-stroke\" d=M13.423,9.1a3.476,3.476,0,0,0-4.679-.36,3.476,3.476,0,0,0,.36,4.679c1.392,1.392,2.5,2.542,4.679.36S14.815,10.5,13.423,9.1Z></path> </svg>";

    /***/ }),
    /* 99 */
    /***/ (function(module, exports) {

    module.exports = "<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=7 x2=15 y1=4 y2=4></line> <line class=ql-stroke x1=7 x2=15 y1=9 y2=9></line> <line class=ql-stroke x1=7 x2=15 y1=14 y2=14></line> <line class=\"ql-stroke ql-thin\" x1=2.5 x2=4.5 y1=5.5 y2=5.5></line> <path class=ql-fill d=M3.5,6A0.5,0.5,0,0,1,3,5.5V3.085l-0.276.138A0.5,0.5,0,0,1,2.053,3c-0.124-.247-0.023-0.324.224-0.447l1-.5A0.5,0.5,0,0,1,4,2.5v3A0.5,0.5,0,0,1,3.5,6Z></path> <path class=\"ql-stroke ql-thin\" d=M4.5,10.5h-2c0-.234,1.85-1.076,1.85-2.234A0.959,0.959,0,0,0,2.5,8.156></path> <path class=\"ql-stroke ql-thin\" d=M2.5,14.846a0.959,0.959,0,0,0,1.85-.109A0.7,0.7,0,0,0,3.75,14a0.688,0.688,0,0,0,.6-0.736,0.959,0.959,0,0,0-1.85-.109></path> </svg>";

    /***/ }),
    /* 100 */
    /***/ (function(module, exports) {

    module.exports = "<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=6 x2=15 y1=4 y2=4></line> <line class=ql-stroke x1=6 x2=15 y1=9 y2=9></line> <line class=ql-stroke x1=6 x2=15 y1=14 y2=14></line> <line class=ql-stroke x1=3 x2=3 y1=4 y2=4></line> <line class=ql-stroke x1=3 x2=3 y1=9 y2=9></line> <line class=ql-stroke x1=3 x2=3 y1=14 y2=14></line> </svg>";

    /***/ }),
    /* 101 */
    /***/ (function(module, exports) {

    module.exports = "<svg class=\"\" viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=9 x2=15 y1=4 y2=4></line> <polyline class=ql-stroke points=\"3 4 4 5 6 3\"></polyline> <line class=ql-stroke x1=9 x2=15 y1=14 y2=14></line> <polyline class=ql-stroke points=\"3 14 4 15 6 13\"></polyline> <line class=ql-stroke x1=9 x2=15 y1=9 y2=9></line> <polyline class=ql-stroke points=\"3 9 4 10 6 8\"></polyline> </svg>";

    /***/ }),
    /* 102 */
    /***/ (function(module, exports) {

    module.exports = "<svg viewbox=\"0 0 18 18\"> <path class=ql-fill d=M15.5,15H13.861a3.858,3.858,0,0,0,1.914-2.975,1.8,1.8,0,0,0-1.6-1.751A1.921,1.921,0,0,0,12.021,11.7a0.50013,0.50013,0,1,0,.957.291h0a0.914,0.914,0,0,1,1.053-.725,0.81,0.81,0,0,1,.744.762c0,1.076-1.16971,1.86982-1.93971,2.43082A1.45639,1.45639,0,0,0,12,15.5a0.5,0.5,0,0,0,.5.5h3A0.5,0.5,0,0,0,15.5,15Z /> <path class=ql-fill d=M9.65,5.241a1,1,0,0,0-1.409.108L6,7.964,3.759,5.349A1,1,0,0,0,2.192,6.59178Q2.21541,6.6213,2.241,6.649L4.684,9.5,2.241,12.35A1,1,0,0,0,3.71,13.70722q0.02557-.02768.049-0.05722L6,11.036,8.241,13.65a1,1,0,1,0,1.567-1.24277Q9.78459,12.3777,9.759,12.35L7.316,9.5,9.759,6.651A1,1,0,0,0,9.65,5.241Z /> </svg>";

    /***/ }),
    /* 103 */
    /***/ (function(module, exports) {

    module.exports = "<svg viewbox=\"0 0 18 18\"> <path class=ql-fill d=M15.5,7H13.861a4.015,4.015,0,0,0,1.914-2.975,1.8,1.8,0,0,0-1.6-1.751A1.922,1.922,0,0,0,12.021,3.7a0.5,0.5,0,1,0,.957.291,0.917,0.917,0,0,1,1.053-.725,0.81,0.81,0,0,1,.744.762c0,1.077-1.164,1.925-1.934,2.486A1.423,1.423,0,0,0,12,7.5a0.5,0.5,0,0,0,.5.5h3A0.5,0.5,0,0,0,15.5,7Z /> <path class=ql-fill d=M9.651,5.241a1,1,0,0,0-1.41.108L6,7.964,3.759,5.349a1,1,0,1,0-1.519,1.3L4.683,9.5,2.241,12.35a1,1,0,1,0,1.519,1.3L6,11.036,8.241,13.65a1,1,0,0,0,1.519-1.3L7.317,9.5,9.759,6.651A1,1,0,0,0,9.651,5.241Z /> </svg>";

    /***/ }),
    /* 104 */
    /***/ (function(module, exports) {

    module.exports = "<svg viewbox=\"0 0 18 18\"> <line class=\"ql-stroke ql-thin\" x1=15.5 x2=2.5 y1=8.5 y2=9.5></line> <path class=ql-fill d=M9.007,8C6.542,7.791,6,7.519,6,6.5,6,5.792,7.283,5,9,5c1.571,0,2.765.679,2.969,1.309a1,1,0,0,0,1.9-.617C13.356,4.106,11.354,3,9,3,6.2,3,4,4.538,4,6.5a3.2,3.2,0,0,0,.5,1.843Z></path> <path class=ql-fill d=M8.984,10C11.457,10.208,12,10.479,12,11.5c0,0.708-1.283,1.5-3,1.5-1.571,0-2.765-.679-2.969-1.309a1,1,0,1,0-1.9.617C4.644,13.894,6.646,15,9,15c2.8,0,5-1.538,5-3.5a3.2,3.2,0,0,0-.5-1.843Z></path> </svg>";

    /***/ }),
    /* 105 */
    /***/ (function(module, exports) {

    module.exports = "<svg viewbox=\"0 0 18 18\"> <path class=ql-stroke d=M5,3V9a4.012,4.012,0,0,0,4,4H9a4.012,4.012,0,0,0,4-4V3></path> <rect class=ql-fill height=1 rx=0.5 ry=0.5 width=12 x=3 y=15></rect> </svg>";

    /***/ }),
    /* 106 */
    /***/ (function(module, exports) {

    module.exports = "<svg viewbox=\"0 0 18 18\"> <rect class=ql-stroke height=12 width=12 x=3 y=3></rect> <rect class=ql-fill height=12 width=1 x=5 y=3></rect> <rect class=ql-fill height=12 width=1 x=12 y=3></rect> <rect class=ql-fill height=2 width=8 x=5 y=8></rect> <rect class=ql-fill height=1 width=3 x=3 y=5></rect> <rect class=ql-fill height=1 width=3 x=3 y=7></rect> <rect class=ql-fill height=1 width=3 x=3 y=10></rect> <rect class=ql-fill height=1 width=3 x=3 y=12></rect> <rect class=ql-fill height=1 width=3 x=12 y=5></rect> <rect class=ql-fill height=1 width=3 x=12 y=7></rect> <rect class=ql-fill height=1 width=3 x=12 y=10></rect> <rect class=ql-fill height=1 width=3 x=12 y=12></rect> </svg>";

    /***/ }),
    /* 107 */
    /***/ (function(module, exports) {

    module.exports = "<svg viewbox=\"0 0 18 18\"> <polygon class=ql-stroke points=\"7 11 9 13 11 11 7 11\"></polygon> <polygon class=ql-stroke points=\"7 7 9 5 11 7 7 7\"></polygon> </svg>";

    /***/ }),
    /* 108 */
    /***/ (function(module, exports, __webpack_require__) {


    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = exports.BubbleTooltip = undefined;

    var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

    var _extend = __webpack_require__(3);

    var _extend2 = _interopRequireDefault(_extend);

    var _emitter = __webpack_require__(8);

    var _emitter2 = _interopRequireDefault(_emitter);

    var _base = __webpack_require__(43);

    var _base2 = _interopRequireDefault(_base);

    var _selection = __webpack_require__(15);

    var _icons = __webpack_require__(41);

    var _icons2 = _interopRequireDefault(_icons);

    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    var TOOLBAR_CONFIG = [['bold', 'italic', 'link'], [{ header: 1 }, { header: 2 }, 'blockquote']];

    var BubbleTheme = function (_BaseTheme) {
      _inherits(BubbleTheme, _BaseTheme);

      function BubbleTheme(quill, options) {
        _classCallCheck(this, BubbleTheme);

        if (options.modules.toolbar != null && options.modules.toolbar.container == null) {
          options.modules.toolbar.container = TOOLBAR_CONFIG;
        }

        var _this = _possibleConstructorReturn(this, (BubbleTheme.__proto__ || Object.getPrototypeOf(BubbleTheme)).call(this, quill, options));

        _this.quill.container.classList.add('ql-bubble');
        return _this;
      }

      _createClass(BubbleTheme, [{
        key: 'extendToolbar',
        value: function extendToolbar(toolbar) {
          this.tooltip = new BubbleTooltip(this.quill, this.options.bounds);
          this.tooltip.root.appendChild(toolbar.container);
          this.buildButtons([].slice.call(toolbar.container.querySelectorAll('button')), _icons2.default);
          this.buildPickers([].slice.call(toolbar.container.querySelectorAll('select')), _icons2.default);
        }
      }]);

      return BubbleTheme;
    }(_base2.default);

    BubbleTheme.DEFAULTS = (0, _extend2.default)(true, {}, _base2.default.DEFAULTS, {
      modules: {
        toolbar: {
          handlers: {
            link: function link(value) {
              if (!value) {
                this.quill.format('link', false);
              } else {
                this.quill.theme.tooltip.edit();
              }
            }
          }
        }
      }
    });

    var BubbleTooltip = function (_BaseTooltip) {
      _inherits(BubbleTooltip, _BaseTooltip);

      function BubbleTooltip(quill, bounds) {
        _classCallCheck(this, BubbleTooltip);

        var _this2 = _possibleConstructorReturn(this, (BubbleTooltip.__proto__ || Object.getPrototypeOf(BubbleTooltip)).call(this, quill, bounds));

        _this2.quill.on(_emitter2.default.events.EDITOR_CHANGE, function (type, range, oldRange, source) {
          if (type !== _emitter2.default.events.SELECTION_CHANGE) return;
          if (range != null && range.length > 0 && source === _emitter2.default.sources.USER) {
            _this2.show();
            // Lock our width so we will expand beyond our offsetParent boundaries
            _this2.root.style.left = '0px';
            _this2.root.style.width = '';
            _this2.root.style.width = _this2.root.offsetWidth + 'px';
            var lines = _this2.quill.getLines(range.index, range.length);
            if (lines.length === 1) {
              _this2.position(_this2.quill.getBounds(range));
            } else {
              var lastLine = lines[lines.length - 1];
              var index = _this2.quill.getIndex(lastLine);
              var length = Math.min(lastLine.length() - 1, range.index + range.length - index);
              var _bounds = _this2.quill.getBounds(new _selection.Range(index, length));
              _this2.position(_bounds);
            }
          } else if (document.activeElement !== _this2.textbox && _this2.quill.hasFocus()) {
            _this2.hide();
          }
        });
        return _this2;
      }

      _createClass(BubbleTooltip, [{
        key: 'listen',
        value: function listen() {
          var _this3 = this;

          _get(BubbleTooltip.prototype.__proto__ || Object.getPrototypeOf(BubbleTooltip.prototype), 'listen', this).call(this);
          this.root.querySelector('.ql-close').addEventListener('click', function () {
            _this3.root.classList.remove('ql-editing');
          });
          this.quill.on(_emitter2.default.events.SCROLL_OPTIMIZE, function () {
            // Let selection be restored by toolbar handlers before repositioning
            setTimeout(function () {
              if (_this3.root.classList.contains('ql-hidden')) return;
              var range = _this3.quill.getSelection();
              if (range != null) {
                _this3.position(_this3.quill.getBounds(range));
              }
            }, 1);
          });
        }
      }, {
        key: 'cancel',
        value: function cancel() {
          this.show();
        }
      }, {
        key: 'position',
        value: function position(reference) {
          var shift = _get(BubbleTooltip.prototype.__proto__ || Object.getPrototypeOf(BubbleTooltip.prototype), 'position', this).call(this, reference);
          var arrow = this.root.querySelector('.ql-tooltip-arrow');
          arrow.style.marginLeft = '';
          if (shift === 0) return shift;
          arrow.style.marginLeft = -1 * shift - arrow.offsetWidth / 2 + 'px';
        }
      }]);

      return BubbleTooltip;
    }(_base.BaseTooltip);

    BubbleTooltip.TEMPLATE = ['<span class="ql-tooltip-arrow"></span>', '<div class="ql-tooltip-editor">', '<input type="text" data-formula="e=mc^2" data-link="https://quilljs.com" data-video="Embed URL">', '<a class="ql-close"></a>', '</div>'].join('');

    exports.BubbleTooltip = BubbleTooltip;
    exports.default = BubbleTheme;

    /***/ }),
    /* 109 */
    /***/ (function(module, exports, __webpack_require__) {

    module.exports = __webpack_require__(63);


    /***/ })
    /******/ ])["default"];
    });
    });

    var Quill = unwrapExports(quill);

    /* src\components\QuillEditor.svelte generated by Svelte v3.32.3 */

    const { console: console_1$1 } = globals;
    const file$3 = "src\\components\\QuillEditor.svelte";

    function get_each_context(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[13] = list[i].file;
    	child_ctx[14] = list[i].percent_completed;
    	child_ctx[15] = list[i].index;
    	return child_ctx;
    }

    // (140:16) {#if percent_completed < 100 && percent_completed > 0}
    function create_if_block_1(ctx) {
    	let div1;
    	let div0;
    	let t0_value = /*percent_completed*/ ctx[14] + "";
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			t0 = text(t0_value);
    			t1 = text("%");
    			attr_dev(div0, "class", "m-auto text-white");
    			add_location(div0, file$3, 143, 24, 5134);
    			attr_dev(div1, "class", " w-full  h-full box-border absolute top-0 bg-black  bg-opacity-25 focus:outline-none flex justify-around  items-center ");
    			add_location(div1, file$3, 140, 20, 4928);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			append_dev(div0, t0);
    			append_dev(div0, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*imageFiles*/ 2 && t0_value !== (t0_value = /*percent_completed*/ ctx[14] + "")) set_data_dev(t0, t0_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1.name,
    		type: "if",
    		source: "(140:16) {#if percent_completed < 100 && percent_completed > 0}",
    		ctx
    	});

    	return block;
    }

    // (155:16) {#if percent_completed == 100}
    function create_if_block(ctx) {
    	let lable;
    	let div;
    	let i;

    	const block = {
    		c: function create() {
    			lable = element("lable");
    			div = element("div");
    			i = element("i");
    			attr_dev(i, "class", "ri-check-line text-white");
    			add_location(i, file$3, 171, 28, 6183);
    			attr_dev(div, "for", "");
    			set_style(div, "transform", "rotate(-45deg)");
    			set_style(div, "margin-top", "2px");
    			add_location(div, file$3, 167, 24, 6003);
    			attr_dev(lable, "class", "block");
    			set_style(lable, "position", "absolute");
    			set_style(lable, "right", "-15px");
    			set_style(lable, "top", "-6px");
    			set_style(lable, "width", "40px");
    			set_style(lable, "height", "24px");
    			set_style(lable, "background", "#13ce66");
    			set_style(lable, "text-align", "center");
    			set_style(lable, "transform", "rotate(45deg)");
    			set_style(lable, "box-shadow", "0 0 1pc 1px rgb(0 0 0 / 20%)");
    			add_location(lable, file$3, 155, 20, 5543);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, lable, anchor);
    			append_dev(lable, div);
    			append_dev(div, i);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(lable);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block.name,
    		type: "if",
    		source: "(155:16) {#if percent_completed == 100}",
    		ctx
    	});

    	return block;
    }

    // (126:8) {#each imageFiles as { file, percent_completed, index }
    function create_each_block(key_1, ctx) {
    	let div1;
    	let div0;
    	let button0;
    	let i0;
    	let t0;
    	let button1;
    	let i1;
    	let t1;
    	let t2;
    	let img;
    	let img_src_value;
    	let t3;
    	let t4;
    	let mounted;
    	let dispose;
    	let if_block0 = /*percent_completed*/ ctx[14] < 100 && /*percent_completed*/ ctx[14] > 0 && create_if_block_1(ctx);
    	let if_block1 = /*percent_completed*/ ctx[14] == 100 && create_if_block(ctx);

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			button0 = element("button");
    			i0 = element("i");
    			t0 = space();
    			button1 = element("button");
    			i1 = element("i");
    			t1 = space();
    			if (if_block0) if_block0.c();
    			t2 = space();
    			img = element("img");
    			t3 = space();
    			if (if_block1) if_block1.c();
    			t4 = space();
    			attr_dev(i0, "class", "m-auto ri-zoom-in-line ri-xl text-white");
    			add_location(i0, file$3, 133, 24, 4543);
    			add_location(button0, file$3, 132, 20, 4488);
    			attr_dev(i1, "class", "m-auto ri-delete-bin-line ri-xl text-white");
    			add_location(i1, file$3, 136, 24, 4723);
    			attr_dev(button1, "class", " ");
    			add_location(button1, file$3, 135, 20, 4649);
    			attr_dev(div0, "class", " w-16 h-16  box-border absolute top-0 opacity-0 bg-black hover:opacity-75 focus:outline-none flex justify-around  ");
    			add_location(div0, file$3, 129, 16, 4299);
    			attr_dev(img, "class", " w-full h-full object-cover");
    			if (img.src !== (img_src_value = getObjectURL(/*file*/ ctx[13]))) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "");
    			add_location(img, file$3, 149, 16, 5318);
    			attr_dev(div1, "class", "w-16 h-16 box-border  border-2 rounded mr-2 mb-2 relative overflow-hidden");
    			add_location(div1, file$3, 126, 12, 4163);
    			this.first = div1;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			append_dev(div0, button0);
    			append_dev(button0, i0);
    			append_dev(div0, t0);
    			append_dev(div0, button1);
    			append_dev(button1, i1);
    			append_dev(div1, t1);
    			if (if_block0) if_block0.m(div1, null);
    			append_dev(div1, t2);
    			append_dev(div1, img);
    			append_dev(div1, t3);
    			if (if_block1) if_block1.m(div1, null);
    			append_dev(div1, t4);

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", viewImage, false, false, false),
    					listen_dev(
    						button1,
    						"click",
    						function () {
    							if (is_function(/*deleteImage*/ ctx[5](/*index*/ ctx[15]))) /*deleteImage*/ ctx[5](/*index*/ ctx[15]).apply(this, arguments);
    						},
    						false,
    						false,
    						false
    					)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (/*percent_completed*/ ctx[14] < 100 && /*percent_completed*/ ctx[14] > 0) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_1(ctx);
    					if_block0.c();
    					if_block0.m(div1, t2);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (dirty & /*imageFiles*/ 2 && img.src !== (img_src_value = getObjectURL(/*file*/ ctx[13]))) {
    				attr_dev(img, "src", img_src_value);
    			}

    			if (/*percent_completed*/ ctx[14] == 100) {
    				if (if_block1) ; else {
    					if_block1 = create_if_block(ctx);
    					if_block1.c();
    					if_block1.m(div1, t4);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block.name,
    		type: "each",
    		source: "(126:8) {#each imageFiles as { file, percent_completed, index }",
    		ctx
    	});

    	return block;
    }

    function create_fragment$3(ctx) {
    	let div4;
    	let div0;
    	let t0;
    	let div1;
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let t1;
    	let div3;
    	let div2;
    	let button0;
    	let i0;
    	let t2;
    	let button1;
    	let i1;
    	let t3;
    	let button2;
    	let i2;
    	let t4;
    	let button3;
    	let i3;
    	let t5;
    	let button4;
    	let i4;
    	let t6;
    	let button5;
    	let i5;
    	let t7;
    	let input;
    	let t8;
    	let button6;
    	let mounted;
    	let dispose;
    	let each_value = /*imageFiles*/ ctx[1];
    	validate_each_argument(each_value);
    	const get_key = ctx => /*file*/ ctx[13];
    	validate_each_keys(ctx, each_value, get_each_context, get_key);

    	for (let i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block(key, child_ctx));
    	}

    	const block = {
    		c: function create() {
    			div4 = element("div");
    			div0 = element("div");
    			t0 = space();
    			div1 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t1 = space();
    			div3 = element("div");
    			div2 = element("div");
    			button0 = element("button");
    			i0 = element("i");
    			t2 = space();
    			button1 = element("button");
    			i1 = element("i");
    			t3 = space();
    			button2 = element("button");
    			i2 = element("i");
    			t4 = space();
    			button3 = element("button");
    			i3 = element("i");
    			t5 = space();
    			button4 = element("button");
    			i4 = element("i");
    			t6 = space();
    			button5 = element("button");
    			i5 = element("i");
    			t7 = space();
    			input = element("input");
    			t8 = space();
    			button6 = element("button");
    			button6.textContent = "发送";
    			attr_dev(div0, "id", "editor");
    			attr_dev(div0, "class", "list-decimal list-inside");
    			add_location(div0, file$3, 123, 4, 3950);
    			attr_dev(div1, "class", "flex flex-wrap flex-row  mt-4  pl-3");
    			add_location(div1, file$3, 124, 4, 4027);
    			attr_dev(i0, "class", "ri-hashtag");
    			add_location(i0, file$3, 182, 41, 6594);
    			attr_dev(button0, "class", "rounded-sm hover:bg-gray-200 p-1 focus:outline-none");
    			add_location(button0, file$3, 180, 12, 6467);
    			attr_dev(i1, "class", "ri-bold");
    			add_location(i1, file$3, 185, 17, 6738);
    			attr_dev(button1, "class", "ql-bold hover:bg-gray-200 p-1 focus:outline-none");
    			add_location(button1, file$3, 184, 12, 6655);
    			attr_dev(i2, "class", "ri-list-ordered hover:bg-gray-200 p-1 focus:outline-none");
    			add_location(i2, file$3, 190, 17, 6928);
    			attr_dev(button2, "class", "ql-list hover:bg-gray-200 p-1 focus:outline-none");
    			button2.value = "bullet";
    			add_location(button2, file$3, 187, 12, 6796);
    			attr_dev(i3, "class", "ri-list-check hover:bg-gray-200 p-1 focus:outline-none");
    			add_location(i3, file$3, 198, 17, 7208);
    			attr_dev(button3, "class", "ql-list hover:bg-gray-200 p-1 focus:outline-none");
    			button3.value = "ordered";
    			add_location(button3, file$3, 195, 12, 7075);
    			attr_dev(i4, "class", "ri-underline");
    			add_location(i4, file$3, 205, 17, 7458);
    			attr_dev(button4, "class", "ql-underline hover:bg-gray-200 p-1 focus:outline-none");
    			add_location(button4, file$3, 203, 12, 7353);
    			attr_dev(i5, "class", "ri-image-2-line ");
    			add_location(i5, file$3, 209, 40, 7648);
    			attr_dev(button5, "class", "rounded-sm hover:bg-gray-200 p-1 focus:outline-none ");
    			add_location(button5, file$3, 207, 12, 7521);
    			attr_dev(input, "class", "w-full  rounded-lg   p-2 bg-blue-400 text-white focus:outline-none");
    			attr_dev(input, "type", "file");
    			set_style(input, "display", "none");
    			attr_dev(input, "accept", "image/png, image/jpeg, image/gif, image/jpg");
    			input.multiple = true;
    			add_location(input, file$3, 211, 12, 7715);
    			attr_dev(div2, "id", "toolbar");
    			attr_dev(div2, "class", "space-x-2");
    			add_location(div2, file$3, 179, 8, 6417);
    			attr_dev(button6, "class", "rounded-sm bg-green-500 text-white pl-2 pr-2");
    			add_location(button6, file$3, 221, 8, 8110);
    			attr_dev(div3, "class", " flex justify-between  pl-3 pr-3");
    			add_location(div3, file$3, 178, 4, 6361);
    			attr_dev(div4, "class", "border-gray-200 border-solid border-4 rounded-lg mt-2 flex flex-col justify-start  pb-2");
    			add_location(div4, file$3, 120, 0, 3836);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div4, anchor);
    			append_dev(div4, div0);
    			/*div0_binding*/ ctx[7](div0);
    			append_dev(div4, t0);
    			append_dev(div4, div1);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div1, null);
    			}

    			append_dev(div4, t1);
    			append_dev(div4, div3);
    			append_dev(div3, div2);
    			append_dev(div2, button0);
    			append_dev(button0, i0);
    			append_dev(div2, t2);
    			append_dev(div2, button1);
    			append_dev(button1, i1);
    			append_dev(div2, t3);
    			append_dev(div2, button2);
    			append_dev(button2, i2);
    			append_dev(div2, t4);
    			append_dev(div2, button3);
    			append_dev(button3, i3);
    			append_dev(div2, t5);
    			append_dev(div2, button4);
    			append_dev(button4, i4);
    			append_dev(div2, t6);
    			append_dev(div2, button5);
    			append_dev(button5, i5);
    			append_dev(div2, t7);
    			append_dev(div2, input);
    			/*input_binding*/ ctx[8](input);
    			append_dev(div3, t8);
    			append_dev(div3, button6);

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*insertHashTag*/ ctx[6], false, false, false),
    					listen_dev(button5, "click", /*selectImages*/ ctx[4], false, false, false),
    					listen_dev(input, "change", /*input_change_handler*/ ctx[9]),
    					listen_dev(button6, "click", sendBiu, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*imageFiles, getObjectURL, deleteImage, viewImage*/ 34) {
    				each_value = /*imageFiles*/ ctx[1];
    				validate_each_argument(each_value);
    				validate_each_keys(ctx, each_value, get_each_context, get_key);
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, div1, destroy_block, create_each_block, null, get_each_context);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div4);
    			/*div0_binding*/ ctx[7](null);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d();
    			}

    			/*input_binding*/ ctx[8](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$3.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function viewImage(params) {
    	
    }

    function getObjectURL(file) {
    	var url = null;

    	// 下面函数执行的效果是一样的，只是需要针对不同的浏览器执行不同的 js 函数而已
    	if (window.createObjectURL != undefined) {
    		// basic
    		url = window.createObjectURL(file);
    	} else if (window.URL != undefined) {
    		// mozilla(firefox)
    		url = window.URL.createObjectURL(file);
    	} else if (window.webkitURL != undefined) {
    		// webkit or chrome
    		url = window.webkitURL.createObjectURL(file);
    	}

    	return url;
    }

    function sendBiu() {
    	
    }

    function instance$3($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("QuillEditor", slots, []);
    	let editor = "";
    	let content = "";
    	let uploadimageNode = "";
    	let uploadimagefiles = [];
    	let imageFiles = [];

    	function joinFile(uploadimagefiles) {
    		let filelist = Array.from(uploadimagefiles);
    		let indexcount = 0;
    		console.log(uploadimagefiles);
    		let tempfiles = imageFiles;

    		filelist.forEach(element => {
    			tempfiles = [
    				...tempfiles,
    				{
    					file: element,
    					percent_completed: 0,
    					index: indexcount,
    					uploadingstatus: "未上传", //"上传中","已上传"
    					
    				}
    			];

    			indexcount++;
    		});

    		return tempfiles;
    	}

    	onMount(() => {
    		var options = {
    			// debug: "info",
    			modules: { toolbar: "#toolbar" },
    			placeholder: "现在的想法是..."
    		}; // theme: "snow",

    		$$invalidate(2, editor = new Quill("#editor", options));
    		editor.focus();
    	});

    	function selectImages(params) {
    		uploadimageNode.click();
    	}

    	function deleteImage(index) {
    		$$invalidate(1, imageFiles = imageFiles.filter(item => {
    			return item.index != index;
    		}));
    	}

    	function insertHashTag() {
    		editor.insertText(0, "#", { color: "#000", italic: true });
    	}

    	function uploadPic(imageFile, index) {
    		var formData = new FormData();
    		var fileField = imageFile.file;
    		formData.append("file", fileField);
    		let request = new XMLHttpRequest();
    		request.open("POST", "http://127.0.0.1:8888/cat/uploadPic");

    		// upload progress event
    		request.upload.addEventListener("progress", function (e) {
    			// upload progress as percentage
    			let percent_completed = e.loaded / e.total * 100;

    			$$invalidate(1, imageFiles[index].percent_completed = parseInt(percent_completed + ""), imageFiles);

    			if (percent_completed >= 100) {
    				$$invalidate(1, imageFiles[index].uploadingstatus = "已上传", imageFiles);
    			}

    			console.log(percent_completed, index, imageFiles[index].percent_completed);
    		});

    		// request finished event
    		request.addEventListener("load", function (e) {
    			// HTTP status message (200, 404 etc)
    			console.log(request.status);

    			// request.response holds response from the server
    			console.log(request.response);
    		});

    		// send POST request to server
    		request.send(formData);
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$1.warn(`<QuillEditor> was created with unknown prop '${key}'`);
    	});

    	function div0_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			editor = $$value;
    			$$invalidate(2, editor);
    		});
    	}

    	function input_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			uploadimageNode = $$value;
    			$$invalidate(3, uploadimageNode);
    		});
    	}

    	function input_change_handler() {
    		uploadimagefiles = this.files;
    		$$invalidate(0, uploadimagefiles);
    	}

    	$$self.$capture_state = () => ({
    		onMount,
    		Quill,
    		editor,
    		content,
    		uploadimageNode,
    		uploadimagefiles,
    		imageFiles,
    		joinFile,
    		selectImages,
    		viewImage,
    		deleteImage,
    		insertHashTag,
    		getObjectURL,
    		uploadPic,
    		sendBiu
    	});

    	$$self.$inject_state = $$props => {
    		if ("editor" in $$props) $$invalidate(2, editor = $$props.editor);
    		if ("content" in $$props) content = $$props.content;
    		if ("uploadimageNode" in $$props) $$invalidate(3, uploadimageNode = $$props.uploadimageNode);
    		if ("uploadimagefiles" in $$props) $$invalidate(0, uploadimagefiles = $$props.uploadimagefiles);
    		if ("imageFiles" in $$props) $$invalidate(1, imageFiles = $$props.imageFiles);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*uploadimagefiles*/ 1) {
    			 $$invalidate(1, imageFiles = joinFile(uploadimagefiles));
    		}

    		if ($$self.$$.dirty & /*imageFiles*/ 2) {
    			 {
    				for (let index = 0; index < imageFiles.length; index++) {
    					const element = imageFiles[index];
    					console.log(index, element);

    					if (element.uploadingstatus == "未上传") {
    						element.uploadingstatus = "上传中";
    						uploadPic(element, index);
    					}
    				}
    			}
    		}
    	};

    	return [
    		uploadimagefiles,
    		imageFiles,
    		editor,
    		uploadimageNode,
    		selectImages,
    		deleteImage,
    		insertHashTag,
    		div0_binding,
    		input_binding,
    		input_change_handler
    	];
    }

    class QuillEditor extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$3, create_fragment$3, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "QuillEditor",
    			options,
    			id: create_fragment$3.name
    		});
    	}
    }

    /* src\components\SideRight.svelte generated by Svelte v3.32.3 */
    const file$4 = "src\\components\\SideRight.svelte";

    function create_fragment$4(ctx) {
    	let div3;
    	let div2;
    	let div0;
    	let t1;
    	let div1;
    	let i;
    	let t2;
    	let input;
    	let t3;
    	let quilleditor;
    	let current;
    	quilleditor = new QuillEditor({ $$inline: true });

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			div2 = element("div");
    			div0 = element("div");
    			div0.textContent = "MEMO";
    			t1 = space();
    			div1 = element("div");
    			i = element("i");
    			t2 = space();
    			input = element("input");
    			t3 = space();
    			create_component(quilleditor.$$.fragment);
    			add_location(div0, file$4, 8, 8, 297);
    			attr_dev(i, "class", "ri-search-2-line text-gray-300");
    			add_location(i, file$4, 11, 12, 400);
    			attr_dev(input, "class", " ml-2 bg-gray-200 focus:outline-none");
    			attr_dev(input, "type", "text");
    			add_location(input, file$4, 12, 12, 458);
    			attr_dev(div1, "class", "bg-gray-200 rounded-lg h-8 p-2 flex items-center");
    			add_location(div1, file$4, 10, 8, 324);
    			attr_dev(div2, "class", "  flex flex-row items-center justify-between");
    			add_location(div2, file$4, 7, 4, 229);
    			attr_dev(div3, "class", "  flex-1 flex flex-col justify-start p-4 ");
    			add_location(div3, file$4, 6, 0, 168);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div2);
    			append_dev(div2, div0);
    			append_dev(div2, t1);
    			append_dev(div2, div1);
    			append_dev(div1, i);
    			append_dev(div1, t2);
    			append_dev(div1, input);
    			append_dev(div3, t3);
    			mount_component(quilleditor, div3, null);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(quilleditor.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(quilleditor.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    			destroy_component(quilleditor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$4.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$4($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("SideRight", slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<SideRight> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ Editor, ProEditor, QuillEditor });
    	return [];
    }

    class SideRight extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$4, create_fragment$4, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SideRight",
    			options,
    			id: create_fragment$4.name
    		});
    	}
    }

    /* src\components\HelloWorld.svelte generated by Svelte v3.32.3 */

    const { console: console_1$2 } = globals;
    const file$5 = "src\\components\\HelloWorld.svelte";

    function create_fragment$5(ctx) {
    	let div1;
    	let div0;
    	let sideleft;
    	let t;
    	let sideright;
    	let current;
    	sideleft = new SideLeft({ $$inline: true });
    	sideright = new SideRight({ $$inline: true });

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			create_component(sideleft.$$.fragment);
    			t = space();
    			create_component(sideright.$$.fragment);
    			attr_dev(div0, "class", "max-w-6xl min-w-0 w-full  flex ");
    			add_location(div0, file$5, 15, 2, 387);
    			attr_dev(div1, "class", "w-full  h-screen flex flex-col items-center justify-start mt-2");
    			add_location(div1, file$5, 14, 0, 308);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			mount_component(sideleft, div0, null);
    			append_dev(div0, t);
    			mount_component(sideright, div0, null);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(sideleft.$$.fragment, local);
    			transition_in(sideright.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(sideleft.$$.fragment, local);
    			transition_out(sideright.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			destroy_component(sideleft);
    			destroy_component(sideright);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$5.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$5($$self, $$props, $$invalidate) {
    	let $count;
    	validate_store(count, "count");
    	component_subscribe($$self, count, $$value => $$invalidate(0, $count = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("HelloWorld", slots, []);

    	function incrementCount() {
    		console.log($count);
    		count.set($count + 3);
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$2.warn(`<HelloWorld> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		count,
    		SideLeft,
    		SideRight,
    		incrementCount,
    		$count
    	});

    	return [];
    }

    class HelloWorld extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$5, create_fragment$5, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "HelloWorld",
    			options,
    			id: create_fragment$5.name
    		});
    	}
    }

    /* src\components\Router.svelte generated by Svelte v3.32.3 */

    const { console: console_1$3 } = globals;

    function create_fragment$6(ctx) {
    	const block = {
    		c: noop,
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: noop,
    		p: noop,
    		i: noop,
    		o: noop,
    		d: noop
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$6.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$6($$self, $$props) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Router", slots, []);

    	window.onload = function () {
    		if (window.location.search.length > 0) {
    			const params = window.location.search.substr(1);

    			params.split("&").forEach(param => {
    				const key = param.split("=")[0];
    				const value = parseFloat(param.split("=")[1]);
    				console.log(`Parameter of ${key} is ${value}`);
    			});
    		}
    	};

    	/**
     * Handle broswer back events here
     */
    	window.onpopstate = function (event) {
    		if (event.state) ;
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$3.warn(`<Router> was created with unknown prop '${key}'`);
    	});

    	return [];
    }

    class Router extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$6, create_fragment$6, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Router",
    			options,
    			id: create_fragment$6.name
    		});
    	}
    }

    /* src\App.svelte generated by Svelte v3.32.3 */
    const file$6 = "src\\App.svelte";

    function create_fragment$7(ctx) {
    	let main;
    	let router;
    	let t;
    	let helloworld;
    	let current;
    	router = new Router({ $$inline: true });
    	helloworld = new HelloWorld({ $$inline: true });

    	const block = {
    		c: function create() {
    			main = element("main");
    			create_component(router.$$.fragment);
    			t = space();
    			create_component(helloworld.$$.fragment);
    			attr_dev(main, "class", "overflow-hidden");
    			add_location(main, file$6, 9, 0, 242);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			mount_component(router, main, null);
    			append_dev(main, t);
    			mount_component(helloworld, main, null);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(router.$$.fragment, local);
    			transition_in(helloworld.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(router.$$.fragment, local);
    			transition_out(helloworld.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			destroy_component(router);
    			destroy_component(helloworld);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$7.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$7($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("App", slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<App> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ HelloWorld, Router });
    	return [];
    }

    class App extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$7, create_fragment$7, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "App",
    			options,
    			id: create_fragment$7.name
    		});
    	}
    }

    const app = new App({
      target: document.body
    });

}());
//# sourceMappingURL=main.js.map
